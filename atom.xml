<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DeppWang&#39;s Blog</title>
  
  <subtitle>这是副标题</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://depp.wang/"/>
  <updated>2020-06-11T13:09:39.066Z</updated>
  <id>https://depp.wang/</id>
  
  <author>
    <name>DeppWang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何查找某个网站的（如：有道云笔记）的接口</title>
    <link href="https://depp.wang/2020/06/11/how-to-find-the-api-of-a-website-eg-note-youdao-com/"/>
    <id>https://depp.wang/2020/06/11/how-to-find-the-api-of-a-website-eg-note-youdao-com/</id>
    <published>2020-06-11T20:48:37.000Z</published>
    <updated>2020-06-11T13:09:39.066Z</updated>
    
    <content type="html"><![CDATA[<p>开发了个 《一键导出 / 备份「有道云笔记」所有笔记》的<a href="https://github.com/DeppWang/youdaonote-pull" target="_blank" rel="noopener">脚本</a>。主要原理是利用有道云笔记本身的接口。下面是根据正常用户操作逻辑，找到需要的接口，主要是登录和「下载」。</p><a id="more"></a><h2 id="一、登录"><a href="#一、登录" class="headerlink" title="一、登录"></a>一、登录</h2><p>登录的目的是获取 Cookie</p><h3 id="1-1-找登录接口"><a href="#1-1-找登录接口" class="headerlink" title="1.1 找登录接口"></a>1.1 找登录接口</h3><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-06-10-150019.png" alt="image-20200610230018739" style="zoom:50%;"><p>接口应该在登录时执行。使用<strong>错误密码</strong>测试，可得到登录 post 请求接口。注意过滤条件是 All</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://note.youdao.com/login/acc/urs/verify/<span class="meta">check</span>?app=web<span class="variable">&amp;product</span>=YNOTE<span class="variable">&amp;tp</span>=urstoken<span class="variable">&amp;cf</span>=6<span class="variable">&amp;fr</span>=1<span class="variable">&amp;systemName</span>=<span class="variable">&amp;deviceType</span>=<span class="variable">&amp;ru</span>=</span><br><span class="line">https://note.youdao.com/signIn//loginCallback.html<span class="variable">&amp;er</span>=</span><br><span class="line">https://note.youdao.com/signIn//loginCallback.html&amp;</span><br><span class="line">vcode=dman9<span class="variable">&amp;systemName</span>=mac<span class="variable">&amp;deviceType</span>=MacPC<span class="variable">&amp;timestamp</span>=1591770253472</span><br></pre></td></tr></table></figure><h3 id="1-2-推导密码加密规则"><a href="#1-2-推导密码加密规则" class="headerlink" title="1.2 推导密码加密规则"></a>1.2 推导密码加密规则</h3><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-06-10-062936.png" alt="image-20200610142935436"></p><p>本地测试使用同样错误密码用不同加密算法加密，看加密结果是否一致</p><p>发现使用 md5 加密</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Python</span></span><br><span class="line">password=hashlib.md5(password.encode(<span class="string">'utf-8'</span>)).hexdigest()</span><br></pre></td></tr></table></figure><h3 id="1-3-找返回验证登录状态-Cookie-的接口"><a href="#1-3-找返回验证登录状态-Cookie-的接口" class="headerlink" title="1.3 找返回验证登录状态 Cookie 的接口"></a>1.3 找返回验证登录状态 Cookie 的接口</h3><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-06-10-091312.png" alt="image-20200610171312277" style="zoom:50%;"><p>登录成功后，会返回验证登录状态的 Cookie。接口应该在登录成功后执行。发现跳转首页后第一个 XHR 接口中包含验证登录状态的 Cookie，YNOTE_CSTK</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://note.youdao.com/yws/api/<span class="keyword">user</span>?<span class="keyword">method</span>=<span class="keyword">get</span>&amp;multilevelEnable=<span class="keyword">true</span></span><br></pre></td></tr></table></figure><!--只需要有 YNOTE_CSTK 和 YNOTE_SESS 两个即可登录，两个都需要登录成功后的值，不一定要一起返回的。只暴露 YNOTE_CSTK 不用担心账号被登录--><h2 id="二、「下载」"><a href="#二、「下载」" class="headerlink" title="二、「下载」"></a>二、「下载」</h2><h3 id="2-1-找返回根目录-id-的接口"><a href="#2-1-找返回根目录-id-的接口" class="headerlink" title="2.1 找返回根目录 id 的接口"></a>2.1 找返回根目录 id 的接口</h3><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-06-11-054205.png" alt="image-20200611134205218" style="zoom:50%;"><p>我们根据一个笔记 URL 可以看出，URL 里包含了父文件夹 id 和当前文件 id。「我的文件夹」下的 test.md 的 URL：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span>/<span class="regexp">/note.youdao.com/web</span><span class="regexp">/#/file</span><span class="regexp">/F83DF1ADA69344D194C7CE861D09B1A1/note</span><span class="regexp">/WEB4aa8bf8074d61befea1dd20f5593f01c/</span></span><br></pre></td></tr></table></figure><p>「我的文件夹」 是根目录，它的 id 是 <code>F83DF1ADA69344D194C7CE861D09B1A1</code>，下面称它为 root_id。</p><p>我们推测，有道云笔记是设计是根据文件夹 id，获取文件夹下的所有文件信息（打开文件夹，可看到文件夹下的文件）。所以我们需要先得到 root_id。当登录成功后，跳转到首页时，应该有接口能得到 root_id。</p><p>测试发现下面接口返回值包含 root_id：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>note.youdao.com<span class="regexp">/yws/</span>api<span class="regexp">/personal/</span>file?method=getByPath&amp;keyfrom=web&amp;cstk=<span class="number">01</span>PvSwwu</span><br></pre></td></tr></table></figure><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-06-11-070108.png" alt="image-20200611150107522" style="zoom:50%;"><p>接口返回格式类似这样：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"fileEntry"</span>:&#123;</span><br><span class="line">        <span class="attr">"userId"</span>:<span class="string">"m17191082115@163.com"</span>,</span><br><span class="line">        "id":"F83DF1ADA69344D194C7CE861D09B1A1", // root_id</span><br><span class="line">        "version":22888,</span><br><span class="line">        "name":"ROOT",</span><br><span class="line">        "parentId":"0",</span><br><span class="line">        "createTimeForSort":1497860357,</span><br><span class="line">        "modifyTimeForSort":1497860357,</span><br><span class="line">        ....</span><br><span class="line">    &#125;,</span><br><span class="line">    "fileMeta":&#123;</span><br><span class="line">        "chunkList":"None",</span><br><span class="line">        "sharedCount":0,</span><br><span class="line">        "title":"ROOT",</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root_id = response.content[<span class="string">'fileEntry'</span>][<span class="string">'id'</span>]</span><br></pre></td></tr></table></figure><h3 id="2-2-找获取目录下所有文件信息的接口"><a href="#2-2-找获取目录下所有文件信息的接口" class="headerlink" title="2.2 找获取目录下所有文件信息的接口"></a>2.2 找获取目录下所有文件信息的接口</h3><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-06-11-052343.png" alt="image-20200611132342543" style="zoom:50%;"><p>有了 root_id，需要找到根据 id 获取目录下所有文件信息的接口。</p><p>接口应该在打开文件夹时执行。点击某一个文件夹，测试发现包含当前目录所有文件信息的接口为：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://note.youdao.com/yws/api/personal/<span class="meta">file</span>/9d8a2385eeec77338211b4f04bbf844d?all=true<span class="variable">&amp;f</span>=true<span class="variable">&amp;len</span>=30<span class="variable">&amp;sort</span>=1<span class="variable">&amp;isReverse</span>=false<span class="variable">&amp;method</span>=listPageByParentId<span class="variable">&amp;keyfrom</span>=web<span class="variable">&amp;cstk</span>=01PvSwwu</span><br></pre></td></tr></table></figure><p>接口返回格式跟上面差不多，只是数量更多，属性多了 parentId（父文件夹 id）。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"fileEntry"</span>:&#123;</span><br><span class="line">            <span class="attr">"userId"</span>:<span class="string">"m17191082115@163.com"</span>,</span><br><span class="line">            <span class="attr">"id"</span>:<span class="string">"9d8a2385eeec77338211b4f04bbf844d"</span>,</span><br><span class="line">            <span class="attr">"version"</span>:<span class="number">14168</span>,</span><br><span class="line">            <span class="attr">"name"</span>:<span class="string">"来自手机"</span>,</span><br><span class="line">            "parentId":"F83DF1ADA69344D194C7CE861D09B1A1", // 父文件夹的 id，此时是 root_id</span><br><span class="line">            "createTimeForSort":1550712995,</span><br><span class="line">            "modifyTimeForSort":1550713003,</span><br><span class="line">            ....</span><br><span class="line">        &#125;,</span><br><span class="line">        "fileMeta":&#123;</span><br><span class="line">            "chunkList":null,</span><br><span class="line">            "sharedCount":0,</span><br><span class="line">            "title":"来自手机",</span><br><span class="line">            "fileSize":0,</span><br><span class="line">            ...</span><br><span class="line">        &#125;,</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="2-3-找到获取文件内容的接口"><a href="#2-3-找到获取文件内容的接口" class="headerlink" title="2.3 找到获取文件内容的接口"></a>2.3 找到获取文件内容的接口</h3><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-06-10-095111.png" alt="image-20200610175111568" style="zoom:50%;"><p>通过文件夹 id 得到了文件 id（fileId），需要找到根据 fileId 获取文件内容的接口。</p><p>接口应该在点击笔记标题得到笔记内容时执行。点击某一篇笔记标题，可以找到获取文件内容的接口：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>note.youdao.com<span class="regexp">/yws/</span>api<span class="regexp">/personal/</span>sync?method=download&amp;keyfrom=web&amp;cstk=<span class="number">01</span>PvSwwu</span><br></pre></td></tr></table></figure><h2 id="三、模拟浏览器操作"><a href="#三、模拟浏览器操作" class="headerlink" title="三、模拟浏览器操作"></a>三、模拟浏览器操作</h2><h3 id="3-1-设置请求头"><a href="#3-1-设置请求头" class="headerlink" title="3.1 设置请求头"></a>3.1 设置请求头</h3><p>随便哪个页面（如：首页 <code>https://note.youdao.com/</code>）可以看到请求头包含下面这些内容：</p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-06-10-102800.png" alt="image-20200610182800122" style="zoom:50%;"><p>取一部分设置即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YoudaoNoteSession</span><span class="params">(requests.Session)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        self.headers = &#123;</span><br><span class="line">            <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36'</span>,</span><br><span class="line">            <span class="string">'Accept'</span>: <span class="string">'*/*'</span>,</span><br><span class="line">            <span class="string">'Accept-Encoding'</span>: <span class="string">'gzip, deflate, br'</span>,</span><br><span class="line">            <span class="string">'Accept-Language'</span>: <span class="string">'zh-CN,zh;q=0.9,en;q=0.8'</span>,</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-模拟打开首页"><a href="#3-2-模拟打开首页" class="headerlink" title="3.2 模拟打开首页"></a>3.2 模拟打开首页</h3><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-06-10-113424.png" alt="image-20200610193423993" style="zoom: 50%;"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.get(<span class="string">'https://note.youdao.com/'</span>)</span><br></pre></td></tr></table></figure><p>点击「进入网页版」，会重定向到登录页面</p><h3 id="3-3-模拟打开登录页"><a href="#3-3-模拟打开登录页" class="headerlink" title="3.3 模拟打开登录页"></a>3.3 模拟打开登录页</h3><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-06-10-060620.png" alt="image-20200610140619564" style="zoom: 67%;"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.get(<span class="string">'https://note.youdao.com/signIn/index.html?&amp;callback=https%3A%2F%2Fnote.youdao.com%2Fweb%2F&amp;from=web'</span>)</span><br></pre></td></tr></table></figure><p>跳转登录页后，要执行下面 3 个接口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.get(<span class="string">'https://note.youdao.com/login/acc/pe/getsess?product=YNOTE&amp;_='</span> + timestamp())</span><br><span class="line">self.get(<span class="string">'https://note.youdao.com/auth/cq.json?app=web&amp;_='</span> + timestamp())</span><br><span class="line">self.get(<span class="string">'https://note.youdao.com/auth/urs/login.json?app=web&amp;_='</span> + timestamp())</span><br></pre></td></tr></table></figure><h2 id="四、结语"><a href="#四、结语" class="headerlink" title="四、结语"></a>四、结语</h2><p>根据找到的接口，模拟用户操作也有不少应用场景。除了开发像导出文件的脚本，可以开发一切你想自动化执行的操作。比方 cnblogs、juejin 发文章等。比较麻烦的就是像上面这样找接口了，可以先看看有没有人有过总结。</p><p>也可以利用一些浏览器的 API，如 <a href="https://github.com/puppeteer/puppeteer" target="_blank" rel="noopener">Puppeteer</a>，它提供一个真实的浏览器环境，可以真正模拟用户操作，不需要找到所有接口，只需要设置网页 url，以及设置需要操作的「按钮」属性。因为提供浏览器环境，它属于重量级操作。可以看看 <a href="https://github.com/crawlab-team/artipub" target="_blank" rel="noopener">ArtiPub</a> 如何使用 Puppeteer。这种方式有点不好的地方就是平台可能改前端属性，需要注意更新。</p><!--有什么不明白的看看[源码](http://github.com/DeppWang/youdaonote-pull/blob/master/pull.py)就知道了。--><p>全文完。</p><!--cnblogs.com 发布文章是用 i.cnblogs.com/api/posts 接口。所以 ArtiPub 没有接口？-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开发了个 《一键导出 / 备份「有道云笔记」所有笔记》的&lt;a href=&quot;https://github.com/DeppWang/youdaonote-pull&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;脚本&lt;/a&gt;。主要原理是利用有道云笔记本身的接口。下面是根据正常用户操作逻辑，找到需要的接口，主要是登录和「下载」。&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="https://depp.wang/categories/Network/"/>
    
    
      <category term="有道云笔记" scheme="https://depp.wang/tags/YouDaoNote/"/>
    
      <category term="接口" scheme="https://depp.wang/tags/%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>iTranswarp 部署记录</title>
    <link href="https://depp.wang/2020/05/26/itranswarp-deploy-record/"/>
    <id>https://depp.wang/2020/05/26/itranswarp-deploy-record/</id>
    <published>2020-05-26T17:58:35.000Z</published>
    <updated>2020-06-11T13:09:39.058Z</updated>
    
    <content type="html"><![CDATA[<p>作者：<a href="https://depp.wang">DeppWang</a>、<a href="https://depp.wang/2020/05/26/itranswarp-deploy-record/">原文地址</a></p><p>目的：使用 <a href="https://github.com/michaelliao/itranswarp" target="_blank" rel="noopener">iTranswarp</a> 学习 ngix 配置</p><p>如果你只想本地启动，直接修改 ip，使用 docker-compose 即可</p><a id="more"></a><h2 id="Google-Cloud-Platform-配置"><a href="#Google-Cloud-Platform-配置" class="headerlink" title="Google Cloud Platform 配置"></a>Google Cloud Platform 配置</h2><p>本地部署耗资源，服务器部署</p><p>腾讯云 clone GitHub 项目太慢，使用 <a href="https://console.cloud.google.com/" target="_blank" rel="noopener">Google Cloud Platform</a>，招商银行国际信用卡注册</p><p>Compute Engine 新建「虚拟机实例」 CentOS7</p><p>实例配置（防火墙）入站端口</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">0</span> tcp:<span class="number">13306</span>,<span class="number">16379</span>,<span class="number">443</span>,<span class="number">80</span></span><br></pre></td></tr></table></figure><p>「元数据」添加公钥 id_rsa.pub，使用 SSH 公钥登录，原理请看<a href="https://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="noopener">SSH 原理与运用（一）：远程登录</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh -i ~/.ssh/id_rsa(私钥) your_user_name@ip</span><br><span class="line"></span><br><span class="line">ssh -i ~/.ssh/id_rsa_4 deppwxq@35.201.176.108 # 示例</span><br></pre></td></tr></table></figure><p>安装 Git、配置别名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install git-core</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.st status</span><br><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.unstage <span class="string">'reset HEAD'</span></span><br><span class="line">git config --global alias.last <span class="string">'log -1'</span></span><br><span class="line">git config --global alias.lg <span class="string">"log --color --graph --pretty=format:'% Cred% h% Creset -% C(yellow)% d% Creset % s % Cgreen(% cr) % C(bold blue)&lt;% an&gt;% Creset' --abbrev-commit"</span></span><br></pre></td></tr></table></figure><p>切换为 ohmyzsh（个人习惯）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo yum update &amp;&amp; sudo yum -y install zsh</span><br><span class="line">sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换 zsh 失败时，重新切换</span></span><br><span class="line">sudo chsh -s /bin/zsh your_user_name</span><br><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure><ul><li>可能需要输入用户密码，用户密码为 Google 账号密码</li><li>未生效时重启实例，重启 ip 会变！</li></ul><p>语言设置为英文（默认就是英文，为何 Git 显示中文）</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">localectl</span></span><br></pre></td></tr></table></figure><p>安装 <a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">Docker</a>，<a href="https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">Docker 教程</a></p><p>安装 <a href="https://docs.docker.com/compose/install/#install-compose" target="_blank" rel="noopener">Docker-Compose</a>，<a href="https://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html" target="_blank" rel="noopener">Docker-Compose 教程</a></p><p>重启实例，ip 会变！需要重启 docker daemon</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo<span class="built_in"> service </span>docker start</span><br></pre></td></tr></table></figure><h2 id="服务器运行项目"><a href="#服务器运行项目" class="headerlink" title="服务器运行项目"></a>服务器运行项目</h2><p>先 fork 项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/your-name/itranswarp.git <span class="comment"># 使用 HTTPS</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> itranswarp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> docker</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp .env.example .env</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim .env <span class="comment"># 修改为服务器公网 ip</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker-compose up <span class="comment"># 启动</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker-compose stop <span class="comment"># 停止</span></span></span><br></pre></td></tr></table></figure><p>修改服务器 hosts，相当于 DNS</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim <span class="regexp">/etc/</span>hosts</span><br></pre></td></tr></table></figure><p>使用 <a href="https://zh.wikipedia.org/wiki/Lynx" target="_blank" rel="noopener">lynx</a> 模拟服务器本地浏览器打开 <code>https://www.local.itranswarp.com/</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install lynx</span><br><span class="line">lynx https://www.local.itranswarp.com/</span><br></pre></td></tr></table></figure><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-05-25-143614.png" alt="image-20200525223613874"></p><p>远程连接 Redis</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 远程连接</span></span><br><span class="line">redis-cli -h XXX.XXX.XXX.XXX(ip) -p port -a password</span><br><span class="line">redis-cli -h ip -p 16379 -a JFPRJ</span><br></pre></td></tr></table></figure><p>远程连接 Mysql 使用 Navicat Premium</p><p>进入容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker container exec -it [containerId] /bin/bash # 启动容器实例 bash</span><br><span class="line">or</span><br><span class="line">docker exec -it [containerId] /bin/bash</span><br></pre></td></tr></table></figure><h2 id="使用自定义域名"><a href="#使用自定义域名" class="headerlink" title="使用自定义域名"></a>使用自定义域名</h2><h3 id="配置域名解析"><a href="#配置域名解析" class="headerlink" title="配置域名解析"></a>配置域名解析</h3><p>（例：万网）配置域名解析</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A www.xingquan.wang ip</span><br><span class="line">A static.xingquan.wang ip</span><br><span class="line">A source.xingquan.wang ip</span><br><span class="line">A @xingquan.wang ip</span><br></pre></td></tr></table></figure><h3 id="申请数字证书"><a href="#申请数字证书" class="headerlink" title="申请数字证书"></a>申请数字证书</h3><p><a href="https://freessl.org/" target="_blank" rel="noopener">freessl</a> 申请免费数字证书</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">www<span class="selector-class">.xingquan</span><span class="selector-class">.wang</span></span><br><span class="line">static<span class="selector-class">.xingquan</span><span class="selector-class">.wang</span></span><br><span class="line">source<span class="selector-class">.xingquan</span><span class="selector-class">.wang</span></span><br><span class="line">xingquan.wang</span><br></pre></td></tr></table></figure><p>可四个域名同时申请同一个数字证书，也可分开申请</p><p>离线申请，使用 <a href="https://keymanager.org/" target="_blank" rel="noopener">KeyManager</a>，最后「导出证书」，解压可得到两个文件：<code>**</code>.crt，<code>**</code>.key。crt 为数字证书，key 为服务器私钥，深入理解请看<a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=2665513779&idx=1&sn=a1de58690ad4f95111e013254a026ca2&chksm=80d67b70b7a1f26697fa1626b3e9830dbdf4857d7a9528d22662f2e43af149265c4fd1b60024&scene=21#wechat_redirect" target="_blank" rel="noopener">一个故事讲完 https</a></p><h3 id="修改项目配置文件"><a href="#修改项目配置文件" class="headerlink" title="修改项目配置文件"></a>修改项目配置文件</h3><p>clone fork 项目到本地，（切换分支）修改配置。</p><p>全局将 local.itranswarp.com 修改为你的域名（如：xingquan.wang）</p><p>修改 local.itranswarp.com.crt / local.itranswarp.com.key 为 xingquan.wang.crt、xingquan.wang.key，使用「导出证书」的 crt、key 替换。local-conf 文件夹下可不修改</p><p>修改配置后，只重启 docker-compose（容器），配置是否生效？生效</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><a href="https://www.xingquan.wang" target="_blank" rel="noopener">https://www.xingquan.wang</a></p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-05-26-084417.png" alt="image-20200526164417094" style="zoom:50%;"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学习到</p><ul><li>HTTPS、证书</li><li>ngix 配置</li></ul><p>问题：</p><ul><li>Docker 如何进入容器操作，如查看日志、修改数据库</li><li>iTranswarp 作为博客，没有订阅地址？</li></ul><p>admin 默认密码为 123456</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者：&lt;a href=&quot;https://depp.wang&quot;&gt;DeppWang&lt;/a&gt;、&lt;a href=&quot;https://depp.wang/2020/05/26/itranswarp-deploy-record/&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目的：使用 &lt;a href=&quot;https://github.com/michaelliao/itranswarp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iTranswarp&lt;/a&gt; 学习 ngix 配置&lt;/p&gt;
&lt;p&gt;如果你只想本地启动，直接修改 ip，使用 docker-compose 即可&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://depp.wang/categories/Linux/"/>
    
    
      <category term="iTranswarp" scheme="https://depp.wang/tags/iTranswarp/"/>
    
  </entry>
  
  <entry>
    <title>一个一键导出/备份「有道云笔记」所有笔记的脚本</title>
    <link href="https://depp.wang/2020/05/18/export-youdaonote-all-notes/"/>
    <id>https://depp.wang/2020/05/18/export-youdaonote-all-notes/</id>
    <published>2020-05-18T13:26:55.000Z</published>
    <updated>2020-06-11T13:09:39.062Z</updated>
    
    <content type="html"><![CDATA[<p>作者：<a href="https://depp.wang">DeppWang</a>、<a href="https://depp.wang/2020/05/18/export-youdaonote-all-notes/">原文地址</a></p><h2 id="出发点"><a href="#出发点" class="headerlink" title="出发点"></a>出发点</h2><p>原来一直是有道云笔记的忠实用户，后面接触到了所见即所得的 <a href="https://typora.io/" target="_blank" rel="noopener">Typora</a>，有点用不惯有道云笔记了，想着有什么法子能电脑本地文件和有道云笔记同步，这样电脑使用 Typora，手机使用有道云笔记。发现有道云笔记有 <a href="http://note.youdao.com/open/developguide.html" target="_blank" rel="noopener">Open API</a> ，打算利用提供的 API，写两个脚本，一个 pull 所有文件到本地，一个 push 本地文件到云笔记。但 API 太难用了，N 多年没更新了，问客服也没更新的意思，开发到最后发现竟然没有 Markdown 文件的接口，醉了。遂放弃。</p><p>现在我使用 Typora + <a href="https://www.dropbox.com/" target="_blank" rel="noopener">Dropbox</a> + <a href="https://www.mweb.im/" target="_blank" rel="noopener">MWeb</a> 实现同步笔记和手机查看编辑的功能，很香。</p><p>最近给朋友推荐此方式，但发现有道云笔记最新的 Mac 客户端和网页端去除了导出所有笔记的功能！这是什么逻辑，怕用户跑了么。所以在原来 pull 脚本的基础上修改得到此脚本。</p><p>脚本地址：<a href="https://github.com/DeppWang/youdaonote-pull" target="_blank" rel="noopener">https://github.com/DeppWang/youdaonote-pull</a></p><a id="more"></a><h2 id="使用提示"><a href="#使用提示" class="headerlink" title="使用提示"></a>使用提示</h2><ol><li>脚本单纯本地运行，不用担心你的账号密码泄露。但注意，如果你自己修改脚本，注意不要将 config.json 文件 push 到 GitHub</li><li>.note 格式笔记下载后为 xml 格式，<strong>默认将 .note 格式笔记转换为 Markdown 格式</strong>，table 等未转换，需要手动复制</li><li>有道云笔记图床图片在有道云笔记外不显示，<strong>默认下载到本地，使用本地图片链接，可设置上传到免费的 <a href="https://sm.ms" target="_blank" rel="noopener">SM.MS</a> 上</strong></li><li>如果你不是开发者，可能对下面的命令行操作有所陌生，建议按步骤慢慢操作一遍。后续我会更加完善此文档，并根据需求看是否应该提供网页下载</li><li>请确认代码是否为最新，有问题请提交 issue</li></ol><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><!--针对普通用户--><h3 id="一、导出前的准备工作"><a href="#一、导出前的准备工作" class="headerlink" title="一、导出前的准备工作"></a>一、导出前的准备工作</h3><h4 id="1、安装-Git、clone-项目"><a href="#1、安装-Git、clone-项目" class="headerlink" title="1、安装  Git、clone 项目"></a>1、安装  <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a>、clone 项目</h4><ul><li>可根据 <a href="https://www.liaoxuefeng.com/wiki/896043488029600/896067074338496" target="_blank" rel="noopener">廖雪峰 Git 教程</a> 安装 Git，测试是否安装成功</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure><ul><li>打开命令行软件，如 Terminal (macOS)、PowerShell(Windows)，clone 项目，里面包含脚本</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br><span class="line">git clone https://github.com/DeppWang/youdaonote-pull.git</span><br><span class="line">cd youdaonote-pull</span><br></pre></td></tr></table></figure><h4 id="2、安装-Python3、安装依赖模块（包）"><a href="#2、安装-Python3、安装依赖模块（包）" class="headerlink" title="2、安装 Python3、安装依赖模块（包）"></a>2、安装 Python3、安装依赖模块（包）</h4><ul><li>可根据 <a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1016959856222624" target="_blank" rel="noopener">廖雪峰 Python 教程</a> 安装 Python3，测试是否安装成功</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 --version  # macOS/Linux</span><br><span class="line">python --version  # Windows</span><br></pre></td></tr></table></figure><ul><li>安装 requests 依赖包</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> macOS/Linux</span></span><br><span class="line">sudo easy_install pip3 # 安装 Python3 Package Installer</span><br><span class="line">pip3 install requests # 安装 requests 包，脚本依赖 requests</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Windows</span></span><br><span class="line">pip install requests # 安装 requests 包，脚本依赖 requests</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 有问题可参考 https://www.liaoxuefeng.com/wiki/1016959663602400/1017493741106496</span></span><br></pre></td></tr></table></figure><h4 id="3、设置脚本参数配置文件"><a href="#3、设置脚本参数配置文件" class="headerlink" title="3、设置脚本参数配置文件"></a>3、设置脚本参数配置文件</h4><p>config.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"username"</span>: <span class="string">""</span>,</span><br><span class="line">   <span class="attr">"password"</span>: <span class="string">""</span>,</span><br><span class="line">   <span class="attr">"local_dir"</span>: <span class="string">""</span>,</span><br><span class="line">   <span class="attr">"ydnote_dir"</span>: <span class="string">""</span>,</span><br><span class="line">   <span class="attr">"smms_secret_token"</span>: <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>username：<strong>必填</strong>，你的有道云笔记用户名</li><li>password：<strong>必填</strong>，你的有道云笔记密码</li><li>local_dir：选填，本地存放导出文件的文件夹，不填则默认为当前文件夹</li><li>ydnote_dir：选填，有道云笔记指定导出文件夹名，不填则导出所有文件</li><li>smms_secret_token：选填， <a href="https://sm.ms" target="_blank" rel="noopener">SM.MS</a> 的 Secret Token（注册后 -&gt; Dashboard -&gt; API Token），用于上传笔记中有道云图床图片到 SM.MS 图床，不填则只下载到本地（youdaonote-images 文件夹），Markdown 使用本地链接</li><li>建议使用 <a href="https://www.sublimetext.com/3" target="_blank" rel="noopener">Sublime</a> 编辑 config.json</li></ul><p>示例：</p><ul><li>macOS</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"username"</span>: <span class="string">"deppwang@163.com"</span>,</span><br><span class="line">   <span class="attr">"password"</span>: <span class="string">"12345678"</span>,</span><br><span class="line">   <span class="attr">"local_dir"</span>: <span class="string">"/Users/yanjie/Dropbox/youdaonote/test"</span>,</span><br><span class="line">   <span class="attr">"ydnote_dir"</span>: <span class="string">""</span>,</span><br><span class="line">   <span class="attr">"smms_secret_token"</span>: <span class="string">"SGSLk9yWdTe4RenXYqEPWkqVrx0Yexample"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Windows</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"username"</span>: <span class="string">"deppwang@163.com"</span>,</span><br><span class="line">   <span class="attr">"password"</span>: <span class="string">"12345678"</span>,</span><br><span class="line">   <span class="attr">"local_dir"</span>: <span class="string">"D:/Dropbox/youdaonote/test"</span>,</span><br><span class="line">   <span class="attr">"ydnote_dir"</span>: <span class="string">""</span>,</span><br><span class="line">   <span class="attr">"smms_secret_token"</span>: <span class="string">"SGSLk9yWdTe4RenXYqEPWkqVrx0Yexample"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、运行导出脚本"><a href="#二、运行导出脚本" class="headerlink" title="二、运行导出脚本"></a>二、运行导出脚本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 pull.py # macOS/Linux</span><br><span class="line">python pull.py  # Windows</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-06-09-130325.jpg" alt=""></p><!--[](https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-06-07-140101.jpg)--><h3 id="三、多次导出"><a href="#三、多次导出" class="headerlink" title="三、多次导出"></a>三、多次导出</h3><p>多次导出时，同样使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 pull.py # macOS/Linux</span><br><span class="line">python pull.py # Windows</span><br></pre></td></tr></table></figure><p>根据有道云笔记的最后修改时间是否大于本地文件最后修改时间来判断是否更新。再次导出时，只会导出有道云笔记上次导出后新增、修改的笔记，不会覆盖本地已经修改的文件。<strong>但有道云笔记和本地不要同时修改同一个文件，这样会导致本地修改丢失</strong>！</p><p>导出是根据最后修改时间来判断，所以被更新文件和新导出一样，会重复下载图片</p><h2 id="后续开发计划"><a href="#后续开发计划" class="headerlink" title="后续开发计划"></a>后续开发计划</h2><ul><li><input checked disabled type="checkbox"> 将 .note 文件转换为 MarkDown 文件</li><li><input checked disabled type="checkbox"> 解决有道云图床图片不能显示问题，实现方式为默认下载到本地，使用本地图片链接，也可上传到 SM.MS 图床</li><li><input checked disabled type="checkbox"> 首次导出使用账号密码登录，再次导出时使用 Cookie 登录（Cookie 保存在 cookies.json 中），避免频繁操作时因为需要输入验证码导致登录不上的情况</li><li><input disabled type="checkbox"> 优化如果同一目录存在同名的 .md 和 .note 文件，.md 文件将被覆盖的情况</li><li><input disabled type="checkbox"> 并发执行以加快速度</li><li><input disabled type="checkbox"> 针对非开发者用户，提供网页输入账号密码直接下载所有笔记压缩包的方式</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>正常用户操作时，浏览器（前端）调用服务器（后端）接口，接口返回文件内容由前端渲染显示。</li><li>原理是利用有道云笔记本身的接口，模拟操作接口，将前端显示改为存放到本地。可以看看<a href="https://depp.wang/2020/06/11/how-to-find-the-api-of-a-website-eg-note-youdao-com">如何找到有道云笔记的接口</a></li><li>Xml 转换为 Markdown：使用了 <a href="http://docs.python.org/3.7/library/xml.etree.elementtree.html" target="_blank" rel="noopener">xml.etree.ElementTreeI</a></li></ul><h2 id="感谢（参考）"><a href="#感谢（参考）" class="headerlink" title="感谢（参考）"></a>感谢（参考）</h2><ul><li><a href="https://github.com/wesley2012/YoudaoNoteExport" target="_blank" rel="noopener">YoudaoNoteExport</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者：&lt;a href=&quot;https://depp.wang&quot;&gt;DeppWang&lt;/a&gt;、&lt;a href=&quot;https://depp.wang/2020/05/18/export-youdaonote-all-notes/&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;出发点&quot;&gt;&lt;a href=&quot;#出发点&quot; class=&quot;headerlink&quot; title=&quot;出发点&quot;&gt;&lt;/a&gt;出发点&lt;/h2&gt;&lt;p&gt;原来一直是有道云笔记的忠实用户，后面接触到了所见即所得的 &lt;a href=&quot;https://typora.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Typora&lt;/a&gt;，有点用不惯有道云笔记了，想着有什么法子能电脑本地文件和有道云笔记同步，这样电脑使用 Typora，手机使用有道云笔记。发现有道云笔记有 &lt;a href=&quot;http://note.youdao.com/open/developguide.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Open API&lt;/a&gt; ，打算利用提供的 API，写两个脚本，一个 pull 所有文件到本地，一个 push 本地文件到云笔记。但 API 太难用了，N 多年没更新了，问客服也没更新的意思，开发到最后发现竟然没有 Markdown 文件的接口，醉了。遂放弃。&lt;/p&gt;
&lt;p&gt;现在我使用 Typora + &lt;a href=&quot;https://www.dropbox.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dropbox&lt;/a&gt; + &lt;a href=&quot;https://www.mweb.im/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MWeb&lt;/a&gt; 实现同步笔记和手机查看编辑的功能，很香。&lt;/p&gt;
&lt;p&gt;最近给朋友推荐此方式，但发现有道云笔记最新的 Mac 客户端和网页端去除了导出所有笔记的功能！这是什么逻辑，怕用户跑了么。所以在原来 pull 脚本的基础上修改得到此脚本。&lt;/p&gt;
&lt;p&gt;脚本地址：&lt;a href=&quot;https://github.com/DeppWang/youdaonote-pull&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/DeppWang/youdaonote-pull&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="OpenSource" scheme="https://depp.wang/categories/OpenSource/"/>
    
    
      <category term="YoudaoNote" scheme="https://depp.wang/tags/YoudaoNote/"/>
    
      <category term="Python" scheme="https://depp.wang/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>从虚拟机角度理解，为什么静态块函数先于构造函数执行</title>
    <link href="https://depp.wang/2020/05/06/static-block-method-and-constructor-method/"/>
    <id>https://depp.wang/2020/05/06/static-block-method-and-constructor-method/</id>
    <published>2020-05-06T15:02:25.000Z</published>
    <updated>2020-06-11T13:09:39.058Z</updated>
    
    <content type="html"><![CDATA[<p>作者：<a href="https://depp.wang">DeppWang</a>、<a href="https://depp.wang/2020/05/06/static-block-method-and-constructor-method/">原文地址</a></p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>常常有关于静态块函数、构造函数执行顺序的面试题，如果死记硬背，往往容易混淆。需要从虚拟角度来理解，当真正理解后，其实很简单。</p><p>一个面试题栗子，请输出下面代码的运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticSuper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"super static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StaticSuper() &#123;</span><br><span class="line">        System.out.println(<span class="string">"super constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> <span class="keyword">extends</span> <span class="title">StaticSuper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StaticTest() &#123;</span><br><span class="line">        System.out.println(<span class="string">"constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"in main"</span>);</span><br><span class="line">        StaticTest s = <span class="keyword">new</span> StaticTest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">super <span class="keyword">static</span> <span class="keyword">block</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">block</span></span><br><span class="line"><span class="keyword">in</span> main</span><br><span class="line">super <span class="function"><span class="keyword">constructor</span></span></span><br><span class="line"><span class="function"><span class="title">constructor</span></span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h2><p>当执行 StaticTest.main() 时，类加载器加载 StaticTest.class 文件到虚拟机，新建一个与之对应的 Class 对象，如果有类变量，为类变量设置初始值。</p><p>执行 StaticTest.main()，其实是执行 invokestatic 指令，Java 虚拟机规范规定，执行 invokestatic 指令时，需要先初始化类，初始化类时，执行类构造器 <code>&lt;clinit&gt;()</code> 方法， <code>&lt;clinit&gt;()</code> 方法为类变量赋值以及执行静态代码块，虚拟机保证执行 <code>&lt;clinit&gt;()</code> 方法前先执行父类 <code>&lt;clinit&gt;()</code> 方法。</p><p>执行完 <code>&lt;clinit&gt;()</code> 方法后执行 main() 方法</p><p>执行 new 指令时，实例化生成对象，并为实例变量设置初始值（如果没有初始值），再调用实例构造方法  <code>&lt;init&gt;()</code>  为实例变量赋值。</p><h2 id="三、加入构造代码块"><a href="#三、加入构造代码块" class="headerlink" title="三、加入构造代码块"></a>三、加入构造代码块</h2><p>有时候，为了加大难度，里面还会加上构造代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticSuper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"super static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"super constructor block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StaticSuper() &#123;</span><br><span class="line">        System.out.println(<span class="string">"super constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> <span class="keyword">extends</span> <span class="title">StaticSuper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"constructor block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StaticTest() &#123;</span><br><span class="line">        System.out.println(<span class="string">"constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"in main"</span>);</span><br><span class="line">        StaticTest s = <span class="keyword">new</span> StaticTest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造代码块可以看成一个公共构造函数，使用任何构造函数前都需要先执行构造代码块。所以执行结果为：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">super <span class="keyword">static</span> <span class="keyword">block</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">block</span></span><br><span class="line"><span class="keyword">in</span> main</span><br><span class="line">super <span class="function"><span class="keyword">constructor</span> <span class="title">block</span></span></span><br><span class="line"><span class="function"><span class="title">super</span> <span class="title">constructor</span></span></span><br><span class="line"><span class="function"><span class="title">constructor</span> <span class="title">block</span></span></span><br><span class="line"><span class="function"><span class="title">constructor</span></span></span><br></pre></td></tr></table></figure><h2 id="四、应用"><a href="#四、应用" class="headerlink" title="四、应用"></a>四、应用</h2><p>静态代码块属于类构造函数的范畴，所以常用于设置静态变量。如，Integer 里面的 IntegerCache。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            ...</span><br><span class="line">            high = h;</span><br><span class="line"></span><br><span class="line">            cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> j = low;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>1、我们<strong>将静态代码块看成类构造方法</strong>，类构造方法肯定先于实例构造方法执行。</p><p>2、构造代码块可以看成公共构造函数，先于构造函数执行</p><p>这方面的内容可以<a href="https://weread.qq.com/web/reader/cf1320d071a1a78ecf19254k283328802332838023a7529" target="_blank" rel="noopener">《深入理解 Java 虚拟机》（第 3 版）- 7.3 类加载的过程</a>，会比看博文理解得更深刻。</p><!--当运行 StaticTest.main() 后，类加载器就会寻找已经编译的 StaticTest.class 文件，将其加载到虚拟机中，--><blockquote><!--静态块函数也叫静态初始化函数（static initializer）是一段在加载类时会执行的程序代码，它会在其他程序可以使用该类之前就执行。--></blockquote><blockquote><!--构造函数的作用是用于给对象进行初始化。不建立对象，构造函数时不会执行。--></blockquote><!--运行过程如下：--><!--当运行 StaticTest.main()(这是一个 static 方法) 后，类装载器就会寻找已经编译的 StaticTest.class 文件。在装载的过程中，装载器注意到它有一个基类（StaticSuper.class），于是它再装载基类。不管创不创建基类对象，这个过程总会发生。如果基类还有基类，那么第二个基类也会被装载，依此类推。--><!--所有基类装载完成后，先执行根基类的 static 初始化函数，然后是下一个派生类的 static 初始化函数，依此类推。这个顺序非常重要，因为派生类的 “static 初始化函数” 有可能要依赖基类成员的正确初始化。所以依次输出 `super static block`,`static  block`--><!--当所有必要的类都已经装载结束，开始执行 main() 方法体，先输出 `in main`，再用 new StaticSuperTest() 创建对象。--><!--类 StaticTest 存在父类 StaticSuper，先调用 StaticSuper 的构造函数，输出 `super constructor`，最后调用 StaticSuperTest 的构造函数输出 `constructor`。--><!--可以使用 super 显式来指定调用哪个构造函数。基类的构造过程以及构造顺序，同派生类的相同。--><!--五、延伸阅读--><!--[Java 提高篇 ---- 静态代码块、构造代码块、构造函数以及 Java 类初始化顺序](http://www.cnblogs.com/Qian123/p/5713440.html)-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者：&lt;a href=&quot;https://depp.wang&quot;&gt;DeppWang&lt;/a&gt;、&lt;a href=&quot;https://depp.wang/2020/05/06/static-block-method-and-constructor-method/&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;常常有关于静态块函数、构造函数执行顺序的面试题，如果死记硬背，往往容易混淆。需要从虚拟角度来理解，当真正理解后，其实很简单。&lt;/p&gt;
&lt;p&gt;一个面试题栗子，请输出下面代码的运行结果：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;StaticSuper&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;super static block&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    StaticSuper() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;super constructor&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;StaticTest&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;StaticSuper&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;static block&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    StaticTest() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;constructor&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;in main&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        StaticTest s = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; StaticTest();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;执行结果如下：&lt;/p&gt;
&lt;figure class=&quot;highlight oxygene&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;super &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; main&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;super &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;constructor&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="https://depp.wang/categories/Java/"/>
    
    
      <category term="Java 基础" scheme="https://depp.wang/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>一道算法题：查找数组 arr 中第 k 小的奇数</title>
    <link href="https://depp.wang/2020/05/06/find-the-k-th-smallest-odd-number-in-the-array-arr/"/>
    <id>https://depp.wang/2020/05/06/find-the-k-th-smallest-odd-number-in-the-array-arr/</id>
    <published>2020-05-06T08:09:37.000Z</published>
    <updated>2020-06-11T13:09:39.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p>「北京波粒子科技有限公司」面试题</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>查找数组 arr 中第 k 小的奇数，如果不存在则返回 0. (arr [i] &gt; 0 (i&gt;=0))</p><p>计算出时间复杂度（注意代码注释，尽可能不用全排序，不要使⽤库函数或脚本中已经实现好的排序算法和⼯具，需要⾃⼰实现数据结构和所需要的算法）</p><a id="more"></a><h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>属于 Top K 问题</li><li>假设数组中数据范围有限，使用「计数排序法」</li><li>时间复杂度：O(N)，N 为第 k 小的奇数的大小</li><li>最坏时间复杂度：当不存在时，需要遍历完 counter 数组，O(M)，M 为指定数组的范围</li><li>空间复杂度：O(M)，需要长度为 M 的额外数组。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 统计每个数字出现的次数</span></span><br><span class="line">        <span class="keyword">int</span>[] counter = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10001</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">            counter[num] = counter[num] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历 counter，查找第 k 小的奇数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">0</span>; num &lt; counter.length; num++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (counter[num] &gt; <span class="number">0</span> &amp;&amp; x &lt; k &amp;&amp; num % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x == k) &#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">23</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">45</span>, <span class="number">12</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> Solution().findKth(arr, k));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!--参考：https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/3chong-jie-fa-miao-sha-topkkuai-pai-dui-er-cha-sou/-->]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目来源&quot;&gt;&lt;a href=&quot;#题目来源&quot; class=&quot;headerlink&quot; title=&quot;题目来源&quot;&gt;&lt;/a&gt;题目来源&lt;/h2&gt;&lt;p&gt;「北京波粒子科技有限公司」面试题&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;查找数组 arr 中第 k 小的奇数，如果不存在则返回 0. (arr [i] &amp;gt; 0 (i&amp;gt;=0))&lt;/p&gt;
&lt;p&gt;计算出时间复杂度（注意代码注释，尽可能不用全排序，不要使⽤库函数或脚本中已经实现好的排序算法和⼯具，需要⾃⼰实现数据结构和所需要的算法）&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="https://depp.wang/categories/Algorithms/"/>
    
    
      <category term="数组" scheme="https://depp.wang/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Spring 中的反射与反射的原理</title>
    <link href="https://depp.wang/2020/05/05/reflection-in-spring-and-reflection-principle/"/>
    <id>https://depp.wang/2020/05/05/reflection-in-spring-and-reflection-principle/</id>
    <published>2020-05-05T08:09:37.000Z</published>
    <updated>2020-06-11T13:09:39.062Z</updated>
    
    <content type="html"><![CDATA[<p>作者：<a href="https://depp.wang">DeppWang</a>、<a href="https://depp.wang/2020/05/05/reflection-in-spring-and-reflection-principle/">原文地址</a></p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-04-29-154427.jpg" alt="image source: https://coderius.biz.ua/blog/article/vvedenie-v-php-reflection-api"></p><p>在<a href="https://depp.wang/2020/04/19/realize-a-simple-spring-ioc-container/">造轮子：实现一个简易的 Spring IoC 容器</a>一文中提到 Spring 在创建 Bean 实例和依赖注入时使用了反射，本文来具体分析一下 Spring 中的反射以及反射的原理。</p><!--[造轮子：实现一个简易的 Spring IoC 容器](https://mp.weixin.qq.com/s/0kfeHOK6FjbGQ0PwzWe58A)--><h2 id="一、Spring-中的反射"><a href="#一、Spring-中的反射" class="headerlink" title="一、Spring 中的反射"></a>一、Spring 中的反射</h2><h3 id="1-1、创建-Bean-实例时的反射"><a href="#1-1、创建-Bean-实例时的反射" class="headerlink" title="1.1、创建 Bean 实例时的反射"></a>1.1、创建 Bean 实例时的反射</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过类加载器，根据 class 路径，得到其类对象</span></span><br><span class="line">Class&lt;?&gt; clz = Thread.currentThread().getContextClassLoader().loadClass(<span class="string">"org.deppwang.litespring.v1.service.PetStoreService"</span>);</span><br><span class="line"><span class="comment">// 根据类对象生成 Bean 实例</span></span><br><span class="line"><span class="keyword">return</span> clz.newInstance();</span><br></pre></td></tr></table></figure><p>反射体现在 <code>clz.newInstance();</code> 中，核心代码可分为两部分：</p><a id="more"></a><p>1、<strong>利用反射</strong>获取当前类 PetStoreService 的所有构造方法信息（Constructor 对象）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.lang.Class.java</span></span><br><span class="line"><span class="comment">// 调用 native 方法，此时 publicOnly 为 false</span></span><br><span class="line">res = getDeclaredConstructors0(publicOnly);</span><br><span class="line"><span class="comment">// native 方法，从 jvm 中的 class 文件中获取构造方法信息，再转换为 Constructor 对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> Constructor&lt;T&gt;[] getDeclaredConstructors0(<span class="keyword">boolean</span> publicOnly);</span><br></pre></td></tr></table></figure><p>2、<strong>利用反射</strong>通过默认构造方法生成实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sun.reflect.NativeConstructorAccessorImpl.java</span></span><br><span class="line"><span class="comment">// 调用 native 方法，var1 代表构造方法的参数，此时为 null</span></span><br><span class="line"><span class="keyword">return</span> newInstance0(<span class="keyword">this</span>.c, var1);</span><br><span class="line"><span class="comment">// native 方法，真正生成实例的方法，执行 class 文件的构造方法 &lt;init&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title">newInstance0</span><span class="params">(Constructor&lt;?&gt; var0, Object[] var1)</span></span>;</span><br></pre></td></tr></table></figure><!--new 指令--><h3 id="1-2、构造方法依赖注入时的反射"><a href="#1-2、构造方法依赖注入时的反射" class="headerlink" title="1.2、构造方法依赖注入时的反射"></a>1.2、构造方法依赖注入时的反射</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过反射获取当前类所有的构造方法信息（Constructor 对象）</span></span><br><span class="line">Constructor&lt;?&gt;[] candidates = beanClass.getDeclaredConstructors();</span><br><span class="line"><span class="comment">// 设置构造方法参数实例</span></span><br><span class="line">Object[] argsToUse = <span class="keyword">new</span> Object[parameterTypes.length];</span><br><span class="line">argsToUse[i] = getBean(beanNames.get(i));</span><br><span class="line"><span class="comment">// 使用带有参数的 Constructor 对象实现实例化 Bean。此时使用反射跟上面一样（newInstance0），只是多了参数</span></span><br><span class="line"><span class="keyword">return</span> constructorToUse.newInstance(argsToUse);</span><br></pre></td></tr></table></figure><h3 id="1-3、setter-方法依赖注入时的反射"><a href="#1-3、setter-方法依赖注入时的反射" class="headerlink" title="1.3、setter() 方法依赖注入时的反射"></a>1.3、setter() 方法依赖注入时的反射</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过反射获取当前类所有的方法信息（Method 对象）</span></span><br><span class="line">Method[] methods = bean.getClass().getDeclaredMethods();</span><br><span class="line"><span class="comment">// 获得方法参数实例</span></span><br><span class="line">Object propertyBean = getBean(propertyName);</span><br><span class="line"><span class="comment">// 通过反射执行调用 setter() 方法。invoke：调用方法，propertyBean 作为方法的参数</span></span><br><span class="line">method.invoke(bean, propertyBean);</span><br></pre></td></tr></table></figure><p>bean.getClass().getDeclaredMethods(); 中的核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.lang.Class.java</span></span><br><span class="line"><span class="comment">// 调用 native 方法，publicOnly 为 false</span></span><br><span class="line">getDeclaredMethods0(publicOnly);</span><br><span class="line"><span class="comment">// native 方法，从 jvm 中的 class 文件中获取方法信息，再转换为 Method</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> Method[]      getDeclaredMethods0(<span class="keyword">boolean</span> publicOnly);</span><br></pre></td></tr></table></figure><p>method.invoke(bean, propertyBean); 中的核心代码：</p><!--根据 var0 找到 class 文件的 setter() 方法，执行 setter() 方法？--><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sun.reflect.NativeMethodAccessorImpl.java</span></span><br><span class="line"><span class="comment">// 调用 native 方法，var1: bean、var2: propertyBean</span></span><br><span class="line"><span class="keyword">return</span> invoke0(<span class="keyword">this</span>.method, var1, var2);</span><br><span class="line"><span class="comment">// native 方法，运行 class 文件中的字节码指令</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title">invoke0</span><span class="params">(Method var0, Object var1, Object[] var2)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="1-4、-Autowired-依赖注入时的反射"><a href="#1-4、-Autowired-依赖注入时的反射" class="headerlink" title="1.4、@Autowired 依赖注入时的反射"></a>1.4、@Autowired 依赖注入时的反射</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过反射得到当前类所有的字段信息（Field 对象）</span></span><br><span class="line">Field[] fields = bean.getClass().getDeclaredFields();</span><br><span class="line"><span class="comment">// 判断字段是否有 @Autowired 注解</span></span><br><span class="line">Annotation ann = field.getAnnotation(Autowired.class);</span><br><span class="line"><span class="comment">// 设置字段可连接，相当于将非 public（private、default、protect）更改为 public</span></span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 通过反射设置字段的值</span></span><br><span class="line">field.set(bean, getBean(field.getName()));</span><br></pre></td></tr></table></figure><p>bean.getClass().getDeclaredFields(); 中的核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.lang.Class.java</span></span><br><span class="line"><span class="comment">// 调用 native 方法，此时 publicOnly 为 false</span></span><br><span class="line">getDeclaredFields0(publicOnly);</span><br><span class="line"><span class="comment">// native 方法，从 jvm 中获取 class 文件的字段信息，再转换为 Field</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> Field[]       getDeclaredFields0(<span class="keyword">boolean</span> publicOnly);</span><br></pre></td></tr></table></figure><p>field.set(bean, getBean(field.getName())); 中的核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sun.reflect.UnsafeObjectFieldAccessorImpl.java</span></span><br><span class="line"><span class="comment">// 调用 native 方法，将目标对象 var1 指定偏移量 fieldOffset 处的字段值设置（修改）为 var2。var1 为 bean, var2 为参数实例</span></span><br><span class="line">unsafe.putObject(var1, <span class="keyword">this</span>.fieldOffset, var2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sun.misc.Unsafe.java</span></span><br><span class="line"><span class="comment">// native 方法，直接修改堆中对象字段的数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="二、class-文件与类对象"><a href="#二、class-文件与类对象" class="headerlink" title="二、class 文件与类对象"></a>二、class 文件与类对象</h2><p>class 文件由 java 文件编译而来，class 文件包含字段表、方法表、<code>&lt;init&gt;</code> 方法（构造方法）等。</p><p>当类加载器将 class 文件加载进虚拟机元空间（Meta-space，jdk 1.8）时，虚拟机在元空间中创建一个与之对应的类对象（Class 实例）。并将 class 文件由存放在磁盘的静态结构转换为存放在内存的运行时结构。</p><!--（在元数据中？）--><p>我们可以认为一个类（class 文件）对应一个类对象，当前类的所有对象共用一个类对象。<strong>类对象作为访问存放在 jvm 的 class 文件的入口。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> Field[]       getDeclaredFields0(<span class="keyword">boolean</span> publicOnly);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> Method[]      getDeclaredMethods0(<span class="keyword">boolean</span> publicOnly);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> Constructor&lt;T&gt;[] getDeclaredConstructors0(<span class="keyword">boolean</span> publicOnly);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ReflectionData 缓存反射对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> Field[] declaredFields;</span><br><span class="line">        <span class="keyword">volatile</span> Field[] publicFields;</span><br><span class="line">        <span class="keyword">volatile</span> Method[] declaredMethods;</span><br><span class="line">        <span class="keyword">volatile</span> Method[] publicMethods;</span><br><span class="line">        <span class="keyword">volatile</span> Constructor&lt;T&gt;[] declaredConstructors;</span><br><span class="line">        <span class="keyword">volatile</span> Constructor&lt;T&gt;[] publicConstructors;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1、获得类对象的方式"><a href="#2-1、获得类对象的方式" class="headerlink" title="2.1、获得类对象的方式"></a>2.1、获得类对象的方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、通过对象</span></span><br><span class="line">Class cls = object.getClass();</span><br><span class="line"><span class="comment">// Object.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、通过类加载器</span></span><br><span class="line">Class cls = Thread.currentThread().getContextClassLoader().loadClass(<span class="string">"org.deppwang.litespring.v1.service.PetStoreService"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、通过 Class 类，本质上也是通过类加载器</span></span><br><span class="line">Class cls = Class.forName(<span class="string">"org.deppwang.litespring.v1.service.PetStoreService"</span>);</span><br><span class="line"><span class="comment">// Class.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; forName0(String name, <span class="keyword">boolean</span> initialize,</span><br><span class="line">                                            ClassLoader loader,</span><br><span class="line">                                            Class&lt;?&gt; caller)</span><br></pre></td></tr></table></figure><!--// 4、直接用类名Class cls = String.class;--><h2 id="三、反射方法"><a href="#三、反射方法" class="headerlink" title="三、反射方法"></a>三、反射方法</h2><p>以下是常用的反射方法。</p><h3 id="3-1、Feild-相关"><a href="#3-1、Feild-相关" class="headerlink" title="3.1、Feild 相关"></a>3.1、Feild 相关</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Field[] fields = cls.getFields(); <span class="comment">// 获取所有公共的 Field（包括父类）</span></span><br><span class="line">Field[] fields = cls.getDeclaredFields(); <span class="comment">// 获取当前类的所有 Field（不包括父类），包括公共和非公共</span></span><br><span class="line">Field field = cls.getDeclaredField(<span class="string">"fieldName"</span>); <span class="comment">// 指定获取当前类某个 Field</span></span><br><span class="line">field.set(Object, Object); <span class="comment">// 设置（修改）字段值</span></span><br><span class="line">field.get(Object); <span class="comment">// 获取字段值</span></span><br></pre></td></tr></table></figure><p>field.get(Object) 核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用 native 方法，获取字段对应的值</span></span><br><span class="line"><span class="keyword">return</span> unsafe.getObject(var1, <span class="keyword">this</span>.fieldOffset);</span><br><span class="line"></span><br><span class="line"><span class="comment">// native 方法，从堆中获取对象指定位置的对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">getObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-2、Method-相关"><a href="#3-2、Method-相关" class="headerlink" title="3.2、Method 相关"></a>3.2、Method 相关</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Method[] methods = cls.getMethods(); <span class="comment">// 获取所有公共的 Method（包括父类）</span></span><br><span class="line">Method[] methods = cls.getDeclaredMethods(); <span class="comment">// 获取当前类的所有 Method（不包括父类），包括公共和非公共</span></span><br><span class="line">method.invoke(Object instance, Object... parameters); <span class="comment">// 运行方法</span></span><br></pre></td></tr></table></figure><p>运行方法使用场景：要么是修改对象的数据，如 void setter() 方法；要么是获得执行方法的返回结果。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="keyword">result</span> = <span class="function"><span class="keyword">method</span>.<span class="title">invoke</span><span class="params">()</span>.<span class="title">toString</span><span class="params">()</span>;</span></span><br></pre></td></tr></table></figure><h3 id="3-3、Constructor-相关"><a href="#3-3、Constructor-相关" class="headerlink" title="3.3、Constructor 相关"></a>3.3、Constructor 相关</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] constructors = cls.getConstructors(); <span class="comment">// 获取所有公共的 Constructor（包括父类）</span></span><br><span class="line">Constructor&lt;?&gt;[] constructors = cls.getDeclaredConstructors(); <span class="comment">// 获取当前类的所有Constructor（不包括父类），包括公共和非公共</span></span><br><span class="line">constructor.newInstance(Object... parameters); <span class="comment">// 运行构造方法</span></span><br></pre></td></tr></table></figure><!--默认包含一个无参公有构造方法，当存在自定义构造方法时，就没有默认构造方法--><p>当没有明确编写构造方法，Java 编译器将为该类构建一个默认构造函数 <code>&lt;init&gt;</code></p><h2 id="四、native-方法"><a href="#四、native-方法" class="headerlink" title="四、native 方法"></a>四、native 方法</h2><p>Java 1.1 新增「Java 本地接口」(Java Native Interface，JNI)，JNI 是一种包容极广的编程接口，允许我们从 Java 应用程序里调用 native 方法，native 方法由其它语言（C 、C++ 或汇编语言等）编写。native 方法用于实现 Java 无法处理的功能。</p><h3 id="4-1、简单示例"><a href="#4-1、简单示例" class="headerlink" title="4.1、简单示例"></a>4.1、简单示例</h3><p>一个在 Java 中使用 Java 本地接口（JNI）的简单示例。</p><ul><li>环境：<strong>jdk8、macOS 10.15</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">intMethod</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 启动时载入 libMain.dylib</span></span><br><span class="line">        System.loadLibrary(<span class="string">"Main"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Main().intMethod(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.c:</span></span><br><span class="line"><span class="comment">// 将 Main.h 引入</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Main.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于继承 "Main.h" 的 Java_Main_intMethod</span></span><br><span class="line"><span class="function">JNIEXPORT jint JNICALL <span class="title">Java_Main_intMethod</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    JNIEnv *env, jobject obj, jint i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i * i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译与运行:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同时生成 Main.class 和 Main.h</span></span><br><span class="line">javac Main.java -h .</span><br><span class="line"><span class="comment">// 根据 Main.c 生成 libMain.dylib</span></span><br><span class="line">gcc -dynamiclib -O3 \</span><br><span class="line">    -I/usr/include \</span><br><span class="line">    -I$JAVA_HOME/include \</span><br><span class="line">    -I$JAVA_HOME/include/darwin \</span><br><span class="line">    Main.c -o libMain.dylib</span><br><span class="line"><span class="comment">// 指定 library 的路径为当前路径</span></span><br><span class="line">java -cp . -Djava.library.path=$(pwd) Main</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Main.h .h 作为头文件*/</span></span><br><span class="line"><span class="comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Header for class Main */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Included_Main</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Included_Main</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     Main</span></span><br><span class="line"><span class="comment"> * Method:    intMethod</span></span><br><span class="line"><span class="comment"> * Signature: (I)I</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jint JNICALL Java_Main_intMethod</span><br><span class="line">  (JNIEnv *, jobject, jint);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javac Main.java -h .</span><br><span class="line"><span class="comment">// 可拆分为两个命令</span></span><br><span class="line">javac Main.java</span><br><span class="line">javah -jni Main</span><br></pre></td></tr></table></figure><h3 id="4-2、原理"><a href="#4-2、原理" class="headerlink" title="4.2、原理"></a>4.2、原理</h3><p>运行 Main.class 时，将 libMain.dylib 载入虚拟机，JVM 调用 libMain.dylib 的 Java_Main_intMethod，传入参数，libMain.dylib 由系统直接运行，返回结果。</p><ul><li>*env 用于将 java 类型数据与本地（此处为 C 语言）类型数据之间的转换</li><li>jint 还是 Java 数据类型，Java 基本数据类型可以映射（使用），不用通过 *env 转换</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*C code*/</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_ClassName_MethodName</span><br><span class="line">  (JNIEnv *env, jobject obj, jstring javaString)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*Get the native string from javaString*/</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *nativeString = (*env)-&gt;GetStringUTFChars(env, javaString, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Do something with the nativeString*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*DON'T FORGET THIS LINE!!!*/</span></span><br><span class="line">    (*env)-&gt;ReleaseStringUTFChars(env, javaString, nativeString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!--Unsafe 类--><!-- - 存放 native 方法的类？--><h3 id="4-3、参考"><a href="#4-3、参考" class="headerlink" title="4.3、参考"></a>4.3、参考</h3><ul><li><a href="https://medium.com/@bschlining/a-simple-java-native-interface-jni-example-in-java-and-scala-68fdafe76f5f" target="_blank" rel="noopener">A Simple Java Native Interface (JNI) example in Java and Scala</a></li><li><a href="https://www.codejava.net/java-core/the-java-language/native-keyword#" target="_blank" rel="noopener">Java native keyword example</a></li><li><a href="https://www.protechtraining.com/blog/post/java-native-interface-jni-example-65" target="_blank" rel="noopener">Java Native Interface: JNI Example</a></li><li><a href="https://depp.wang/Java-Books/docs/Java编程思想.pdf">Java 编程思想 - 附录<strong>A</strong> 使用非<strong>JAVA</strong>代码</a></li><li><a href="https://zh.wikipedia.org/wiki/Java本地接口" target="_blank" rel="noopener">Java本地接口 - WiKi</a></li></ul><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>反射反射，哪里体现反射字面意思？</p><p>可以这么理解，通过 native 方法得到反射对象，操作反射对象，像镜子一样，将反射到原对象上。</p><p>我们发现，反射和 native 方法的关系：</p><ul><li>获取字段、方法、构造方法对象，native() 方法实现</li><li>获取字段值、设置修改字段值，native() 方法实现</li><li>运行方法，native() 方法实现</li><li>运行构造方法，native() 方法实现</li></ul><p>我们可以得出结论，<strong>反射由 native 方法实现</strong>。</p><p>我们说通过反射实现一个功能，我们也可以说：</p><ul><li>通过反射方法实现</li><li>通过反射 API 实现</li><li>通过 native 方法实现</li></ul><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-05-05-123303.png" alt=""></p><p>反射是一种非常规（native 方法实现）方式获取 class 文件信息、运行 class 文件字节码指令和操作对象数据的能力。</p><!--我们可以认为反射就是 native() 方法，可以把它看做一组 API，通过反射 API，可以运行时获取对象的信息，如字段、方法和构造函数，也可以修改字段值和运行方法和构造方法。--><p>一句话总结 ：反射是一种运行时<strong>获取和修改</strong>对象数据的能力。</p><p>关于运行时：Java 是静态语言，先编译，后运行。编译时不执行代码，代码都是运行时执行。</p><h2 id="六、延伸阅读"><a href="#六、延伸阅读" class="headerlink" title="六、延伸阅读"></a>六、延伸阅读</h2><ul><li><a href="https://www.cnblogs.com/techspace/p/6931397.html" target="_blank" rel="noopener">JAVA 反射原理</a></li><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255945147512512" target="_blank" rel="noopener">廖雪峰 Java 教程 - 反射</a></li><li><a href="https://www.geeksforgeeks.org/reflection-in-java/" target="_blank" rel="noopener">Reflection in Java</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html" target="_blank" rel="noopener">oracle reflect docs</a></li><li><a href="https://stackoverflow.com/questions/37628/what-is-reflection-and-why-is-it-useful" target="_blank" rel="noopener">What is reflection and why is it useful?</a></li><li><a href="https://dzone.com/articles/understanding-sunmiscunsafe" target="_blank" rel="noopener">Understanding sun.misc.Unsafe</a></li><li><a href="https://www.baeldung.com/java-unsafe" target="_blank" rel="noopener">Guide to sun.misc.Unsafe</a></li></ul><!--运行期类型鉴定 (RTTI)--><!--全限定名：指编译后的 class 文件在 jar 包中的路径，package 路径的 . 转换为 /-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者：&lt;a href=&quot;https://depp.wang&quot;&gt;DeppWang&lt;/a&gt;、&lt;a href=&quot;https://depp.wang/2020/05/05/reflection-in-spring-and-reflection-principle/&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-04-29-154427.jpg&quot; alt=&quot;image source: https://coderius.biz.ua/blog/article/vvedenie-v-php-reflection-api&quot;&gt;&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://depp.wang/2020/04/19/realize-a-simple-spring-ioc-container/&quot;&gt;造轮子：实现一个简易的 Spring IoC 容器&lt;/a&gt;一文中提到 Spring 在创建 Bean 实例和依赖注入时使用了反射，本文来具体分析一下 Spring 中的反射以及反射的原理。&lt;/p&gt;
&lt;!--[造轮子：实现一个简易的 Spring IoC 容器](https://mp.weixin.qq.com/s/0kfeHOK6FjbGQ0PwzWe58A)--&gt;

&lt;h2 id=&quot;一、Spring-中的反射&quot;&gt;&lt;a href=&quot;#一、Spring-中的反射&quot; class=&quot;headerlink&quot; title=&quot;一、Spring 中的反射&quot;&gt;&lt;/a&gt;一、Spring 中的反射&lt;/h2&gt;&lt;h3 id=&quot;1-1、创建-Bean-实例时的反射&quot;&gt;&lt;a href=&quot;#1-1、创建-Bean-实例时的反射&quot; class=&quot;headerlink&quot; title=&quot;1.1、创建 Bean 实例时的反射&quot;&gt;&lt;/a&gt;1.1、创建 Bean 实例时的反射&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 通过类加载器，根据 class 路径，得到其类对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Class&amp;lt;?&amp;gt; clz = Thread.currentThread().getContextClassLoader().loadClass(&lt;span class=&quot;string&quot;&gt;&quot;org.deppwang.litespring.v1.service.PetStoreService&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 根据类对象生成 Bean 实例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; clz.newInstance();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;反射体现在 &lt;code&gt;clz.newInstance();&lt;/code&gt; 中，核心代码可分为两部分：&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://depp.wang/categories/Java/"/>
    
    
      <category term="反射" scheme="https://depp.wang/tags/%E5%8F%8D%E5%B0%84/"/>
    
      <category term="Spring" scheme="https://depp.wang/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>造轮子：实现一个简易的 Spring IoC 容器</title>
    <link href="https://depp.wang/2020/04/19/realize-a-simple-spring-ioc-container/"/>
    <id>https://depp.wang/2020/04/19/realize-a-simple-spring-ioc-container/</id>
    <published>2020-04-19T08:09:37.000Z</published>
    <updated>2020-06-11T13:09:39.062Z</updated>
    
    <content type="html"><![CDATA[<p>作者：<a href="https://depp.wang">DeppWang</a>、<a href="https://depp.wang/2020/04/19/realize-a-simple-spring-ioc-container">原文地址</a></p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-04-19-110638.jpg" alt="source:https://fernandofranzini.wordpress.com/"></p><p>我通过实现一个简易的 Spring IoC 容器，算是真正入门了 Spring 框架。本文是对实现过程的一个总结提炼，<strong>需要配合源码阅读</strong>，<a href="https://github.com/DeppWang/litespring" target="_blank" rel="noopener">源码地址</a>。</p><p>结合本文和源码，你应该可以学到：Spring 的原理和 Spring Boot 的原理。</p><p>Spring 框架是 Java 开发的，Java 是面向对象的语言，所以 Spring 框架本身有大量的抽象、继承、多态。对于初学者来说，光是理清他们的逻辑就很麻烦，我摒弃了那些包装，只实现了最本质的功能。代码不是很严谨，但只为了理解 Spring 思想却够了。</p><p>下面正文开始。</p><a id="more"></a><h2 id="零、Spring-的作用"><a href="#零、Spring-的作用" class="headerlink" title="零、Spring 的作用"></a>零、Spring 的作用</h2><p>在没有 Spring 框架的远古时代，我们业务逻辑一般长这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PetStoreService</span> </span>&#123;</span><br><span class="line">    AccountDao accountDao = <span class="keyword">new</span> AccountDao();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PetStoreService petStoreService = <span class="keyword">new</span> PetStoreService();</span><br></pre></td></tr></table></figure><p>到处都是  <strong>new</strong> 关键字，需要开发人员显式的使用 new 关键字来创建对象（实例）。这样有很多弊端，如，创建的对象太多（多次创建多个对象），耦合性太强（默认 new），等等。</p><p>有个叫 <a href="https://en.wikipedia.org/wiki/Rod_Johnson_(programmer)" target="_blank" rel="noopener">Rod Johnson</a> 老哥对此很不爽，就开发了一个叫 <a href="https://spring.io/" target="_blank" rel="noopener">Spring</a> 的框架，就是为了干掉 new 关键字（哈哈，我杜撰的，只是为了说明 Spring 的作用）。</p><p>有了 Spring 框架，<strong>由框架来新建对象，管理对象，并处理对象之间的依赖</strong>，我们程序员就可以专注于业务逻辑（专心搬砖），不用关心对象的创建了。我们来看看 Spring 框架是如何实现的吧。</p><p>注：以下 Spring 框架简写为 Spring</p><p>本节源码对应：<strong>v0</strong></p><h2 id="一、实现「实例化-Bean-」"><a href="#一、实现「实例化-Bean-」" class="headerlink" title="一、实现「实例化 Bean 」"></a>一、实现「实例化 Bean 」</h2><p>首先，我们需要标记哪些类交给 Spring 管理，可以借助 xml 标记，将其标记为 <code>&lt;bean&gt;</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--petstore-v1.xml--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"petStore"</span> <span class="attr">class</span>=<span class="string">"org.deppwang.litespring.v1.service.PetStoreService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountDao"</span> <span class="attr">class</span>=<span class="string">"org.deppwang.litespring.v1.dao.AccountDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring 的第一步操作就是根据 xml 的标记来实例化类，在 Spring 中，我们管类叫 Bean，所以实例化类也可以称为实例化 Bean。</p><p>Spring 如何根据 xml 配置来实现实例化类？</p><p>大致可以分为三步（配合源码 <strong>v1</strong> 阅读）：</p><ol><li><p>从 xml 配置文件获取 Bean 信息：id、beanClassName（路径），将其作为 BeanDefinition（Bean 定义类）的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BeanDefinition bd = <span class="keyword">new</span> BeanDefinition(id, beanClassName);</span><br></pre></td></tr></table></figure></li><li><p>使用一个 Map 存放所有 BeanDefinition，此时 Spring 本质上是一个 Map，存放 BeanDefinition</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">64</span>);</span><br></pre></td></tr></table></figure></li><li><p>当获取 Bean 实例时，通过类加载器，根据路径，得到其类对象，通过类对象利用<strong>反射</strong>创建 Bean 实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> Thread.currentThread().getContextClassLoader().loadClass(bd.getBeanClassName()).newInstance();</span><br></pre></td></tr></table></figure></li></ol><p>关于类加载和反射，前者可以看看<a href="https://book.douban.com/subject/34907497/" target="_blank" rel="noopener">《深入理解 Java 虚拟机》</a>第 7 章，后者可以看看 <a href="https://depp.wang/2020/04/29/reflection-in-spring-and-reflection-principle/">Spring 中的反射与反射的原理</a>。本文只学习 Spring，这两个知识点不做深入讨论。</p><p>本节源码对应：<strong>v1</strong></p><h2 id="二、实现「填充属性（依赖注入）」"><a href="#二、实现「填充属性（依赖注入）」" class="headerlink" title="二、实现「填充属性（依赖注入）」"></a>二、实现「填充属性（依赖注入）」</h2><!--使用 Spring 时，我们希望只需要声明一下就能使用--><!--直接 new 改为依赖注入--><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PetStoreService</span> </span>&#123;</span><br><span class="line">    AccountDao accountDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当不默认 new 时，实现实例化 Bean 后，此时成员变量（属性）还为 null：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-04-17-143303.png" alt=""></p><!--当一个 Bean 的成员变量类型是另一个 Bean 时，我们可以说一个 Bean 依赖于另一个 Bean。当不默认 new 时，就需要使用依赖注入（**D**ependency **I**njection，简称 DI）的方式设置依赖。依赖注入让属性不为 null，所以也可以称为填充属性。--><!--Spring 通过依赖注入的方式实现填充属性。--><p>此时需要通过一种方式实现让属性不为 null，我们管这一步叫填充属性。</p><p>当一个 Bean 的成员变量类型是另一个 Bean 时，我们可以说一个 Bean 依赖于另一个 Bean。所以填充属性，也可以称为依赖注入（<strong>D</strong>ependency <strong>I</strong>njection，简称 DI）。</p><p>抛开 Spring 不谈，在正常情况下，我们有两种方式实现依赖注入，1、使用构造方法；2、使用 Setter() 方法。一般使用构造方法（因为依赖可能有多个）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PetStoreService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PetStoreService</span><span class="params">(AccountDao accountDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PetStoreService petStore = <span class="keyword">new</span> PetStoreService(<span class="keyword">new</span> AccountDao()); <span class="comment">// 将依赖 new AccountDao() 注入 petStore</span></span><br></pre></td></tr></table></figure><p>Spring 也是通过这两种方式来实现依赖注入。</p><p>我们需要告诉 Spring，需要为类使用什么方式注入依赖，注入什么依赖。比如，我们想 Spring 使用构造函数的方式，注入 AccountDao 依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"petStore"</span> <span class="attr">class</span>=<span class="string">"org.deppwang.litespring.v2.service.PetStoreService"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"accountDao"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring 如何根据 <code>&lt;constructor-arg&gt;</code> 来实现依赖注入？</p><p>大致也分为 3 步（配合源码 <strong>v2</strong> 阅读）：</p><ol><li><p>从 xml 中获取构造函数的参数实例的 id，存放到 BeanDefinition 的 constructorArguments 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bd.getConstructorArgumentValues().add(argumentName);</span><br></pre></td></tr></table></figure></li><li><p>通过反射得到 PetStoreService 所有的构造函数（Constructor 对象），找到参数跟 constructorArguments 一致的 Constructor 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] candidates = beanClass.getDeclaredConstructors();</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>通过 constructorArguments 获取到所有参数实例，再利用反射，通过 Constructor 对象实现填充属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> constructorToUse.newInstance(argsToUse);</span><br></pre></td></tr></table></figure></li></ol><p>基于 Setter() 方法实现依赖注入的方式跟构造方法差不多，源码中有实现，请看源码。</p><p>实际上，Spring 默认先尝试使用构造函数注入依赖，当没有配置 <code>&lt;constructor-arg&gt;</code> 时，使用 <code>&lt;property&gt;</code>。</p><p>因为 Spring 实现了依赖注入，所以我们程序员没有了创建对象的控制权，所以也被称为控制反转（<strong>I</strong>nversion <strong>o</strong>f <strong>C</strong>ontrol，简称  IoC）。因为 Spring 使用 Map 管理 BeanDefinition，我们也可以将 Spring 称为 IoC 容器。</p><p>本节源码对应：<strong>v2</strong></p><h2 id="三、使用「单例模式、工厂方法模式」"><a href="#三、使用「单例模式、工厂方法模式」" class="headerlink" title="三、使用「单例模式、工厂方法模式」"></a>三、使用「单例模式、工厂方法模式」</h2><p>前面两步实现了获取 Bean 实例时创建 Bean 实例，但 Bean 实例经常使用，不能每次都新创建。其实在 Spring 中，一个 Bean 只对应一个 Bean 实例，这需要使用单例模式。</p><blockquote><p>单例模式：一个类有且只有一个实例</p></blockquote><p>Spring 使用类对象创建 Bean 实例，是如何实现单例模式的？</p><p>Spring 其实使用一个 Map 存放所有 Bean 实例。创建时，先看 Map 中是否有 Bean 实例，没有就创建；获取时，直接从 Map 中获取。这种方式能保证一个类只有一个 Bean 实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">64</span>);</span><br></pre></td></tr></table></figure><p>因为存放 Bean 实例也是 Map，这是除 beanDefinitionMap 外，Spring 称为 IoC 容器的另一个原因。</p><p>我们将创建对象的控制权交给 Spring（BeanIocContainer.java），我们可以认为 BeanIocContainer.java 是一个创建对象的工厂（专门生产对象），也可以称为简单工厂。它实现了创建对象和使用对象分离。</p><p>Spring 为了使用不同的方式均可实现实例化 Bean，不能只是简单工厂，需要使用工厂方法模式。</p><blockquote><p>工厂方法模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。来源：《Head First 设计模式》</p></blockquote><p>简单的理解就是：将创建对象的方法抽象，作为一个工厂方法。</p><p>这里的「让子类决定实例化哪一个类」，也可以看成让子类决定如何实现实例化类。</p><p>我们可以把工厂方法模式理解为简单工厂的升级版，可通过子类实现多种方式创建对象，是一种简单工厂的「多态」。</p><p>早期 Spring 使用 Bean 的策略是用到时再实例化所用 Bean，杰出代表是 XmlBeanFactory。后期为了实现更多的功能，新增了 ApplicationContext，初始化时就实例化所有 Bean，两者都继承于 BeanFactory 接口。</p><!--两者的区别：ApplicationContext 初始化时就实例化所有 Bean，BeanFactory 用到时再实例化所用 Bean。--><!--这里创建对象的工厂方法是**构造方法**。--><p>实现：将 BeanIocContainer 修改为 BeanFactory 接口，只提供 getBean() 方法。实现不同的子类对应不同什么的方式实例化 Bean。</p><p>Spring 使用 *<em>getBean() *</em>作为工厂方法。getBean() 包含创建对象的方法。</p><p>本节源码对应：<strong>v3</strong></p><h2 id="四、实现「注解」"><a href="#四、实现「注解」" class="headerlink" title="四、实现「注解」"></a>四、实现「注解」</h2><p>在业务开发中，如果每个业务类均设置构造函数，并且需要在 xml 中配置，那么就太繁琐，还容易出错。Spring 从 2.5<sup><a href="https://www.tutorialspoint.com/spring/spring_annotation_based_configuration.htm" target="_blank" rel="noopener">ref</a></sup> 开始，新增了注解，可以使用注解来替代业务类的 xml 配置和构造函数。</p><ul><li>使用 @Component 注解代替 <code>&lt;bean&gt;</code></li><li>使用 @Autowired 注解代替 <code>&lt;constructor-arg&gt;</code> + 构造函数。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PetStoreService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring 如何根据注解来实现实例化 Bean 和依赖注入？或者说，这两个注解起了什么作用？</p><p>1、@Component 用于生成 BeanDefinition，实现原理（配合源码 <strong>v4</strong> 阅读）：</p><ul><li><p>根据 <code>&lt;context:component-scan&gt;</code> 指定路径，找到路径下所有包含 @Component 注解的 Class 文件，作为 BeanDefinition</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String basePackagesStr = ele.attributeValue(<span class="string">"base-package"</span>);</span><br></pre></td></tr></table></figure></li><li><p>如何判断 Class 是否有 @Component：利用字节码技术，获取 Class 文件中的元数据（注解），判断元数据中是否有 @Componet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">annotationMetadata.hasAnnotation(Component.class.getName())</span><br></pre></td></tr></table></figure></li></ul><p>2、@Autowired 用于依赖注入，实现原理（配合源码 <strong>v4</strong> 阅读）：</p><ul><li><p>通过反射，得到所有的属性（Field 对象），查看 Field 对象中是否有 @Autowired 类型的注解，有，则使用反射实现依赖注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Field[] fields = bean.getClass().getDeclaredFields();</span><br><span class="line">field.set(bean, getBean(field.getName()));</span><br></pre></td></tr></table></figure></li><li><p>注意：使用 @Autowired 时，既没有使用构造方法，也没有使用 Setter() 方法</p></li></ul><p>@Component + @Autowired 实现 Spring 对业务类的管理。被 @Component + @Autowired  修饰的业务类算是一种特殊的 Bean。</p><p>至此，我们还是在需要通过配置文件来实现组件扫描。有没有完全不使用配置文件的方式？有！</p><p>我们可以使用 @Configuration 替代配置文件，并使用 @ComponentScan 来替代配置文件的  <code>&lt;context:component-scan&gt;</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 将类标记为 @Configuration，代表这个类是相当于一个配置文件</span></span><br><span class="line"><span class="meta">@ComponentScan</span> <span class="comment">// ComponentScan 扫描 PetStoreConfig.class 所在路径及其所在路径所有子路径的文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PetStoreConfig</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(PetStoreConfig.class);</span><br><span class="line">        PetStoreService userService = context.getBean(PetStoreService.class);</span><br><span class="line">        userService.getAccountDao();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用注解其实跟使用 xml 配置文件一样，目的是将配置类作为入口，实现扫描组件，将其加载进 IoC 容器中的功能。</p><p>AnnotationConfigApplicationContext 是专为针对配置类的启动类。其实现机制，可以 Google 查阅。</p><p>前面说：在 Spring 中，我们管类叫 Bean。其实不完全正确，类要称为 Bean，需要满足一个条件：</p><ul><li>当有成员变量时，要么有 @Autowired 注解，要么有对应的构造函数或者 Setter() 方法</li></ul><p>即可以被 Spring 管理的类，称为 Bean。</p><p>名词解释：</p><ul><li>Component：组件</li><li>Autowired：自动装配</li></ul><p>本节源码对应：<strong>v4</strong></p><h2 id="五、注解-Bean"><a href="#五、注解-Bean" class="headerlink" title="五、注解 @Bean"></a>五、注解 @Bean</h2><p>只要类是一个 Bean，就可以由 Spring 管理。</p><p>业务类为了减少配置，可使用 @Component + @Autowired 实现依赖注入。</p><p>将其他 Bean 注入容器时，虽然可以通过 xml 实现，但仍然比较麻烦，Spring 提供了一个注解 @Bean，当一个方法标记为 @Bean 时，它的返回值将被注入容器。</p><p>举个栗子：我们可以将一个线程池 Executor 实例注入容器，再 @Autowired 使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">sendMessageExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExecutorService executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">2</span>,</span><br><span class="line">                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">1024</span>), <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ExecutorService service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这如果用 xml 来实现，就比较麻烦了，还不直观。</p><!--如果 Bean 没有构造函数或者 Setter 方法，需要引用 @Autowired--><p>注意：@Bean 需要和 @Configuration 一起使用</p><p>本节源码对应：<strong>v5</strong></p><!--如果一个标记为 @Bean 的函数需要使用另一个类，那么另一个类也要注入容器？除非它本身也作为 Bean--><h2 id="六、Spring-Boot-原理"><a href="#六、Spring-Boot-原理" class="headerlink" title="六、Spring Boot 原理"></a>六、Spring Boot 原理</h2><p>前面说到了 @Configuration 和 @ComponentScan，这就不得不提 Spring Boot。因为 Spring Boot 就使用了  @Configuration 和 @ComponentScan，你可以点开 @SpringBootApplication 看到。</p><p>我们发现，Spring Boot 启动时，并没有使用 AnnotationConfigApplicationContext 来指定启动某某 Config 类。这是因为它使用了 @EnableAutoConfiguration 注解。</p><p>Spring Boot 利用了 @EnableAutoConfiguration 来自动加载标识为 @Configuration 的配置类到容器中。Spring Boot 还可以将需要自动加载的配置类放在 spring.factories 中，Spring Boot 将自动加载 spring.factories 中的配置类。spring.factories 需放置于META-INF 下。</p><p>如 Spring Boot 项目启动时，autocofigure 包中将自动加载到容器的（部分）配置类如下：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-04-05-092624.png?ynotemdtimestamp=1587214457308" alt=""></p><p>以上也是 Spring Boot 的原理。</p><p>在 Spring Boot 中，我们引入的 jar 包都有一个字段，<strong>starter</strong>，我们叫 starter 包。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-04-18-151532.png" alt=""></p><p>标识为 starter（启动器）是因为引入这些包时，我们不用设置额外操作，它能被自动装配，starter 包一般都包含自己的 spring.factories。如 spring-cloud-starter-eureka-server：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-04-18-134518.png" alt=""></p><p>如 druid-spring-boot-starter：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-04-19-085235.png" alt=""></p><p>有时候我们还需要自定义 starter 包，比如在 Spring Cloud 中，当某个应用要调用另一个应用的代码时，要么调用方使用 Feign（HTTP），要么将被调用方自定义为 starter 包，让调用方依赖引用，再 @Autowired 使用。此时需要在被调用方设置配置类和 spring.factories：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderAppConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// spring.factories</span></span><br><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.amy.cloud.amycloudact.ProviderAppConfiguration</span><br></pre></td></tr></table></figure><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-04-18-111026.png" alt=""></p><p>当然，你也可以把这两个文件放在调用方（此时要指定扫描路径），但一般放在被调用方。ps：如果你两个应用的 base-package 路径一样，那么可以不用这一步。</p><p>说了 Spring Boot，那么在 Spring MVC，如何将引入 jar 包的组件注入容器？</p><ul><li>跟扫描本项目包一样，在 xml ，增加引入 jar 包的扫描路径：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"引入 jar 包的 base-package"</span> /&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>嗯，本节没有源码</p><h2 id="七、结语"><a href="#七、结语" class="headerlink" title="七、结语"></a>七、结语</h2><p>Spring 的原理离不开两个关键词：反射和注解。</p><ul><li>反射：在创建 Bean 实例和依赖注入是都需要使用反射。</li><li>注解：使用注解可大大提升代码可阅读性，降低复杂度。注解本质上是作为一个标识，获取注解时需要使用字节码技术。</li></ul><p>现在我们一般很少使用 xml 来设置 bean，但了解了 xml 可以更好的理解 Spring 注解的原理。</p><p>来个注解小结：</p><ul><li>@Component 作为组件标识，代表需要 Spring 管理</li><li>@Autowired 用于判断是否需要依赖注入，代替构造函数</li><li>@ComponentScan 指定组件扫描路径，不指定即为当前路径</li><li>@Configuration 代表配置类，作为 Spring 寻找需要被管理 Bean 的入口</li><li>@Bean 实现将任意 Bean 注入容器</li><li>@EnableAutoConfiguration 实现自动加载配置类到容器</li></ul><p>以上实现了一个简易的 Spring IoC 容器，顺便说了一下 Spring Boot 原理。Spring 还有很多重要功能，如：处理对象之间的依赖、管理 Bean 生命周期、AOP 的实现，等等。后续有机会再做一次分享。</p><p>全文完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者：&lt;a href=&quot;https://depp.wang&quot;&gt;DeppWang&lt;/a&gt;、&lt;a href=&quot;https://depp.wang/2020/04/19/realize-a-simple-spring-ioc-container&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-04-19-110638.jpg&quot; alt=&quot;source:https://fernandofranzini.wordpress.com/&quot;&gt;&lt;/p&gt;
&lt;p&gt;我通过实现一个简易的 Spring IoC 容器，算是真正入门了 Spring 框架。本文是对实现过程的一个总结提炼，&lt;strong&gt;需要配合源码阅读&lt;/strong&gt;，&lt;a href=&quot;https://github.com/DeppWang/litespring&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源码地址&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;结合本文和源码，你应该可以学到：Spring 的原理和 Spring Boot 的原理。&lt;/p&gt;
&lt;p&gt;Spring 框架是 Java 开发的，Java 是面向对象的语言，所以 Spring 框架本身有大量的抽象、继承、多态。对于初学者来说，光是理清他们的逻辑就很麻烦，我摒弃了那些包装，只实现了最本质的功能。代码不是很严谨，但只为了理解 Spring 思想却够了。&lt;/p&gt;
&lt;p&gt;下面正文开始。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="https://depp.wang/categories/Spring/"/>
    
    
      <category term="Spring" scheme="https://depp.wang/tags/Spring/"/>
    
      <category term="IoC" scheme="https://depp.wang/tags/IoC/"/>
    
  </entry>
  
  <entry>
    <title>你真的会写单例模式吗</title>
    <link href="https://depp.wang/2020/04/10/singleton-pattern/"/>
    <id>https://depp.wang/2020/04/10/singleton-pattern/</id>
    <published>2020-04-10T08:09:37.000Z</published>
    <updated>2020-06-11T13:09:39.058Z</updated>
    
    <content type="html"><![CDATA[<p>作者：<a href="https://depp.wang">DeppWang</a>、<a href="https://depp.wang/2020/04/10/singleton-pattern/">原文地址</a></p><p>又一篇一抓一大把的博文，可是你真的的搞懂了吗？点开看看，事后，你也来一篇。。。</p><blockquote><p>人生在世，谁不面试。单例模式：一个搞懂不加分，不搞懂减分的知识点</p></blockquote><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-04-10-143047.jpg" alt="img"></p><p>单例模式是面试中非常喜欢问的了，我们往往自认为已经完全理解了，没什么问题了。但要把它手写出来的时候，可能出现各种小错误，下面是我总结的快速准确的写出单例模式的方法。</p><p>单例模式有各种写法，什么「双重检锁法」、什么「饿汉式」、什么「饱汉式」，总是记不住、分不清。这就对了，人的记忆力是有限的，我们应该记的是最基本的单例模式怎么写。</p><p>单例模式：一个类有且只能有一个对象（实例）。单例模式的 3 个要点：</p><ol><li>外部不能通过 new 关键字（构造函数）的方式新建实例，所以构造函数为私有：<code>private Singleton(){}</code></li><li>只能通过类方法获取实例，所以获取实例的方法为公有、且为静态：<code>public static Singleton getInstance()</code></li><li>实例只能有一个，那只能作为类变量的「数据」，类变量为静态 （另一种记忆：静态方法只能使用静态变量）：<code>private static Singleton instance</code></li></ol><a id="more"></a><h2 id="一、最基础、最简单的写法"><a href="#一、最基础、最简单的写法" class="headerlink" title="一、最基础、最简单的写法"></a>一、最基础、最简单的写法</h2><p>类加载的时候就新建实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Singleon using static initialization in Java"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here is how to access this Singleton class</span></span><br><span class="line">Singleton.getInstance().show();</span><br></pre></td></tr></table></figure><p>当执行 Singleton.getInstance() 时，类加载器加载 Singleton.class 进虚拟机，虚拟机在方法区（元数据区）为类变量分配一块内存，并赋值为空。再执行类构造器 <code>&lt;client&gt;()</code> 方法，新建实例指向类变量 instance。这个过程在类加载阶段执行，并由虚拟机保证线程安全。所以执行 getInstance() 前，实例就已经存在，所以 getInstance() 是线程安全的。</p><p>很多博文说 instance 还需要声明为 final，其实不用。final 的作用在于不可变，使引用 instance 不能指向另一个实例，保证变量可见性（线程安全），因为 instance 不会改变，这里用不上。当然，加上也没问题。</p><p>看到这里，单例模式的写法你已经学到了。后面的是加餐，可以选择不看了。</p><!--// final 修饰的基本数据类型，在编译期时，初始化数据放在常量池--><p>这个写法有一个不足之处，就是如果需要通过参数设置实例，则无法做到。举个栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能设置 name！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Singleon using static initialization in Java"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here is how to access this Singleton class</span></span><br><span class="line">Singleton.getInstance(<span class="string">"test"</span>).show();</span><br></pre></td></tr></table></figure><h2 id="二、可通过参数设置实例的写法"><a href="#二、可通过参数设置实例的写法" class="headerlink" title="二、可通过参数设置实例的写法"></a>二、可通过参数设置实例的写法</h2><p>考虑到这种情况，就在调用 getInstance() 方法时，再新建实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">",hashcode: "</span> + instance.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton.getInstance(<span class="string">"test"</span>).show();</span><br></pre></td></tr></table></figure><p>这里加了 <code>synchronized</code> 关键字，能保证线程安全（只会生成一个实例），但效率不高。因为实例创建成功后，再获取实例时就不用加锁了。</p><p>当不加 synchronized 时，会发生什么：</p><p>instance 是类的变量，类存放在方法区（元数据区），元数据区线程共享，所以类变量 instance 线程共享，类变量也是在主内存中。线程执行 getInstance() 时，在自己工作内存新建一个栈帧，将主内存的 instance 拷贝到工作内存。多个线程并发访问时，都认为 <code>instance == null</code>，就将新建多个实例，那单例模式就不是单例模式了。</p><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                Singleton.getInstance(<span class="string">"test"</span>).show();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、改良版加锁的写法"><a href="#三、改良版加锁的写法" class="headerlink" title="三、改良版加锁的写法"></a>三、改良版加锁的写法</h2><p>实现只在创建的时候加锁，获取时不加锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么要判断两次：</strong></p><p>多个线程将 instance 拷贝进工作内存，即多个线程读取到 instance == null，虽然每次只有一个线程进入 synchronized 方法，当进入线程成功新建了实例，synchronized 保证了可见性（在 unlock 操作前将变量写回了主内存），此时 instance 不等于 null 了，但其他线程已经执行到 synchronized 这里了，某个线程就又会进入 synchronized 方法，如果不判断一次，又会再次新建一个实例。</p><p><strong>为什么要用 volatile 修饰 instance：</strong></p><p>synchronized 已经可以实现原子性、可见性、有序性，其中实现原子性：一次只有一个线程执行同步块的代码。但计算机为了提升运行效率，会指令重排序。</p><p>代码 <code>instance = new Singleton();</code> 会被计算机拆为 3 步执行。</p><ul><li>A：在堆中分配一块内存空间</li><li>B：在内存空间位置新建一个实例</li><li>C：将引用指向实例，即，引用存放实例的内存空间地址</li></ul><p>线程可能按 ACB 执行，如果 instance 都在 synchronized 里面，怎么重排序都没啥问题，问题出现在还有 instance 在 synchronized 外边，因为此时外边一群饿狼（线程），就在等待一个 instance 这块肉不为 null。</p><p>模拟一下指令重排序的出错场景：多线程环境下，正好一个线程，在同步块中按 ACB 执行，执行到 AC 时（并将 instance 写回了主内存），另一个线程执行第一个判断时，从主内存拷贝了最新的 instance，认为 instance 不为空，返回 instance，但此时 instance 还没被正确初始化，所以出错。</p><p>volatile 修饰 instance 时，虚拟机在 ACB 后添加一个 <code>lock</code> 指令，lock 指令之前的操作执行完成后，后面的操作才能执行。只有当 ACB 都执行完了之后，其他线程才能读取 instance 的值，即：只有当写操作完成之后，读操作才能开始。这也是 Java 虚拟机规范的其中一条先行发生原则：对 volatile 修饰的变量，读操作，必须等写操作完成。</p><p>所以用 volatile 修饰 instance，是使用它的禁止指令重排序特性：禁止读指令重排序到写指令之前。（它禁止不了 lock 指令前的指令重排序。）</p><p>你可能认为上面的解释太复杂，不好理解。对，确实比较复杂，看不懂，下次问到再看吧。</p><h2 id="四、其他非主流写法"><a href="#四、其他非主流写法" class="headerlink" title="四、其他非主流写法"></a>四、其他非主流写法</h2><p>枚举写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当面试官让我写一个单例模式，我总是觉得写这个好像有点另类。</p><p>静态内部类写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE; </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个写法还是比较有逼格的，但稍不注意就容易出错。</p><h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><p>单例模式主要为了节省内存开销，Spring 容器的 Bean 就是通过单例模式创建出来的。</p><p>单例模式没写出来，那也没啥事，因为那下一个问题你也不一定能答出来 :)。</p><!--单例模式不会写，也不影响你称为大佬，哈哈。--><h2 id="六、延伸阅读"><a href="#六、延伸阅读" class="headerlink" title="六、延伸阅读"></a>六、延伸阅读</h2><ul><li><a href="http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/" target="_blank" rel="noopener">如何正确写出单例模式</a></li><li><a href="http://javarevisited.blogspot.com/2012/12/how-to-create-thread-safe-singleton-in-java-example.html" target="_blank" rel="noopener">How to create thread safe Singleton in Java</a></li><li><a href="https://javarevisited.blogspot.com/2012/07/why-enum-singleton-are-better-in-java.html" target="_blank" rel="noopener">Why Enum Singleton are better in Java</a></li><li><a href="https://stackoverflow.com/questions/228164/on-design-patterns-when-should-i-use-the-singleton" target="_blank" rel="noopener">On design patterns: When should I use the singleton? </a></li></ul><!--![个人公众号](https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-04-10-150424.png)-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者：&lt;a href=&quot;https://depp.wang&quot;&gt;DeppWang&lt;/a&gt;、&lt;a href=&quot;https://depp.wang/2020/04/10/singleton-pattern/&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;又一篇一抓一大把的博文，可是你真的的搞懂了吗？点开看看，事后，你也来一篇。。。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;人生在世，谁不面试。单例模式：一个搞懂不加分，不搞懂减分的知识点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-04-10-143047.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;单例模式是面试中非常喜欢问的了，我们往往自认为已经完全理解了，没什么问题了。但要把它手写出来的时候，可能出现各种小错误，下面是我总结的快速准确的写出单例模式的方法。&lt;/p&gt;
&lt;p&gt;单例模式有各种写法，什么「双重检锁法」、什么「饿汉式」、什么「饱汉式」，总是记不住、分不清。这就对了，人的记忆力是有限的，我们应该记的是最基本的单例模式怎么写。&lt;/p&gt;
&lt;p&gt;单例模式：一个类有且只能有一个对象（实例）。单例模式的 3 个要点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;外部不能通过 new 关键字（构造函数）的方式新建实例，所以构造函数为私有：&lt;code&gt;private Singleton(){}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;只能通过类方法获取实例，所以获取实例的方法为公有、且为静态：&lt;code&gt;public static Singleton getInstance()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;实例只能有一个，那只能作为类变量的「数据」，类变量为静态 （另一种记忆：静态方法只能使用静态变量）：&lt;code&gt;private static Singleton instance&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java" scheme="https://depp.wang/categories/Java/"/>
    
    
      <category term="Singleton Pattern" scheme="https://depp.wang/tags/Singleton-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>随意修改你文章的 url 吧，一个 js 解决原 url 不能访问的问题</title>
    <link href="https://depp.wang/2020/03/27/redirect-404-url-by-js/"/>
    <id>https://depp.wang/2020/03/27/redirect-404-url-by-js/</id>
    <published>2020-03-27T20:48:37.000Z</published>
    <updated>2020-06-11T13:09:39.062Z</updated>
    
    <content type="html"><![CDATA[<p>作者：<a href="https://depp.wang">DeppWang</a></p><p>阅读提示：此文适用于有自己博客的同学。</p><p>昨天在公众号分享了一篇在 <a href="https://depp.wang/2020/03/26/how-to-insert-slide-in-markdown/">如何在 Markdown 里面插入幻灯片</a>的文章，微信公众号由于平台限制，幻灯片只能在原文里面才能看到效果，不巧，原文链接手误写错了一个单词，本来是 insert，写成了 inset。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">https</span>://depp.wang/<span class="number">2020</span>/<span class="number">03</span>/<span class="number">26</span>/how-<span class="built_in">to</span>-inset-slide-<span class="keyword">in</span>-markdown/</span><br><span class="line">应该是</span><br><span class="line"><span class="keyword">https</span>://depp.wang/<span class="number">2020</span>/<span class="number">03</span>/<span class="number">26</span>/how-<span class="built_in">to</span>-insert-slide-<span class="keyword">in</span>-markdown/</span><br></pre></td></tr></table></figure><p>作为一个强迫症患者，不能忍受这样的问题。可一旦我修改了原文链接，公众号这边要么删了重发，要么来个留言，说原文链接已经修改。两种方式可以解决问题，但是不爽。</p><p>除了像我手误写错链接单词的情况，<strong>很多时候，我们文章修改题目后，如果想修改 url（url 是文章题目的英文），就会面临原 url 失效的问题。</strong></p><p>如果你也有上面这种困扰，那么可以看看我的解决思路。</p><a id="more"></a><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>我的思路是这样：自定义一个 404 页面，链接失效就显示 404 页面，404 页面引入一个重定向指定 url 的 js。</p><p>重定向指定 url 的 js 的代码很简单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">redirectUrl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> redirectObj = &#123;</span><br><span class="line">        <span class="string">"https://depp.wang/2020/03/26/how-to-inset-slide-in-markdown/"</span>: <span class="string">"https://depp.wang/2020/03/26/how-to-insert-slide-in-markdown/"</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> newUrl = redirectObj[<span class="built_in">window</span>.location.href];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> newUrl !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="built_in">window</span>.location = newUrl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">redirectUrl();</span><br></pre></td></tr></table></figure><ul><li>此 js 使用条件：显示 404 页面时，原 url 不变，不能是重定向到 404 页面</li></ul><p>404 页面引入 js，404 页面可以用<a href="https://www.qq.com/404/" target="_blank" rel="noopener">腾讯公益 404 页面</a>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--404.html--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-type"</span> <span class="attr">content</span>=<span class="string">"text/html;charset=utf-8;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge,chrome=1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"robots"</span> <span class="attr">content</span>=<span class="string">"all"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"robots"</span> <span class="attr">content</span>=<span class="string">"index,follow"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"https://qzone.qq.com/gy/404/style/404style.css"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"https://depp.wang/redirectUrl.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> // 此处修改为你自己的 js 地址</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/plain"</span> <span class="attr">src</span>=<span class="string">"http://www.qq.com/404/search_children.js"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">charset</span>=<span class="string">"utf-8"</span> <span class="attr">homePageUrl</span>=<span class="string">"/"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">homePageName</span>=<span class="string">"回到主页"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://qzone.qq.com/gy/404/data.js"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://qzone.qq.com/gy/404/page.js"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>代码来源：<a href="http://theme-next.iissnan.com/theme-settings.html#volunteer-404" target="_blank" rel="noopener">http://theme-next.iissnan.com/theme-settings.html#volunteer-404</a></li><li>如果你使用 <a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">Hexo </a>+ <a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="noopener">Next</a>，注意 404.html 放在主题的 source 目录下。</li></ul><p>引入 js 代码时要注意路径，最好直接使用绝对路径。使用相对路径要考虑原文章所在路径与 js 文件路径之间的关联。</p><p>多说一嘴，相对路径有时候有点不好理解，需要理解相对路径常用两个符号 <code>.</code> 和 <code>..</code> 的含义：</p><ul><li><code>.</code>：一个点代表当前文件所在的文件夹（路径）。在 Linux 中，复制文件到当前路径的命令：<code>cp **/test.md .</code>。示例：<code>src=&quot;./redirectUrl.js&quot;</code>，代表引入和当前文件在同一个文件夹的 redirectUrl.js</li><li><code>..</code>：两个点代表当前文件所在的上一层文件夹（路径）。在 Linux 中，切换到上一层的命令： <code>cd ..</code></li></ul><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-27-074330.gif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者：&lt;a href=&quot;https://depp.wang&quot;&gt;DeppWang&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;阅读提示：此文适用于有自己博客的同学。&lt;/p&gt;
&lt;p&gt;昨天在公众号分享了一篇在 &lt;a href=&quot;https://depp.wang/2020/03/26/how-to-insert-slide-in-markdown/&quot;&gt;如何在 Markdown 里面插入幻灯片&lt;/a&gt;的文章，微信公众号由于平台限制，幻灯片只能在原文里面才能看到效果，不巧，原文链接手误写错了一个单词，本来是 insert，写成了 inset。&lt;/p&gt;
&lt;figure class=&quot;highlight livecodeserver&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;https&lt;/span&gt;://depp.wang/&lt;span class=&quot;number&quot;&gt;2020&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;03&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;26&lt;/span&gt;/how-&lt;span class=&quot;built_in&quot;&gt;to&lt;/span&gt;-inset-slide-&lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;-markdown/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;应该是&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;https&lt;/span&gt;://depp.wang/&lt;span class=&quot;number&quot;&gt;2020&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;03&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;26&lt;/span&gt;/how-&lt;span class=&quot;built_in&quot;&gt;to&lt;/span&gt;-insert-slide-&lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;-markdown/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;作为一个强迫症患者，不能忍受这样的问题。可一旦我修改了原文链接，公众号这边要么删了重发，要么来个留言，说原文链接已经修改。两种方式可以解决问题，但是不爽。&lt;/p&gt;
&lt;p&gt;除了像我手误写错链接单词的情况，&lt;strong&gt;很多时候，我们文章修改题目后，如果想修改 url（url 是文章题目的英文），就会面临原 url 失效的问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你也有上面这种困扰，那么可以看看我的解决思路。&lt;/p&gt;
    
    </summary>
    
      <category term="Software &amp; Website" scheme="https://depp.wang/categories/Software-Website/"/>
    
    
      <category term="URL" scheme="https://depp.wang/tags/URL/"/>
    
  </entry>
  
  <entry>
    <title>如何在 Markdown 里面插入幻灯片</title>
    <link href="https://depp.wang/2020/03/26/how-to-insert-slide-in-markdown/"/>
    <id>https://depp.wang/2020/03/26/how-to-insert-slide-in-markdown/</id>
    <published>2020-03-26T20:48:37.000Z</published>
    <updated>2020-06-11T13:09:39.062Z</updated>
    
    <content type="html"><![CDATA[<p>作者：<a href="https://depp.wang">DeppWang</a></p><p><strong>效果示例</strong>：</p><script async class="speakerdeck-embed" data-id="9780d352c95f4361bd8c6fa164554afc" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script><ul><li>幻灯片来自：<a href="https://deepu.tech/memory-management-in-jvm/" target="_blank" rel="noopener">https://deepu.tech/memory-management-in-jvm/</a></li></ul><a id="more"></a><p><strong>使用前提</strong>：博客（网站）使用可渲染 js 脚本的 markdown 解析器，如 hexo 静态博客。我测试了一下，掘金、博客园等将 markdown 转换（解析）为 html 时，会忽略幻灯片 js 脚本。</p><p><strong>原理</strong>：在网页中内嵌一个 js 脚本。</p><p><strong>步骤</strong>： </p><ol><li>将多个图片转换为一个 PDF，可使用 <a href="https://smallpdf.com/jpg-to-pdf" target="_blank" rel="noopener">Smallpdf</a> 转换。pdf 示例：<a href="https://drive.google.com/file/d/1RJ3j2F5hh4oR-RWOBRNI5DJCcT6Oh2VE/view?usp=sharing" target="_blank" rel="noopener">presentation.pdf</a></li><li>在  <a href="https://speakerdeck.com/" target="_blank" rel="noopener">Speaker Deck</a> 上传 PDF，生成<a href="https://speakerdeck.com/deppwang/google-drive-presentation" target="_blank" rel="noopener">幻灯片</a>，点击分享按钮，获取幻灯片可内嵌（Embed）到 markdown 的 js 脚本</li><li>在 markdown 粘贴 js 脚本即可</li></ol><p><strong>js 脚本</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">class</span>=<span class="string">"speakerdeck-embed"</span> <span class="attr">data-id</span>=<span class="string">"69f38a5da6a64b4086368afca27bc7e1"</span> <span class="attr">data-ratio</span>=<span class="string">"1.77777777777778"</span> <span class="attr">src</span>=<span class="string">"//speakerdeck.com/assets/embed.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>最终效果</strong>：</p><script async class="speakerdeck-embed" data-id="69f38a5da6a64b4086368afca27bc7e1" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者：&lt;a href=&quot;https://depp.wang&quot;&gt;DeppWang&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;效果示例&lt;/strong&gt;：&lt;/p&gt;
&lt;script async class=&quot;speakerdeck-embed&quot; data-id=&quot;9780d352c95f4361bd8c6fa164554afc&quot; data-ratio=&quot;1.77777777777778&quot; src=&quot;//speakerdeck.com/assets/embed.js&quot;&gt;&lt;/script&gt;

&lt;ul&gt;
&lt;li&gt;幻灯片来自：&lt;a href=&quot;https://deepu.tech/memory-management-in-jvm/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://deepu.tech/memory-management-in-jvm/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Markdown" scheme="https://depp.wang/categories/Markdown/"/>
    
    
      <category term="幻灯片" scheme="https://depp.wang/tags/%E5%B9%BB%E7%81%AF%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>互联网协议入门</title>
    <link href="https://depp.wang/2020/03/20/internet-protocol-suite-introduction/"/>
    <id>https://depp.wang/2020/03/20/internet-protocol-suite-introduction/</id>
    <published>2020-03-20T20:48:37.000Z</published>
    <updated>2020-06-11T13:09:39.066Z</updated>
    
    <content type="html"><![CDATA[<p>作者：<a href="https://depp.wang">DeppWang</a></p><p>互联网上的数据能从一台设备发送到另一台设备，整个过程由<a href="https://zh.wikipedia.org/wiki/TCP/IP协议族" target="_blank" rel="noopener">互联网协议</a>（ Internet Protocol Suite）实现的。 </p><p>对于互联网协议，一直一知半解。知道会分为几层，但为什么分层，分层有什么好处，都不甚理解。通过<a href="www.ruanyifeng.com">阮一峰</a>的这两篇文章，大概有了一个初步认识，下面是我对互联网协议的理解。</p><ul><li><a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="noopener">互联网协议入门（一）<em>阮一峰</em></a></li><li><a href="http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html" target="_blank" rel="noopener">互联网协议入门（二）<em>阮一峰</em></a></li></ul><a id="more"></a><!--一直以来的疑惑：--><!--为什么说 Dubbo 基于 TCP 协议，Spring Cloud 基于 HTTP 协议？难道 Spring Cloud 就没有使用应用层吗？HTTP 协议没有用到 TCP 协议吗（没有经过传输层吗）？怎么好像两者是并列的关系。为什么基于 TCP 协议的 Dubbo 就更快一些呢？--><!--一个打开网页的请求如何从客户端发送到服务端，并接受到请求的，其请求包是格式是怎样的。--><!--对于手机来说，这几层体现在哪里？或者说是哪个软件实现这几层的？--><h2 id="一、五层模型"><a href="#一、五层模型" class="headerlink" title="一、五层模型"></a>一、五层模型</h2><p>我也认为将互联网协议分为五层，可以更好的去理解它，从上往下分别是：应用层、传输层、网络层、（数据）链路层（链接层）和物理层（实体层）。如果死记硬背，往往过几天就忘了，所以需要了解其原理，当我们理解了全文，让我们去说文章的名字，那还不是轻而易举吗！</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-16-091651.png" alt="图片来自阮一峰博客"></p><p>大多数文章或书籍都是从上往下来讲解互联网协议，但是个人感觉总是没有深入其理，阮一峰<strong>自下而上</strong>的讲解每一层的功能，让人记忆深刻。我也依葫芦画瓢，先自下而上分析一下每一层的功能，再结合 <a href="https://www.wireshark.org/" target="_blank" rel="noopener">Wireshark</a> 抓包工具，来稍稍看看互联网协议的真面目。</p><h3 id="1-1-层与协议"><a href="#1-1-层与协议" class="headerlink" title="1.1 层与协议"></a>1.1 层与协议</h3><p>为什么叫某某层？为什么要分层？层是什么？</p><p>我觉得层这个叫法很形象，一层一层，好像平行，各自独立。维基百科的解释是：「<strong>整个通信网络的任务，可以划分成不同的功能区块，即所谓的层级（<a href="https://zh.wikipedia.org/w/index.php?title=Layer&action=edit&redlink=1" target="_blank" rel="noopener">layer</a>）</strong>」，我们可以理解为，每一层是实现了一个功能，有不同的分工。就跟写代码一样，如果把所有功能放一起，改一行代码就可能影响全部，所以根据不同功能拆成不同的方法。我觉得叫什么不重要，可以叫应用块、应用组，等等。<strong>主要知道，每一层是为了完成一个功能就行。</strong></p><p>我们知道，每一层都有自己对应的协议（Protocol），比如，网络层有 IP 协议。那何为协议？跟这个层又有什么关联？维基百科上有这么一句话：「网络层功能由 IP 协议规定和实现，故又称 IP 层」。我们可以看出，每一层的功能其实是协议来规定和实现的。所以，协议可以理解为，<strong>有大家都遵守的规则（规定），并负责去实现这个规则。</strong></p><h2 id="二、物理层（Physcial-Layer）"><a href="#二、物理层（Physcial-Layer）" class="headerlink" title="二、物理层（Physcial Layer）"></a>二、物理层（Physcial Layer）</h2><p>我们电脑现在不用插网线就能上网（连 WIFI），但是路由器插网线了，在家里，路由器一般又需要通过一根网线连接入户光纤盒（又称为光猫），光纤盒又需要通过一根光纤连接到其他设备。电脑连接 WiFi，电脑的数据发送到路由器，是通过无线电波。所以传输数据需要物理载体，类似网线、光纤、无线电波。<strong>我们将传输数据的物理载体称为物理层（Physcial Layer）</strong>。为什么我们访问美国的网站就慢一些，因为美国网站的服务器在美国，数据通过海底光缆传输，耗时会久一些。这也是为什么很多公司要在不同城市部署服务器的原因之一吧。</p><p>数据在物理载体中传输，传输的是什么呢？<strong>是 0 和 1 组成的电信号</strong>，为什么是 0 和 1 组成的电信号呢？这个吧，姑且通过类比的方式来解释，因为计算机只能识别 0 1 二进制，所以要传输 0 和 1 组成的电信号吧。</p><!--问好脸：网速的快慢由每 1 秒能传输电信号的多少决定？--><h2 id="三、链路层（Link-Layer）"><a href="#三、链路层（Link-Layer）" class="headerlink" title="三、链路层（Link Layer）"></a>三、链路层（Link Layer）</h2><p>物理层只是一个传输载体，没有「自主意识」， 我们需要借助物理层上的<a href="https://zh.wikipedia.org/wiki/数据链路层" target="_blank" rel="noopener">链路层</a>（Link Layer），<strong>链路层的功能：将数据从一处发送到另一处</strong>，链路层在发送方和接收方都有，在发送方：链路层将数据转换为电信号，并将其发送出去；在接收方：链路层收到电信号，并将电信号转换为数据。链路层和物理层之间的关系可以这样表示：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-131628.jpg" alt=""></p><p>在<a href="https://zh.wikipedia.org/wiki/局域网" target="_blank" rel="noopener">局域网</a>内，将数据从一处发送到另一处需要使用<a href="https://zh.wikipedia.org/wiki/以太网" target="_blank" rel="noopener">以太网</a>（Ethernet）。<strong>局域网的通俗理解，连接同一个 <a href="https://zh.wikipedia.org/wiki/Wi-Fi" target="_blank" rel="noopener">WiFi</a> （路由器 Router）的设备在同一个局域网内。</strong></p><h3 id="3-1-以太网"><a href="#3-1-以太网" class="headerlink" title="3.1 以太网"></a>3.1 以太网</h3><p>以太网是一种局域网技术，它可以实现局域网内的设备通信，我们现在电脑一般连 WiFi，WiFi 可以认为是「无线以太网」。</p><p>我们可以理解为，<strong>在局域网内，链路层的功能其实是由以太网实现的</strong>（局域网外的链路层比较复杂，本文不讨论）。 局域网内的链路层和以太网的关系可以这样表示（物理层作为以太网的传输载体）：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-121930.jpg" alt=""></p><p><strong>以太网需要规定电信号的格式，以便双方解读</strong>。以太网规定一组电信号为一个数据包，叫帧（Frame），帧包含两部分，标头（Head）和数据（Data），标头包含发送方地址、接收方地址等信息，数据则是数据包的具体内容。我们一般将帧称为以太网数据包，或者<a href="https://zh.wikipedia.org/wiki/以太网帧格式" target="_blank" rel="noopener">以太帧</a>，以太帧格式类似下面这样：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-17-065355.png" alt="以太帧，图片来自阮一峰博客"></p><p>每台网络设备都有自己的网卡，<strong>以太网是将数据从一块<a href="https://zh.wikipedia.org/wiki/网卡" target="_blank" rel="noopener">网卡</a>发送到另一块网卡</strong>，每块网卡需要有自己的「身份证号」，叫 <a href="https://zh.wikipedia.org/wiki/MAC地址" target="_blank" rel="noopener">MAC 地址</a>（iPhone 手机的 MAC 地址叫无线局域网地址），由 12 个十六进制数表示：</p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-121841.jpg" style="zoom:50%;"><blockquote><p>MAC地址：（<strong>M</strong>edia <strong>A</strong>ccess <strong>C</strong>ontrol Address），直译为媒体存取控制位址，也称为局域网地址（LAN Address），<strong>以太网地址</strong>（Ethernet Address）或<strong>物理地址</strong>（Physical Address），它是一个用来确认网络设备位置的地址。</p></blockquote><p>所以以太网发送前需要知道接收方网卡的 MAC 地址，即标头的接收方地址，但正常情况下，不知道接收方 MAC 地址，需要使用 <a href="https://zh.wikipedia.org/wiki/地址解析协议" target="_blank" rel="noopener">ARP 协议</a>得到（这个本文后面解释）</p><p>假设已经知道了 MAC 地址，那么在局域网内，以太网可以根据 MAC 地址，将数据发送给对方。但如果对方没有在一个局域网内，如何发送给对方呢？此时，就需要<a href="https://zh.wikipedia.org/wiki/网络层" target="_blank" rel="noopener">网络层</a>（Network Layer）出马了！</p><hr><p>以太网在 Windows 中的体现：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-123642.jpg" alt=""></p><p>在 macOS 的体现： <a href="https://zh.wikipedia.org/wiki/PPPoE" target="_blank" rel="noopener">PPPoE</a>（英语：<strong>P</strong>oint-to-<strong>P</strong>oint <strong>P</strong>rotocol <strong>o</strong>ver <strong>E</strong>thernet），以太网上的点对点协议。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-123706.jpg" alt=""></p><h2 id="四、网络层（Network-Layer）"><a href="#四、网络层（Network-Layer）" class="headerlink" title="四、网络层（Network Layer）"></a>四、网络层（Network Layer）</h2><p>首先，我们要区分接收方是否在一个局域网，使用 MAC 地址不能区分，需要设备有另外一个地址，能代表它所处的具体是哪个网络（局域网），我们称这个地址为「<strong>网络地址</strong>」。</p><p><strong>网络层的作用，就是根据网络地址找到目的主机处于哪一个局域网</strong>。实现这一功能的协议称为网络协议，即 <a href="https://zh.wikipedia.org/wiki/网际协议" target="_blank" rel="noopener">IP 协议</a> 。网络地址用于 IP 协议，所以网络地址也可以叫它 IP 地址。<strong>注意</strong>：我们叫 IP 协议，是一种习惯，其实 IP(<strong>I</strong>nternet <strong>P</strong>rotocol) 本身就有协议的意思。</p><!--如果设备连 WiFi，WiFi 是局域网，路由器会为设备分配一个局域网 IP 地址，它只能在局域网内部使用，所以也叫内部（本地） IP。局域网有一个对外访问互联网的 IP，称为外部 IP，**一个局域网内的所有设备共用一个外部 IP 地址**。在百度输入IP，显示的 IP 就是外部 IP，在「设置->网络」中看到的 IP 是内部 IP。我们称局域网为内网，内是相对的概念，代表没有外部 IP 就不能访问。--><p>如果设备连 WiFi，路由器会为设备分配一个 IP 地址。</p><h3 id="4-1-IP-协议"><a href="#4-1-IP-协议" class="headerlink" title="4.1 IP 协议"></a>4.1 IP 协议</h3><blockquote><p><strong>IP</strong> 协议：英语全称为：<strong>I</strong>nternet <strong>P</strong>rotocol，即<strong>网络协议</strong>，也称<strong>网际协议</strong>。</p></blockquote><p>现在大部分使用的还是 IP 协议第四版，简称 IPv4，IP 地址为 32 位（4*8，二进制）。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052908.png" alt="图片来自阮一峰博客"></p><p>有了 IP 地址，网络层可以通过 IP 地址来区分是否处于一个局域网。如何根据 IP 地址判断设备是否处于同一个局域网？答案是利用<a href="https://zh.wikipedia.org/wiki/子网#网络掩码" target="_blank" rel="noopener">子网掩码</a>。IP 地址分为两部分，网络部分和主机部分，如果子网掩码为 <code>255.255.255.0</code>（二进制表示：<code>11111111.11111111.11111111.00000000</code>），表示前 24 位代表网络部分，如果两个 IP 地址前 24 位相同，则代表是在同一个局域网中。</p><h3 id="4-2-IP-数据包"><a href="#4-2-IP-数据包" class="headerlink" title="4.2 IP 数据包"></a>4.2 IP 数据包</h3><p>数据经过网络层，IP 协议为数据加上包含发送方 IP 地址和接收方 IP 地址的标头，包装为 IP 数据包：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-17-134735.png" alt="图片来自阮一峰博客"></p><p>IP 数据包到达链路层时，直接作为作为以太帧的数据部分，嵌入以太帧。此时的以太帧的格式如下：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-17-134810.png" alt="图片来自阮一峰博客"></p><p>如果通过子网掩码判断接收方在一个局域网，就通过以太网发送，此时需要得到其 MAC 地址，前面说，需要 ARP 协议得到其 MAC 地址，何为 ARP 协议？</p><h3 id="4-3-ARP-协议"><a href="#4-3-ARP-协议" class="headerlink" title="4.3 ARP 协议"></a>4.3 ARP 协议</h3><p>ARP 协议，英语全称为：<strong>A</strong>ddress <strong>R</strong>esolution <strong>P</strong>rotocol，即地址解析协议，是一种通过 IP 地址得到 MAC 地址的协议。默认情况，发送方知道接收方的 IP 地址（通过 <a href="https://zh.wikipedia.org/wiki/域名系统" target="_blank" rel="noopener">DNS</a> 得到，这个又后面解释），所以发送方使用「广播」（broadcasting）的方式给当前局域网所有主机发送一个以太帧，包含对方的 IP 地址，对方 MAC 地址设为 <code>ff:ff:ff:ff:ff:ff</code>，接收方根据接收者 IP 地址判断自己是否为接收者，是，就发送一个数据包告诉对方自己的 MAC 地址，不是，就丢弃这个包。</p><p>通过这种方式，发送方就可以通过接收方的 IP 地址得到 MAC 地址。</p><p>如果通过子网掩码判断接收方不在一个局域网，通过 APR 协议就得不到对方的 MAC 地址，那就要使用<a href="https://zh.wikipedia.org/wiki/路由" target="_blank" rel="noopener">路由</a>（Route）的方式发送了。</p><h3 id="4-4-路由"><a href="#4-4-路由" class="headerlink" title="4.4 路由"></a>4.4 路由</h3><p>路由，简单来说，就是得到路由器的 MAC 地址，数据先发送到<a href="https://zh.wikipedia.org/wiki/路由器" target="_blank" rel="noopener">路由器</a>（Router），由路由器来发送下一个路由器，通过一系列路由中转，最后发给目标主机。</p><!--路由器往外发送时，使用的是外部 IP（互联网 IP）。使用外部 IP 才能和互联网通信，外部 IP 是名片--><p>其实就像发送快递一样，在快递上写上收件人的地址，由快递点发送给下一个中转站，再中转，最后收件人收到快递。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-030924.png" alt=""></p><p>一个简单的路由器，需要实现 IP 协议和链路层协议。</p><p>如果把上面的过程说的仔细一点，以太网是将以太帧发送给路由器链路层，路由器链路层将数据包发送给路由器网络层，路由器有一个路由表，网络层在路由表找到跟当前路由器相连的、离目的主机最近的路由器，路由器通过 ARP 协议，得到下一个路由器的 MAC 地址，让路由器链路层根据 MAC 地址，发送给下一个路由器。通过一系列中转，来到目的主机所在的路由器。使用同样的方式，通过以太网将以太帧发送给目的主机。整个过程大概是这样：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-030834.png" alt=""></p><p>我们常说，网络层负责寻址和路由，寻址就是寻找最近的 IP 地址，路由就是找到最近的路由 MAC 地址（我这么理解，不一定正确）。我们可以理解为：整个通信过程中的网络层负责寻址和路由，发送方的网络层其实负责它自己的寻址和路由。</p><!--前面说，局域网内的链路层是由以太网实现的。那么局域网外的后链路层呢？是通过骨干网等实现。--><h2 id="五、传输层（Transport-Layer）"><a href="#五、传输层（Transport-Layer）" class="headerlink" title="五、传输层（Transport Layer）"></a>五、传输层（Transport Layer）</h2><p>网络层和链路层实现了互联网任意两台主机之间的网络通信，此时还有两个问题，<strong>1、设备不止一个程序，具体发送给哪一个程序？2、没有保证数据包能发送成功。</strong></p><p>这时候就需要<a href="https://zh.wikipedia.org/wiki/传输层" target="_blank" rel="noopener">传输层</a>（Transport Layer），<strong>传输层的功能是保证数据能可靠传输到对方主机的应用程序上。</strong></p><p>应用是进程，<strong>每个进程使用网卡时，需要有一个编号，这个编号就是端口</strong>。系统默认占用 0 到 1023 的端口，系统会为软件随机分配 1024 到 65535 之间的端口。 常见术语套接字（Socket）就是 IP 地址 + 端口的组合称谓。</p><p>传输层要为发送的数据包中增加发送方和接收方的端口号。</p><p>传输层功能实现一般有两种协议，1 是 <a href="https://zh.wikipedia.org/wiki/传输控制协议" target="_blank" rel="noopener">TCP 协议</a>，2 是 <a href="https://zh.wikipedia.org/wiki/用户数据报协议" target="_blank" rel="noopener">UDP 协议</a>。</p><h3 id="5-1-TCP-协议"><a href="#5-1-TCP-协议" class="headerlink" title="5.1 TCP 协议"></a>5.1 TCP 协议</h3><blockquote><p><strong>TCP</strong> 协议，英语全称为：<strong>T</strong>ransmission <strong>C</strong>ontrol <strong>P</strong>rotocol，即，<strong>传输控制协议</strong></p></blockquote><p>TCP 协议使用用三次握手来保证线路的可靠，失败后，有失败重传机制，它是一个很复杂的协议，传输层的称谓，也是来源于 TCP 这个 <strong>传输控制协议</strong>。</p><p>TCP 协议发送的数据包叫 TCP 数据包，它的标头包含发送方端口和接收方端口，</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-17-141857.png" alt="图片来自阮一峰博客"></p><p>它发送数据包给网络层，网络层将 TCP 数据包作为 IP 数据包的数据部分，再发给链路层。此时以太帧格式如下：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-17-141939.png" alt="图片来自阮一峰博客"></p><p>因为以太帧有长度限制，TCP 协议没有规定数据的长度，所以当 TCP 数据包过长时，以太帧装不下，此时 TCP 数据包需要切分为多个 TCP 数据包。我们常常看到有的书籍说：传输层负责「请求报文」的分割。这就是传输层为什么要分割「请求报文」的缘故。</p><p>传输层保证数据的「可靠传输」，这句话常常被我们误解为，是由传输层传输数据，现在我们知道，传输数据的其实是链路层，传输层其实只是失败重传（当然不止这一个功能，这里这么说是为了方便理解）。所以这句话的重点在于<strong>可靠</strong>，不在传输。</p><h3 id="5-2-UDP-协议"><a href="#5-2-UDP-协议" class="headerlink" title="5.2 UDP 协议"></a>5.2 UDP 协议</h3><blockquote><p><strong>UDP 协议</strong>，英语全称为： <strong>U</strong>ser <strong>D</strong>atagram <strong>P</strong>rotocol，即<strong>用户数据包协议</strong></p></blockquote><p>传输层有一种简单的协议，叫 UDP 协议，UDP 协议只是为数据简单的加上包含发送方端口和接收方端口的标头，就将 UDP 数据包扔给网络层，它不保证是否能成功的发送给接收方，它是一种不可靠的传输协议。因为简单，减少了时间开销，常用于对时间有较高要求的应用程序。</p><h2 id="六、应用层（Application-Layer）"><a href="#六、应用层（Application-Layer）" class="headerlink" title="六、应用层（Application Layer）"></a>六、应用层（Application Layer）</h2><p>链路层、网络层、传输层实现了数据包能从主机应用发送到目的主机应用。正常情况下，网络上主要传输的数据是应用产生的。传输的数据各种各样，有网络请求，有电子邮件等等。数据需要由<a href="https://zh.wikipedia.org/wiki/应用层" target="_blank" rel="noopener">应用层</a>（Application Layer）封装，即规定数据的格式。</p><p>规定「HTML 数据」格式的是 <a href="https://zh.wikipedia.org/wiki/超文本传输协议" target="_blank" rel="noopener">HTTP 协议</a>。可以说，HTTP 协议是应用层的一种实现。</p><h3 id="6-1-HTTP-协议"><a href="#6-1-HTTP-协议" class="headerlink" title="6.1 HTTP 协议"></a>6.1 HTTP 协议</h3><blockquote><p><strong>HTTP 协议</strong>：英文全称为：H<strong>yper</strong>T<strong>ext **T</strong>ransfer <strong>P</strong>rotocol，即超文本转移（传输）协议</p></blockquote><p>当我们打开百度首页时，输入的就是一个网址 <code>www.baidu.com</code>，这是一个 GET 请求，HTTP 协议将请求封装为应用层数据包。这样，百度的服务器应用层就可以根据 HTTP 协议来解析数据包。</p><p>HTTP 请求的数据包一般称为请求报文，分为报文首部和报文主题，报文首部即为请求头，请求头格式如下：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-123839.jpg" alt=""></p><p>包含的应用层数据包的以太帧格式如下：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-17-143436.png" alt="图片来自阮一峰博客"></p><h3 id="6-2-DNS"><a href="#6-2-DNS" class="headerlink" title="6.2 DNS"></a>6.2 DNS</h3><blockquote><p> <strong>DNS</strong>：英语全称为： <strong>D</strong>omain <strong>N</strong>ame <strong>S</strong>ystem，即<strong>域名系统</strong></p></blockquote><p>类似  <code>www.baidu.com</code> 这样的网址域名，是为了用户方便记忆，网络通信时，需要将域名转换为 IP 地址，这是由 <a href="https://zh.wikipedia.org/wiki/域名系统" target="_blank" rel="noopener">DNS</a> 负责的，它也属于应用层。</p><h2 id="七、WireShark-抓包分析"><a href="#七、WireShark-抓包分析" class="headerlink" title="七、WireShark 抓包分析"></a>七、WireShark 抓包分析</h2><p>当 Mac 连 WIFI 后，可以在「设置-&gt;网络」中看见下面这些内容：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-123927.jpg" alt="TCP/IP"></p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-123948.jpg" alt="MAC 地址"></p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-124038.jpg" alt="DNS 地址"></p><p>此时电脑，有自己的 IP 地址、MAC 地址、还知道路由器的 IP 地址、DNS 服务器地址（由路由器负责域名解析，所以 DNS 地址其实就是 IP 地址）和当前的子网掩码。还可以看出，路由器动态分配 IP 地址是由 <a href="https://zh.wikipedia.org/wiki/动态主机设置协议" target="_blank" rel="noopener">DHCP</a> 实现的。</p><p>通过打开百度首页，结合抓包工具 Wireshark 来看看网络通信过程中的数据包的内容。</p><p>关于如何使用 Wireshark，请看 <a href="https://juejin.im/post/5c87059ae51d452f3f64b110" target="_blank" rel="noopener">使用 wireshark 学习网络协议</a>。通过 <code>ping www.baidu.com</code> 得到百度的 IP 地址为 <code>61.135.169.121</code>，在 Wireshark 中配置过滤条件后，通过使用命令 <code>curl www.baidu.com</code> 来模拟打开百度首页：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-124128.jpg" alt=""></p><p>此时在 Wireshark 中可以看出，TCP 协议发送了以太帧，以太帧的格式是：Ethernet II 标头 + IP 4 标头 + TCP 标头 + TCP 数据，TCP 标头显示源端口为 53732，目的地端口为 80；IP 标头显示源 IP 地址为 <code>192.168.31.206</code>，目的地 IP 地址为 <code>61.135.169.121</code>；以太网标头显示源 MAC 地址为 <code>f0:18:98:46:bf:65</code>，目的地 MAC 地址为 <code>28:6c:07:9d:e2:8e</code>（小米路由器地址）。帧的长度为 78 字节，TCP 数据包的长度为 44 个字节。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-124202.jpg" alt=""></p><p>这与我们前面说的相符合，目的主机不在同一个局域网，通过以太网发送以太帧给路由器，再由路由器负责路由发送。</p><p>前三个数据包为 TCP 的 3 次握手，接着发送了 HTTP 数据包，HTTP 数据包包含了请求的内容：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-124319.jpg" alt="">整个过程：先使用 TCP 协议完成了 3 次握手，然后使用 HTTP 协议发送了 GET 请求，接收到了百度的 HTTP 响应，最后使用 TCP 协议完成了 4 次挥手。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-124357.jpg" alt=""></p><h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>互联网协议整个网络通信过程可以用下面这张图描述：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-083129.png" alt="图片来自 Wiki"></p><p>对于发送方的数据处理，<strong>这个过程像是一个俄罗斯套娃的过程</strong>：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-17-150358.png" alt="图片来自 Wiki"></p><p>如果用发快递来类比一下：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">应用层：将物体打包为快递  </span><br><span class="line">      <span class="string">|</span></span><br><span class="line">传输层：为快递填上收件人门牌号；如果快递丢失重新发送</span><br><span class="line">      <span class="string">|</span></span><br><span class="line">网络层：为快递填上收件人小区地址；并根据收件人小区地址，找到下一个快递中转站的地址，最终找到整个线路</span><br><span class="line">      <span class="string">|</span></span><br><span class="line">链路层：为快递填上下一个中转地地址；并负责将快递发往到下一个中转站</span><br><span class="line">      <span class="string">|</span></span><br><span class="line">物理层：运快递的车</span><br></pre></td></tr></table></figure><p>在互联网协议中，因为 TCP/IP 协议最重要，所以互联网协议也可以叫做 「<strong>TCP/IP 协议族</strong>」。</p><p>此文只是个人对互联网协议的浅显理解，毕竟没有深入研究，可能有诸多不当处，欢迎留言指出。</p><p>最后我想说一句，阮一峰牛逼。有的知识点是知道怎么回事，就是不能正确的表达出来，遣词排句真的很需要功力，真的需要常年累月的积累。</p><!--解疑现在来说说，为什么说 SpringCloud 基于 HTTP 协议，Dubbo 基于 TCP 协议。我是这么理解的，因为 SpringClout 框架直接接受 HTTP 请求，而 Dubbo 让数据没有使用 HTTP 协议包装数据包。直接将数据包装为 TCP 数据包。--><h2 id="九、延伸阅读"><a href="#九、延伸阅读" class="headerlink" title="九、延伸阅读"></a>九、延伸阅读</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="noopener">互联网协议入门（一）<em>阮一峰</em></a></li><li><a href="http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html" target="_blank" rel="noopener">互联网协议入门（二）<em>阮一峰</em></a></li><li><a href="https://juejin.im/post/5c87059ae51d452f3f64b110" target="_blank" rel="noopener">使用wireshark学习网络协议</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者：&lt;a href=&quot;https://depp.wang&quot;&gt;DeppWang&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;互联网上的数据能从一台设备发送到另一台设备，整个过程由&lt;a href=&quot;https://zh.wikipedia.org/wiki/TCP/IP协议族&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;互联网协议&lt;/a&gt;（ Internet Protocol Suite）实现的。 &lt;/p&gt;
&lt;p&gt;对于互联网协议，一直一知半解。知道会分为几层，但为什么分层，分层有什么好处，都不甚理解。通过&lt;a href=&quot;www.ruanyifeng.com&quot;&gt;阮一峰&lt;/a&gt;的这两篇文章，大概有了一个初步认识，下面是我对互联网协议的理解。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;互联网协议入门（一）&lt;em&gt;阮一峰&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;互联网协议入门（二）&lt;em&gt;阮一峰&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="网络" scheme="https://depp.wang/categories/Network/"/>
    
    
      <category term="互联网协议" scheme="https://depp.wang/tags/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + NexT 博客优化（修改）记录</title>
    <link href="https://depp.wang/2020/03/12/hexo-next-all-change/"/>
    <id>https://depp.wang/2020/03/12/hexo-next-all-change/</id>
    <published>2020-03-12T20:48:37.000Z</published>
    <updated>2020-06-11T13:09:39.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、样式修改"><a href="#一、样式修改" class="headerlink" title="一、样式修改"></a>一、样式修改</h2><p>注意：重新部署后，样式若没更新，清除浏览器缓存</p><h3 id="分类横向展示"><a href="#分类横向展示" class="headerlink" title="分类横向展示"></a>分类横向展示</h3><p><code>themes\next\source\css\_common\component\pages\categories.styl</code> 中修改：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.category-list-item</span> &#123; </span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">5px</span> <span class="number">10px</span>; </span><br><span class="line">  display: inline-block; // 新增</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>display: inline-block</code>：可以不换行，让其他元素元素显示在旁边；并且可以设置高度，<a href="https://www.w3schools.com/css/css_inline-block.asp" target="_blank" rel="noopener">w3schools: CSS Layout - display: inline-block</a></li></ul><a id="more"></a><h3 id="设置图片居中"><a href="#设置图片居中" class="headerlink" title="设置图片居中"></a>设置图片居中</h3><p>Mist 主题： <code>themes\next\source\css\_schemes\Mist\_posts-expanded.styl</code> 中修改</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.post-body img &#123; margin: auto; &#125; // 0 - &gt; auto</span><br></pre></td></tr></table></figure><ul><li>_schemes：方案</li></ul><h3 id="设置字体大小"><a href="#设置字体大小" class="headerlink" title="设置字体大小"></a>设置字体大小</h3><p><code>themes\next\source\css\_variables\base.styl</code> 中修改：</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$font</span>-size-base           = <span class="number">16px</span> <span class="comment">// 14px -&gt; 16px</span></span><br></pre></td></tr></table></figure><ul><li><code>_variables\base</code>：存放公共基础变量</li></ul><h3 id="显示宽度设置"><a href="#显示宽度设置" class="headerlink" title="显示宽度设置"></a>显示宽度设置</h3><p><code>themes\next\source\css\_variables\base.styl</code> 中修改：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">$content</span>-desktop                = 800px</span></span><br></pre></td></tr></table></figure><h3 id="更改-h1-h2-字体大小，并设置下划线"><a href="#更改-h1-h2-字体大小，并设置下划线" class="headerlink" title="更改 h1 h2 字体大小，并设置下划线"></a>更改 h1 h2 字体大小，并设置下划线</h3><p>更改 h1 h2 字体大小： <code>themes\next\source\css\_custom\custom.styl</code> 中修改</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Custom styles.</span><br><span class="line">// 新增</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  font-size: 2em; // 2em = 32px</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">  font-size: 1.5em; // 1.5em = 24px, 1em = 16px</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>_custom\custom.styl</code> 为全局自定义样式</li></ul><p>设置下划线： <code>themes\next\source\css\_common\component\post\post-expand.styl</code> 中修改</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.posts-expand</span> <span class="selector-class">.post-body</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  // 新增</span><br><span class="line">  <span class="selector-tag">h1</span>, <span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: .<span class="number">3em</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#eaecef</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>也可以在  <code>themes\next\source\css\_schemes\Mist\_posts-expanded.styl</code> 修改？</li><li>只为文章内容中的 h1 h2 标题添加下划线</li></ul><h3 id="URL-中文改为英文"><a href="#URL-中文改为英文" class="headerlink" title="URL 中文改为英文"></a>URL 中文改为英文</h3><p>文章标题块添加 english-tile，站点配置文件修改 permalink</p><p>站点配置文件设置 tag_map、category_map</p><h2 id="二、功能添加"><a href="#二、功能添加" class="headerlink" title="二、功能添加"></a>二、功能添加</h2><ul><li>底部添加版权声明、微信公众号图片、分享按钮</li></ul><h3 id="添加-Disqus-评论"><a href="#添加-Disqus-评论" class="headerlink" title="添加 Disqus 评论"></a>添加 Disqus 评论</h3><p>教程：<a href="https://depp.wang/2017/06/15/hexo-disqus">Hexo 添加 Disqus 评论</a></p><p>缺点：只能科学上网后才能评论</p><hr><h5 id="也可以使用-Gitalk"><a href="#也可以使用-Gitalk" class="headerlink" title="也可以使用 Gitalk"></a>也可以使用 <a href="https://github.com/gitalk/gitalk" target="_blank" rel="noopener">Gitalk</a></h5><p>教程：</p><ul><li><a href="https://asdfv1929.github.io/2018/01/20/gitalk/" target="_blank" rel="noopener">使用 gitalk 评论插件</a></li><li><a href="https://liujunzhou.top/2018/8/10/gitalk-error/" target="_blank" rel="noopener">gitalk-error</a></li><li><a href="https://priesttomb.github.io/%E6%97%A5%E5%B8%B8/2018/02/12/%E5%A4%84%E7%90%86Gitalk%E4%B8%AD%E7%94%B1%E4%BA%8E%E6%96%87%E7%AB%A0URL%E8%BF%87%E9%95%BF%E5%AF%BC%E8%87%B4%E7%9A%84Validation-Failed(422)/" target="_blank" rel="noopener">处理Gitalk中由于文章URL过长导致的Validation Failed(422)</a></li></ul><p>缺点：发布文章后需要页面点击初始化</p><h3 id="添加-Algolia-搜索"><a href="#添加-Algolia-搜索" class="headerlink" title="添加 Algolia 搜索"></a>添加 Algolia 搜索</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export HEXO_ALGOLIA_INDEXING_KEY=*** // 使用 export 临时设置一个环境变量</span><br><span class="line">echo $HEXO_ALGOLIA_INDEXING_KEY  // 查看环境变量是否设置成功</span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li><a href="https://www.npmjs.com/package/hexo-algolia" target="_blank" rel="noopener">hexo-algolia</a> 和  <a href="https://www.npmjs.com/package/hexo-algoliasearch" target="_blank" rel="noopener">hexo-algoliasearch</a> 不要同时使用</li><li>使用 hexo-algolia 时，如果你删除了文章，需要更新 Algolia 里面的链接，需要使用 <code>hexo algolia --flush true</code> 命令</li></ol><p>hexo-algolia 模块的作用：将博客文章链接发送给自己的 Algolia 账户。搜索原理：输入关键字，调用 Algolia 提供接口，返回相应文章链接</p><p>可参考教程：</p><ul><li><a href="https://juejin.im/post/5af3f9d1518825673e35a6eb" target="_blank" rel="noopener">Hexo + Next 集成 Algolia 搜索</a></li><li><a href="http://theme-next.iissnan.com/third-party-services.html#algolia-search" target="_blank" rel="noopener">Next Algolia</a> </li></ul><p>缺点：</p><ol><li>新增文章后需要运行 <code>hexo algolia</code> 将当前文章发送到 Algolia</li><li>删除文章后还能搜索到，需要再次去 Algolia 删除？可使用  <code>hexo algolia --flush true</code> 命令更新</li></ol><p>可能遇到的问题：</p><ul><li>每次运行 <code>hexo algolia</code> 都需要设置环境变量，解决方式：直接「永久」设置环境变量</li></ul><p>macOS「永久」设置环境变量：</p><ul><li>默认为 bash，修改 .bash_profile</li><li>如果为 oh-my-zsh，修改 .zshrc</li><li>打印环境变量命令：printenv</li></ul><h3 id="添加文章阅读次数统计、网站访问次数统计"><a href="#添加文章阅读次数统计、网站访问次数统计" class="headerlink" title="添加文章阅读次数统计、网站访问次数统计"></a>添加文章阅读次数统计、网站访问次数统计</h3><p>可参考文章：<a href="https://depp.wang/2017/06/14/hexo-statistical/">Hexo 添加不蒜子和 LeanCloud 统计</a></p><h2 id="三、外部设置"><a href="#三、外部设置" class="headerlink" title="三、外部设置"></a>三、外部设置</h2><ul><li><a href="https://depp.wang/2020/02/17/use-github-actions-to-achieve-hexo-blog-auto-deploy/">使用 GitHub Actions 实现 Hexo 博客自动部署</a></li></ul><h3 id="自定义域名加密为-HTTPS"><a href="#自定义域名加密为-HTTPS" class="headerlink" title="自定义域名加密为 HTTPS"></a>自定义域名加密为 HTTPS</h3><p>直接利用 <a href="https://www.cloudflare.com/" target="_blank" rel="noopener">cloudfire</a> 加密网站</p><p>访问域名时，需要先由 DNS 服务来将域名解析为 ip 地址</p><p>DNS 服务器负责域名解析，需要先将域名的 DNS 服务器修改为  cloudfire 的服务器，由 cloudfiere 的 DNS 服务器负责域名解析，在 cloudfire 中设置规则，如：将 depp.wang 解析到 deppwang.gihub.io</p><p>在项目 GitHub Pages 中设置：访问 deppwang.gihub.io 重定向到 depp.wang，访问 depp.wang 时，cloudfiere 的 DNS 服务器又将 depp.wang 指向到 deppwang.github.io，最终访问的还是 deppwang.github.io。ping depp.wang  会发现是 github 节点，如果 ip 地址为  cloudfiere 节点，那是因为 cloudfiere 设置了代理。</p><ul><li>DNS：Domain Name System 域名系统</li></ul><p>可参考文章：<a href="https://crossoverjie.top/%2F2017%2F05%2F07%2Fhttps%2Fl" target="_blank" rel="noopener">科普-为自己的博客免费加上小绿锁</a></p><h3 id="提交到-Google-搜索引擎"><a href="#提交到-Google-搜索引擎" class="headerlink" title="提交到 Google 搜索引擎"></a>提交到 Google 搜索引擎</h3><p>一般不主动提交 url  给 Google 搜索引擎，Google 也可以凭借强大的爬虫（蜘蛛）抓取你网址的 url，但为了让谷歌更好更快的抓取你的文章，还是给他提供一个参考，一个站点地图（sitemap.xml）</p><p>先在 <a href="https://search.google.com/search-console" target="_blank" rel="noopener">Search Console</a> 验证你拥有网站的所有权，可以使用 HTML 文件、HTML 标记等方式验证。将 HTML 文件添加到网站中。每个用户拥有自己的 HTML 文件，如果网站有多个管理员，每个管理员的 HTML 文件不同。</p><p>如果使用 HTML 文件验证失败，HTML 文件添加 <code>layout: false</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">layout: false</span><br><span class="line">---</span><br><span class="line">google-site-verification: googlec27ee4754ff2e800.html</span><br></pre></td></tr></table></figure><p>使用 hexo-generator-sitemap 包生成站点地图，hexo-generator-sitemap 包的作用：</p><ul><li>每次 hexo g 时，根据_post 的文章生成站点地图：sitemap.xml，</li><li>如果能生成说明配置没有问题</li></ul><p>Google 定期抓取你设置的 sitemap</p><ul><li>站点地图抓取时间不更新解释：<a href="https://metinsaylan.com/9642/how-to-solve-search-console-sitemap-could-not-be-read-error/" target="_blank" rel="noopener">[How To] Solve Search Console “Sitemap could not be read” Error</a></li></ul><h2 id="四、其他可能遇到的问题"><a href="#四、其他可能遇到的问题" class="headerlink" title="四、其他可能遇到的问题"></a>四、其他可能遇到的问题</h2><ul><li>Google 不收录网址的问题</li><li>博客源文件每次被覆盖的问题</li></ul><h3 id="网址描述不显示问题"><a href="#网址描述不显示问题" class="headerlink" title="网址描述不显示问题"></a>网址描述不显示问题</h3><p>原因在于 NexT 开起了 SEO，SEO 覆盖掉了原来的代码</p><p>思路：找到不显示字样的 class，IDEA 打开文件，全局搜索 class，找到代码位置，进行修改</p><p>修改文件位置</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/next/</span>layout<span class="regexp">/_macro/</span>sidebar.swig</span><br></pre></td></tr></table></figure><p><code>theme.signature</code> 修改为 <code>config.description</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"site-description motion-element"</span> <span class="attr">itemprop</span>=<span class="string">"description"</span>&gt;</span>&#123;&#123; config.description &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>SEO: Search engine optimization 搜索引擎优化</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、样式修改&quot;&gt;&lt;a href=&quot;#一、样式修改&quot; class=&quot;headerlink&quot; title=&quot;一、样式修改&quot;&gt;&lt;/a&gt;一、样式修改&lt;/h2&gt;&lt;p&gt;注意：重新部署后，样式若没更新，清除浏览器缓存&lt;/p&gt;
&lt;h3 id=&quot;分类横向展示&quot;&gt;&lt;a href=&quot;#分类横向展示&quot; class=&quot;headerlink&quot; title=&quot;分类横向展示&quot;&gt;&lt;/a&gt;分类横向展示&lt;/h3&gt;&lt;p&gt;&lt;code&gt;themes\next\source\css\_common\component\pages\categories.styl&lt;/code&gt; 中修改：&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-class&quot;&gt;.category-list-item&lt;/span&gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;margin&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;5px&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;10px&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  display: inline-block; // 新增&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;display: inline-block&lt;/code&gt;：可以不换行，让其他元素元素显示在旁边；并且可以设置高度，&lt;a href=&quot;https://www.w3schools.com/css/css_inline-block.asp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;w3schools: CSS Layout - display: inline-block&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://depp.wang/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://depp.wang/tags/Hexo/"/>
    
      <category term="NexT" scheme="https://depp.wang/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>使用 GitHub Actions 实现 Hexo 博客自动部署</title>
    <link href="https://depp.wang/2020/02/17/use-github-actions-to-achieve-hexo-blog-auto-deploy/"/>
    <id>https://depp.wang/2020/02/17/use-github-actions-to-achieve-hexo-blog-auto-deploy/</id>
    <published>2020-02-17T13:26:55.000Z</published>
    <updated>2020-06-11T13:09:39.058Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-02-17-084920.png" alt="Image result for image Hexo"></p><h2 id="一、Hexo-相关知识点"><a href="#一、Hexo-相关知识点" class="headerlink" title="一、Hexo 相关知识点"></a>一、Hexo 相关知识点</h2><p>静态博客简单，但是发布博文时稍显麻烦，一般需要下面两步：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g -d // 相当于 hexo g + hexo d</span><br></pre></td></tr></table></figure><p>如果考虑到同步源文件，还需要每次更改后，将源文件 push 到指定仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><a id="more"></a><p>我们可以将 Hexo 文件分为两类，一类是源文件，即下面这些文件：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── <span class="variable">_config</span>.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── <span class="variable">_drafts</span></span><br><span class="line">|   └── <span class="variable">_posts</span></span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p>一类是 public 文件，即网站文件：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line">├── <span class="number">2020</span></span><br><span class="line">├── categories</span><br><span class="line">├── tags</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>发布博文的这三个操作代表：</p><ul><li>hexo clean：删除网站（public）文件</li><li>hexo g：生成网站（public）文件</li><li>hexo d：将本地网站（public）文件同步到指定仓库（如：yourname.github.io）中</li></ul><p>我使用一个私有仓库存放 Hexo 源文件，在 deppwang/deppwang.github.io 中存放网站文件。所以每次发布或者更新博文时，需要使用 push 操作更新源文件，再执行 <code>hexo clean</code>、<code>hexo g -d</code> 更新博客，比较麻烦。</p><p>所以我们希望能在 push 源文件后，由 <a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank" rel="noopener">CI/CD</a>（持续集成 / 持续部署）工具为我们执行  <code>hexo clean</code>、<code>hexo g -d</code> 这两个操作。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-02-15-105934.png" alt="Image result for github action"></p><h2 id="二、GitHub-Actions"><a href="#二、GitHub-Actions" class="headerlink" title="二、GitHub Actions"></a>二、GitHub Actions</h2><p>CI/CD 工具前有 Travis CI，现有 GitHub Actions，这里使用 GitHub Actions。</p><p>GitHub Actions 的工作原理：我们提前设置好需要自动化执行的任务，GitHub Actions 监控当前仓库的某一个操作（如：push），一旦有此操作，就自动化执行这些任务。</p><p>所以我们希望使用 GitHub Actions 后，只需要往源文件仓库 push 更新源文件，GitHub Actions 监控到 push 操作时，就自动化执行  <code>hexo clean</code>、<code>hexo g -d</code>  操作，完成博文发布。</p><p>Action 存放在项目根目录的 <code>.github/workflows</code> 下，后缀为 <code>.yml</code>。一个 Action 相当于一个工作流 workflow，一个工作流可以有多个任务 job，每个任务可以分为几步 step。任务、步骤依次执行。</p><p>每个 Action 是一个独立脚本，所以可以作为代码仓库。</p><ul><li><code>actions/setup-node</code> 就表示 <code>github.com/actions/setup-node</code> 这个 <a href="https://github.com/actions/setup-node" target="_blank" rel="noopener">仓库</a>，代表安装 node.js。Action 为 action.yml </li></ul><p>可以通过下面这种格式来使用别人写好的 action，@借用了指针的概念：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">actions/setup-<span class="keyword">node</span><span class="title">@74bc508</span> <span class="comment"># 指向一个 commit</span></span><br><span class="line">actions/setup-<span class="keyword">node</span><span class="title">@v1</span>.<span class="number">0</span>    <span class="comment"># 指向一个标签</span></span><br><span class="line">actions/setup-<span class="keyword">node</span><span class="title">@master</span>  <span class="comment"># 指向一个分支</span></span><br></pre></td></tr></table></figure><p>关于 GitHub Actions 更多知识，请看 <a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html" target="_blank" rel="noopener">GitHub Actions 入门教程 - 阮一峰</a>。</p><p>现在需要实现一个 Action，使其能够执行  <code>hexo clean</code>、<code>hexo g -d</code>  操作。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-02-17-115214.png" alt="Image result for hexo action"></p><h2 id="三、Hexo-Action"><a href="#三、Hexo-Action" class="headerlink" title="三、Hexo Action"></a>三、Hexo Action</h2><p>我是使用的 <a href="https://github.com/sma11black/" target="_blank" rel="noopener">sma11black</a> 已经开发好的 <a href="https://github.com/DeppWang/hexo-action" target="_blank" rel="noopener">Hexo Action</a>，这个 Action <strong>针对的是存放 Hexo 源文件和网站文件分开存放的场景</strong>。请先看 <a href="https://github.com/marketplace/actions/hexo-action" target="_blank" rel="noopener">教程</a>，以下为教程的补充。</p><p>非第一次生成 SSH Key：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -f ~/.ssh/id_rsa_x -C "yourmail@xxx.com"</span><br></pre></td></tr></table></figure><p>将生成的 <code>private key</code> 作为 Hexo 源文件仓库 <code>Settings &gt; Secrets</code> 的 一个名叫 <code>DEPLOY_KEY</code> 的 <code>Secret</code>。注意：需要复制包括 <code>-----BEGIN OPENSSH PRIVATE KEY-----</code> 和 <code>-----END OPENSSH PRIVATE KEY-----</code> 的整个内容。Secret 相当于一个变量，可以使私有变量不公开。</p><p>将生成的 <code>public key</code> 作为网站文件仓库 <code>Settings &gt; Deploy Keys</code> 的 Deploy Key。Deploy Keys 中的公钥针对于当前仓库。</p><p>为什么要用 SSH Key？</p><ul><li><p>SSH Key，是一对密匙：公钥 + 私钥，用于加密本地仓库和远程仓库的传输内容。</p><blockquote><p>在 RSA 加密算法中，公钥用于对数据进行加密，私钥用于对数据进行解密<br>在 RSA 签名算法中，私钥用于对数据进行签名，公钥用于对签名进行验证。</p></blockquote><blockquote><p>pull 的时候公钥用于对数据进行加密，私钥用于对数据进行解密，<br>push 的时候私钥用于对数据进行签名，公钥用于对签名进行验证。</p></blockquote></li><li><p>使用 GitHub Actions 是借助 GitHub 提供的环境，跟本地环境一样，也需要有私钥。当 GitHub Action 执行 <code>hexo g -d</code> 时，是一个 push 的过程，用私钥 DEPLOY_KEY 签名，GitHub 用网站文件仓库的公钥 Deploy Key 进行验证。</p></li></ul><p>下面是具体的 action.yml：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span> <span class="comment"># workflow name</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="string">[push]</span> <span class="comment"># 触发事件</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line"><span class="attr">  build:</span> <span class="comment"># job1 id</span></span><br><span class="line"><span class="attr">    runs-on:</span> <span class="string">ubuntu-latest</span> <span class="comment"># 运行环境为最新版 Ubuntu</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">A</span> <span class="string">job</span> <span class="string">to</span> <span class="string">deploy</span> <span class="string">blog.</span></span><br><span class="line"><span class="attr">    steps:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Checkout</span> <span class="comment"># step1 获取 hexo 源码</span></span><br><span class="line"><span class="attr">      uses:</span> <span class="string">actions/checkout@v1</span> <span class="comment"># 使用 actions/checkout@v1</span></span><br><span class="line"><span class="attr">      with:</span> <span class="comment"># 条件</span></span><br><span class="line"><span class="attr">        submodules:</span> <span class="literal">true</span> <span class="comment"># Checkout private submodules(themes or something else). 当有子模块时时，同步子模块</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Caching dependencies to speed up workflows. (GitHub will remove any cache entries that have not been accessed in over 7 days.) 根据 package-lock.json 压缩缓存 node_modules，不用每次下载，使用时解压，可以加快工作流的执行过程，超过 7 天没有使用将删除压缩包。</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Cache</span> <span class="string">node</span> <span class="string">modules</span> <span class="comment"># step2</span></span><br><span class="line"><span class="attr">      uses:</span> <span class="string">actions/cache@v1</span></span><br><span class="line"><span class="attr">      id:</span> <span class="string">cache</span></span><br><span class="line"><span class="attr">      with:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">node_modules</span></span><br><span class="line"><span class="attr">        key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.os</span> <span class="string">&#125;&#125;-node-$&#123;&#123;</span> <span class="string">hashFiles('**/package-lock.json')</span> <span class="string">&#125;&#125;</span> <span class="comment"># 使用 Hexo 项目的 package-lock.json 安装、缓存 node_moudules</span></span><br><span class="line"><span class="attr">        restore-keys:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          $<span class="template-variable">&#123;&#123; runner.os &#125;&#125;</span>-node-</span></span><br><span class="line"><span class="string">          </span></span><br><span class="line"><span class="string"></span><span class="attr">    - name:</span> <span class="string">Install</span> <span class="string">Dependencies</span> <span class="comment"># step3</span></span><br><span class="line"><span class="attr">      if:</span> <span class="string">steps.cache.outputs.cache-hit</span> <span class="string">!=</span> <span class="string">'true'</span> <span class="comment"># 如果没有缓存 node_modules</span></span><br><span class="line"><span class="attr">      run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="comment"># 根据 package.json 在 node_modules 下载相关包（依赖）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Deploy hexo blog website.</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Deploy</span> <span class="comment"># step4</span></span><br><span class="line"><span class="attr">      id:</span> <span class="string">deploy</span></span><br><span class="line"><span class="attr">      uses:</span> <span class="string">deppwang/hexo-action@v1.0.0</span></span><br><span class="line"><span class="attr">      with:</span></span><br><span class="line"><span class="attr">        deploy_key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEPLOY_KEY</span> <span class="string">&#125;&#125;</span> </span><br><span class="line"><span class="attr">        user_name:</span> <span class="string">your</span> <span class="string">github</span> <span class="string">username</span> <span class="comment"># 自定义</span></span><br><span class="line"><span class="attr">        user_email:</span> <span class="string">your</span> <span class="string">github</span> <span class="string">useremail</span> <span class="comment"># 自定义</span></span><br></pre></td></tr></table></figure><h2 id="四、运行过程"><a href="#四、运行过程" class="headerlink" title="四、运行过程"></a>四、运行过程</h2><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-02-24-135152.png" alt=""></p><h3 id="1、-Build-deppwang-hexo-action-master（新建-hexo-action-Docker-容器）"><a href="#1、-Build-deppwang-hexo-action-master（新建-hexo-action-Docker-容器）" class="headerlink" title="1、 Build deppwang/hexo-action@master（新建 hexo-action Docker 容器）"></a>1、 Build deppwang/hexo-action@master（新建 hexo-action Docker 容器）</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## action.yml</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">runs:</span></span><br><span class="line"><span class="attr">  using:</span> <span class="string">'docker'</span></span><br><span class="line"><span class="attr">  image:</span> <span class="string">'Dockerfile'</span></span><br><span class="line"><span class="attr">  args:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">$&#123;&#123;</span> <span class="string">inputs.user_name</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">$&#123;&#123;</span> <span class="string">inputs.user_email</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">$&#123;&#123;</span> <span class="string">inputs.deploy_key</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Dockerfile</span></span></span><br><span class="line">FROM node:13-alpine  # node:13-alpine 是一个 Dockerfile</span><br><span class="line"></span><br><span class="line">LABEL version="1.0.0"</span><br><span class="line">LABEL repository="https://github.com/sma11black/hexo-action"</span><br><span class="line">LABEL homepage="https://sma11black.github.io"</span><br><span class="line">LABEL maintainer="sma11black &lt;smallblack@outlook.com&gt;"</span><br><span class="line"></span><br><span class="line">RUN apk add --no-cache git # 安装 Git</span><br><span class="line">RUN apk add --no-cache openssh # 安装 openssh</span><br><span class="line"></span><br><span class="line">COPY entrypoint.sh /entrypoint.sh</span><br><span class="line">RUN chmod +x /entrypoint.sh</span><br><span class="line"></span><br><span class="line">ENTRYPOINT ["/entrypoint.sh"]</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Run Log</span></span></span><br><span class="line">Build container for action use: '/home/runner/work/_actions/sma11black/hexo-action/v1.0.0/Dockerfile'.</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Step 1/10 : FROM node:13-alpine</span><br><span class="line">...</span><br><span class="line">Status: Downloaded newer image for node:13-alpine</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="2、Check-Out（下载代码存放在容器中）"><a href="#2、Check-Out（下载代码存放在容器中）" class="headerlink" title="2、Check Out（下载代码存放在容器中）"></a>2、Check Out（下载代码存放在容器中）</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">Checkout</span> <span class="comment"># step1 获取 hexo 网站源码</span></span><br><span class="line"><span class="attr">  uses:</span> <span class="string">actions/checkout@v1</span> <span class="comment"># 使用 actions/checkout@v1</span></span><br><span class="line"><span class="attr">  with:</span> <span class="comment"># 条件</span></span><br><span class="line"><span class="attr">    submodules:</span> <span class="literal">true</span> <span class="comment"># Checkout private submodules(themes or something else). 当有子模块时切换分支？</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Run Log</span></span></span><br><span class="line">...</span><br><span class="line">git init "/home/runner/work/HexoBlog/HexoBlog"</span><br><span class="line">Initialized empty Git repository in /home/runner/work/HexoBlog/HexoBlog/.git/ # Hexo 项目位置</span><br><span class="line">....</span><br><span class="line">Resolving deltas: 100% (1226/1226), done.</span><br><span class="line">From https://github.com/DeppWang/HexoBlog</span><br><span class="line"> * [new branch]      master     -&gt; origin/master</span><br><span class="line">git checkout --progress --force da857124acdb52ed76426dccf6309c2944d8be86</span><br><span class="line">Note: switching to 'da857124acdb52ed76426dccf6309c2944d8be86'.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="3、Cache-node-modules（解压-node-modules-压缩包）"><a href="#3、Cache-node-modules（解压-node-modules-压缩包）" class="headerlink" title="3、Cache node modules（解压 node_modules 压缩包）"></a>3、Cache node modules（解压 node_modules 压缩包）</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Caching dependencies to speed up workflows. (GitHub will remove any cache entries that have not been accessed in over 7 days.) 根据 package-lock.json 压缩缓存 node_modules，不用每次下载，使用时解压，可以加快工作流的执行过程，超过 7 天没有使用将删除压缩包。</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Cache</span> <span class="string">node</span> <span class="string">modules</span> <span class="comment"># step2</span></span><br><span class="line"><span class="attr">      uses:</span> <span class="string">actions/cache@v1</span></span><br><span class="line"><span class="attr">      id:</span> <span class="string">cache</span></span><br><span class="line"><span class="attr">      with:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">node_modules</span></span><br><span class="line"><span class="attr">        key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.os</span> <span class="string">&#125;&#125;-node-$&#123;&#123;</span> <span class="string">hashFiles('**/package-lock.json')</span> <span class="string">&#125;&#125;</span> <span class="comment"># 使用 Hexo 项目的 package-lock.json 安装、缓存 node_moudules</span></span><br><span class="line"><span class="attr">        restore-keys:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          $<span class="template-variable">&#123;&#123; runner.os &#125;&#125;</span>-node-</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Run Log</span></span></span><br><span class="line">...</span><br><span class="line">Cache Size: ~9 MB (8961261 B)</span><br><span class="line">/bin/tar -xz -f /home/runner/work/_temp/e7af5c7e-5251-4125-8eea-dbd9f8574796/cache.tgz -C /home/runner/work/HexoBlog/HexoBlog/node_modules # 将 cache.tgz 解压为 node_modules。-C, --directory=DIR change to directory DIR</span><br><span class="line">Cache restored from key: Linux-node-85c3344f19ab8bd53e79be4d334a61c6c60f0730b275ad9bcbe1c9bc06076575</span><br></pre></td></tr></table></figure><h3 id="4、-Install-Dependencies（如有必要，更新-node-modules）"><a href="#4、-Install-Dependencies（如有必要，更新-node-modules）" class="headerlink" title="4、 Install Dependencies（如有必要，更新 node_modules）"></a>4、 Install Dependencies（如有必要，更新 node_modules）</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">Install</span> <span class="string">Dependencies</span> <span class="comment"># step3</span></span><br><span class="line"><span class="attr">  if:</span> <span class="string">steps.cache.outputs.cache-hit</span> <span class="string">!=</span> <span class="string">'true'</span> <span class="comment"># 如果没有缓存 node_modules</span></span><br><span class="line"><span class="attr">  run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="comment"># 根据 package.json 在 node_modules 下载相关包（依赖）</span></span><br></pre></td></tr></table></figure><h3 id="5、Deploy（生成、发布博文）"><a href="#5、Deploy（生成、发布博文）" class="headerlink" title="5、Deploy（生成、发布博文）"></a>5、Deploy（生成、发布博文）</h3><ul><li>hexo g 生成 public 网站静态文件</li><li>hexo d 将静态文件 push 到指定仓库（会强制覆盖原文件，如何不覆盖源文件呢？）</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">Deploy</span> <span class="comment"># step4</span></span><br><span class="line"><span class="attr">  id:</span> <span class="string">deploy</span></span><br><span class="line"><span class="attr">  uses:</span> <span class="string">sma11black/hexo-action@v1.0.0</span></span><br><span class="line"><span class="attr">  with:</span></span><br><span class="line"><span class="attr">    deploy_key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEPLOY_KEY</span> <span class="string">&#125;&#125;</span> </span><br><span class="line"><span class="attr">    user_name:</span> <span class="string">your</span> <span class="string">github</span> <span class="string">username</span> <span class="comment"># 自定义</span></span><br><span class="line"><span class="attr">    user_email:</span> <span class="string">your</span> <span class="string">github</span> <span class="string">useremail</span> <span class="comment"># 自定义</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">set -e</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> setup ssh-private-key</span></span><br><span class="line">mkdir -p /root/.ssh/</span><br><span class="line">echo "$INPUT_DEPLOY_KEY" &gt; /root/.ssh/id_rsa</span><br><span class="line">chmod 600 /root/.ssh/id_rsa</span><br><span class="line">ssh-keyscan -t rsa github.com &gt;&gt; /root/.ssh/known_hosts</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> setup deploy git account</span></span><br><span class="line">git config --global user.name "$INPUT_USER_NAME"</span><br><span class="line">git config --global user.email "$INPUT_USER_EMAIL"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> install hexo env</span></span><br><span class="line">npm install hexo-cli -g</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> deployment</span></span><br><span class="line">hexo g -d</span><br><span class="line"></span><br><span class="line">echo ::set-output name=notify::"Deploy complate."</span><br><span class="line">© 2020 GitHub, Inc.</span><br></pre></td></tr></table></figure><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-02-17-115552.jpg" alt="Image result for error"></p><h2 id="五、可能出现的问题：Deploy-失败"><a href="#五、可能出现的问题：Deploy-失败" class="headerlink" title="五、可能出现的问题：Deploy 失败"></a>五、可能出现的问题：Deploy 失败</h2><p>可能出现以下 3 三种情况：</p><p><strong>1、</strong></p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-02-15-140504.png" alt="image-20200215220503185"></p><p>重点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Host key verification failed</span><br><span class="line">fatal: Could not read from remote repository.</span><br></pre></td></tr></table></figure><p>原因：<code>站点配置文件</code> 配置项 deploy 存在出 GitHub 以外的仓库 — 如：Coding ，而 Hexo-Action 不能识别此仓库</p><p>解决方式：</p><ol><li>要么去除 GitHub 以外的仓库；</li><li>要么 *<em>entrypoint.sh *</em> 添加 <code>ssh-keyscan -t rsa e.coding.net &gt;&gt; /root/.ssh/known_hosts</code></li></ol><p><strong>2、</strong></p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-02-15-140636.png" alt="image-20200215220635619"></p><p>重点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Load key "/root/ssh/id_rsa": invalid format</span><br><span class="line">git@github.com: Permission denied (publickey)</span><br><span class="line">fatal: Could not read from remote repository.</span><br></pre></td></tr></table></figure><p>原因：SSH Key 的公钥和私钥没有正确复制，或者设置错误</p><p>解决方式：正确且完整的复制并设置</p><p><strong>3、</strong></p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-02-16-103927.png" alt="image-20200216183926423"></p><p>重点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR Local hexo not found in /github/workspace</span><br><span class="line">ERROR Try running: 'npm install hexo --save'</span><br></pre></td></tr></table></figure><p>原因：<code>hexo-deployer-git</code> 的版本过低，导致删除了 hexo 包。</p><p>解决方式：</p><ol><li>参考 <a href="https://github.com/sma11black/hexo-action/issues/1" target="_blank" rel="noopener">此 issue</a> 升级 <code>hexo-deployer-git</code></li><li>使用 <code>deppwang/hexo-aciton@v1.0.1</code> 重装，他重新安装了 hexo 包</li></ol><h2 id="六、解决-github-io-丢失-commit-记录"><a href="#六、解决-github-io-丢失-commit-记录" class="headerlink" title="六、解决 **.github.io 丢失 commit 记录"></a>六、解决 **.github.io 丢失 commit 记录</h2><p><code>hexo d</code> 其实分为 3 步：</p><ol><li>将 public 文件复制到 .deploy_git</li><li>commit</li><li>push 到远程仓库</li></ol><p>执行 hexo d 命令时，如果没有 .doploy_git 文件，它将新建一个 .deploy_git 文件，所以旧的 commit 记录将丢失。</p><p>可以在 entrypoint.sh 中添加一行命令来解决这个问题：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/username/username.github.io.git .deploy_git</span><br></pre></td></tr></table></figure><h2 id="七、参考"><a href="#七、参考" class="headerlink" title="七、参考"></a>七、参考</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html" target="_blank" rel="noopener">GitHub Actions 入门教程 - 阮一峰</a></li><li><a href="https://github.com/marketplace/actions/hexo-action" target="_blank" rel="noopener">Hexo Action</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-02-17-084920.png&quot; alt=&quot;Image result for image Hexo&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、Hexo-相关知识点&quot;&gt;&lt;a href=&quot;#一、Hexo-相关知识点&quot; class=&quot;headerlink&quot; title=&quot;一、Hexo 相关知识点&quot;&gt;&lt;/a&gt;一、Hexo 相关知识点&lt;/h2&gt;&lt;p&gt;静态博客简单，但是发布博文时稍显麻烦，一般需要下面两步：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo clean&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo g -d // 相当于 hexo g + hexo d&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;如果考虑到同步源文件，还需要每次更改后，将源文件 push 到指定仓库：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git push origin master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://depp.wang/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://depp.wang/tags/Hexo/"/>
    
      <category term="GitHub Actions" scheme="https://depp.wang/tags/GitHub-Actions/"/>
    
  </entry>
  
  <entry>
    <title>Java 的几种运算符</title>
    <link href="https://depp.wang/2020/01/11/java-operator/"/>
    <id>https://depp.wang/2020/01/11/java-operator/</id>
    <published>2020-01-11T17:58:35.000Z</published>
    <updated>2020-06-11T13:09:39.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、原码、反码、补码"><a href="#一、原码、反码、补码" class="headerlink" title="一、原码、反码、补码"></a>一、原码、反码、补码</h2><p>1 用二进制表示                    00000001</p><p>-1 如果只变符号位（原码）10000001</p><p>那么 1 + -1 =                         10000010   =   -2</p><p>-1 的反码                               11111110  除去符号位，整体翻转</p><p>-1 的补码（<strong>反码加 1</strong>）         11111111 补码  也等于  0 - 1 的原（补）码</p><p>1 的补码 + -1 的补码            10000000 = 0，溢出 1 位</p><a id="more"></a><p>int 为 4 个字节，32 位，1 位作为符号位，表示大小的有 31 位</p><p>为了方便运算，Java 整数二进制<strong>默认使用补码表示</strong>，<strong>正数和 0 的补码不变，负数的补码为反码加 1</strong></p><ul><li>0 :             00000000000000000000000000000000 <code>32个0</code></li><li>2^32-1     01111111111111111111111111111111 <code>0+31个1</code></li><li>-2^31 :     10000000000000000000000000000000 <code>1+31个0</code></li><li>-2^31+1 : 10000000000000000000000000000001 <code>1+30个0+1</code></li><li>-1 :            11111111111111111111111111111111 <code>32个1</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = Integer.toBinaryString(<span class="number">0x80000000</span>); <span class="comment">// 0x80000000: -2^31</span></span><br></pre></td></tr></table></figure><ul><li>1111 = 15 = <code>1*2^3 + 1*2^2 + 1*2^1 + 1*2^0</code>，0001 为 1，等于 2^0</li></ul><h2 id="二、移位运算符"><a href="#二、移位运算符" class="headerlink" title="二、移位运算符"></a>二、移位运算符</h2><h3 id="lt-lt-左移运算符"><a href="#lt-lt-左移运算符" class="headerlink" title="&lt;&lt;  : 左移运算符"></a><code>&lt;&lt;</code>  : 左移运算符</h3><p><code>num &lt;&lt; 1</code>，num 转换为二进制，长度固定，丢弃最左边指定位数，1 位，整体向左移动 1 位，后面补 0。</p><p>以 int 类型为例，4 个字节，32 位，表示 -2^31 ~ 2^31 - 1，<code>10000000000000000000000000000000</code> ~ <code>01111111111111111111111111111111</code>，最左位是符号位，当小于 2^31 - 1 时，最左边都是 0，所以 0 代表为正数，1 代表为负数。</p><p>当 num 为正数，且没有达到最大值时，即左边的 0 够多时，<code>num &lt;&lt; 1</code> 相当于二进制每一位转十进制时在原来基础上再乘以 2，相当于 num 乘以 2。达到最大值后，正数可能变负数。</p><h3 id="gt-gt-右移运算符"><a href="#gt-gt-右移运算符" class="headerlink" title="&gt;&gt; : 右移运算符"></a><code>&gt;&gt;</code> : 右移运算符</h3><p><code>num &gt;&gt; 1</code>，num 转换为二进制，丢弃最右边指定位数，1 位，整体向右移动 1 位，后面补符号位，如果 num 为正数，补 0，如果为负数，补 1。</p><p>当 num 为正数时，<code>num &gt;&gt; 1</code> 相当于 num 除以 2 取整（/）。</p><p>int 类型 4 字节，正数右移 31 位变为 0，右移 32  位相当于不移位，当大于 32 位时，先求余，再移位。long 类型 64 位取余。</p><h3 id="gt-gt-gt-无符号右移运算符"><a href="#gt-gt-gt-无符号右移运算符" class="headerlink" title="&gt;&gt;&gt; : 无符号右移运算符"></a><code>&gt;&gt;&gt;</code> : 无符号右移运算符</h3><p>丢弃最右边指定位数，整体右移指定位，忽略符号位，后面空位都以 0 补齐。</p><p>因为左边没有符号，所以没有无符号左移。或者说，左移运算符就是无符号左移。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> intValue = <span class="number">733183670</span>;</span><br><span class="line">    <span class="keyword">int</span> intValue2 = -<span class="number">733183670</span>;</span><br><span class="line">    System.out.println(intValue + <span class="string">" 左移 1 位："</span> + (intValue &lt;&lt; <span class="number">1</span>)); <span class="comment">// 1466367340</span></span><br><span class="line">    System.out.println(intValue2 + <span class="string">" 左移 1 位："</span> + (intValue2 &lt;&lt; <span class="number">1</span>)); <span class="comment">// -1466367340</span></span><br><span class="line">    System.out.println(intValue + <span class="string">" 右移 8 位："</span> + (intValue &gt;&gt; <span class="number">8</span>)); <span class="comment">// 2863998 (733183670/256)</span></span><br><span class="line">    System.out.println(intValue2 + <span class="string">" 右移 8 位："</span> + (intValue2 &gt;&gt; <span class="number">8</span>)); <span class="comment">// -2863999</span></span><br><span class="line">    <span class="comment">// 无符号右移，将数据变小，且最终为正数</span></span><br><span class="line">    System.out.println(intValue + <span class="string">" 无符号右移 8 位："</span> + (intValue &gt;&gt;&gt; <span class="number">8</span>)); <span class="comment">// 2863998</span></span><br><span class="line">    System.out.println(intValue2 + <span class="string">" 无符号右移 8 位："</span> + (intValue2 &gt;&gt;&gt; <span class="number">8</span>)); <span class="comment">// 13913217</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>733183670 &lt;&lt; 1，左移 1 位：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-02-16-131127.png" alt="图片来自知乎"></p><p>-733183670 &gt;&gt; 8，右移 8 位：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-05-04-145501.png" alt=""></p><p>-733183670 &gt;&gt;&gt; 8，无符号右移 8 位：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-05-04-145507.png" alt=""></p><h2 id="三、位运算符"><a href="#三、位运算符" class="headerlink" title="三、位运算符"></a>三、位运算符</h2><ul><li>先转换为二进制后再运算</li><li><code>&amp;</code> 按位与：<code>1&amp;1==1</code> / <code>1&amp;0==0</code> / <code>0&amp;0==0</code>，都为 1，则为 1，否则为 0</li><li><code>|</code> 按位或：<code>1|1==1</code> / <code>1|0==1</code> / <code>0|0==0</code>，有一个为 1，则为 1，否则 为 0</li><li><code>~</code> 按位非：<code>~1==0</code> / <code>~0==1</code>, 单位为 bit，整数类型的话：<code>~1==-2</code> –&gt;<code>~0b00000000000000000000000000000001==0b11111111111111111111111111111110</code></li><li><code>^</code>: 异或运算符  <code>1^1==0</code> / <code>1^0==1</code> / <code>0^0==0</code>，相同为 0，不同为 、1</li></ul><h2 id="四、逻辑运算符"><a href="#四、逻辑运算符" class="headerlink" title="四、逻辑运算符"></a>四、逻辑运算符</h2><ul><li><code>&amp;&amp;</code> 逻辑与：当左边表达式为 false 时，不再计算，直接为 false。规则跟 <code>&amp;</code> 一致</li><li><code>||</code> 逻辑或：当左边表达式为 true 时，不再计算，直接为 true。规则跟 <code>|</code> 一致</li></ul><h2 id="五、延伸阅读"><a href="#五、延伸阅读" class="headerlink" title="五、延伸阅读"></a>五、延伸阅读</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/30108890" target="_blank" rel="noopener">Java中的移位运算符</a></li><li><a href="https://www.jianshu.com/p/8cf5af30f245" target="_blank" rel="noopener">Java &amp;、&amp;&amp;、|、||、^、&lt;&lt;、&gt;&gt;、~、&gt;&gt;&gt;等运算符</a></li><li><a href="https://www.ruanyifeng.com/blog/2009/08/twos_complement.html" target="_blank" rel="noopener">关于 2 的补码</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、原码、反码、补码&quot;&gt;&lt;a href=&quot;#一、原码、反码、补码&quot; class=&quot;headerlink&quot; title=&quot;一、原码、反码、补码&quot;&gt;&lt;/a&gt;一、原码、反码、补码&lt;/h2&gt;&lt;p&gt;1 用二进制表示                    00000001&lt;/p&gt;
&lt;p&gt;-1 如果只变符号位（原码）10000001&lt;/p&gt;
&lt;p&gt;那么 1 + -1 =                         10000010   =   -2&lt;/p&gt;
&lt;p&gt;-1 的反码                               11111110  除去符号位，整体翻转&lt;/p&gt;
&lt;p&gt;-1 的补码（&lt;strong&gt;反码加 1&lt;/strong&gt;）         11111111 补码  也等于  0 - 1 的原（补）码&lt;/p&gt;
&lt;p&gt;1 的补码 + -1 的补码            10000000 = 0，溢出 1 位&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://depp.wang/categories/Java/"/>
    
    
      <category term="运算符 Operator" scheme="https://depp.wang/tags/%E8%BF%90%E7%AE%97%E7%AC%A6-Operator/"/>
    
  </entry>
  
  <entry>
    <title>2019 年买过哪些值得推荐的物品？</title>
    <link href="https://depp.wang/2020/01/03/which-recommended-items-bought-in-2019/"/>
    <id>https://depp.wang/2020/01/03/which-recommended-items-bought-in-2019/</id>
    <published>2020-01-03T14:25:08.000Z</published>
    <updated>2020-06-11T13:09:39.062Z</updated>
    
    <content type="html"><![CDATA[<p>阅读提醒，这篇文章不是技术干货。</p><p>因为前些天京东买了个免打孔单杠，用起来感觉很不错，足不出户（你知道北京室外冬天有多冷<code>^_^</code>）就能来几个引体向上，生活（身体）多了些活力。想着正好 2020 年了，你说做个总结吧，2019 年又没什么成绩，东西倒买了不少，除了单杠好像还有几个值得推荐的东西，那一块推荐一下吧，遂成了这篇软文。</p><p>我发现我买东西很怕挑选，感觉很费时间，希望能快速下单，往往最后直接买了销量最好的那个，不知道有没有小伙伴跟我一样。喜欢刷小红书的女生，大多数也是希望看看别人有什么推荐吧。</p><p><strong>温馨提醒</strong>：在京东、淘宝购买电子产品或者价格较高的商品，可以通过 <a href="http://asd-price.com/" target="_blank" rel="noopener">http://asd-price.com/</a> 查看一下商品的历史价格。</p><a id="more"></a><p>再次申明一下哈，下面不是打广告，不是打广告，关注不多，没人找我打广告 。。。</p><h2 id="个人提升"><a href="#个人提升" class="headerlink" title="个人提升"></a>个人提升</h2><h3 id="李宁室内免打孔单杠"><a href="#李宁室内免打孔单杠" class="headerlink" title="李宁室内免打孔单杠"></a>李宁室内免打孔单杠</h3><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-01-03-024348.jpg" alt=""></p><p>单杠优点是免打孔，对墙面基本没有伤害（可以垫两张纸），没有发生过脱落，挺安全。</p><ul><li><a href="https://item.jd.com/100005078689.html" target="_blank" rel="noopener">京东链接</a>，入手价：194</li></ul><h3 id="Kindle-paperwhite-4-代-8-G"><a href="#Kindle-paperwhite-4-代-8-G" class="headerlink" title="Kindle paperwhite 4 代 8 G"></a>Kindle paperwhite 4 代 8 G</h3><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-01-02-132230.jpg" alt=""></p><p>买它主要是想睡前看书，虽然手机也能看，但没这个专注，熄灯后用黑暗模式挺好。平时零碎时间也可以用，如果兜够大的话，直接揣兜更好。可以配合一个翻盖皮套，避免刮花。</p><p>可以在 <a href="https://www.jiumodiary.com/" target="_blank" rel="noopener">鸠摩搜书</a> 搜索免费书籍，推荐 <a href="https://pan.baidu.com/s/12fBAZ" target="_blank" rel="noopener">人类简史</a>。</p><p>京东平时：998，双十一和 619 一般 898，我是转转在买了二手全新，820。</p><ul><li><a href="https://item.jd.com/100000667370.html" target="_blank" rel="noopener">京东链接</a>，转转价：820</li></ul><h3 id="Suavecito-骷髅发油"><a href="#Suavecito-骷髅发油" class="headerlink" title="Suavecito 骷髅发油"></a>Suavecito 骷髅发油</h3><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-01-02-131003.jpg" alt="img" style="zoom:50%;"><p>虽然人长得一般，但发型不能乱。淘宝这款发油，使用一段时间了，应该是正品。主要用于油头，但每次弄少点，定型也挺好，主要优点是好洗。</p><ul><li><a href="https://item.taobao.com/item.htm?spm=a1z09.2.0.0.10982e8dWUoV2y&id=41149726970&_u=2rh8cg8348b" target="_blank" rel="noopener">淘宝链接</a>，入手价：103</li></ul><h2 id="食物"><a href="#食物" class="headerlink" title="食物"></a>食物</h2><h3 id="统一开小灶自热土豆牛腩饭"><a href="#统一开小灶自热土豆牛腩饭" class="headerlink" title="统一开小灶自热土豆牛腩饭"></a>统一开小灶自热土豆牛腩饭</h3><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-01-02-141438.jpg" alt=""></p><p>马上又要一年一度的大迁移了，这款是火车食物链的顶级存在，统一方便面不好吃，这个倒挺好吃</p><ul><li><a href="https://item.jd.com/100001449314.html" target="_blank" rel="noopener">京东链接</a>：入手价：43.5（2 盒）</li></ul><h3 id="拉面说重庆麻辣肉酱小面"><a href="#拉面说重庆麻辣肉酱小面" class="headerlink" title="拉面说重庆麻辣肉酱小面"></a>拉面说重庆麻辣肉酱小面</h3><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-01-02-141055.jpg" alt=""></p><p>这个还是我看 <a href="https://www.bilibili.com/video/av80809511" target="_blank" rel="noopener">司徒视频</a> 发现的，买回来尝了一下，非常辣，按 13 均价来评价的话，还行。</p><ul><li><a href="https://item.jd.com/62789652518.html" target="_blank" rel="noopener">京东链接</a>：入手价：39.9（3 盒）</li></ul><h2 id="纸质书"><a href="#纸质书" class="headerlink" title="纸质书"></a>纸质书</h2><p>好书还是需要纸质书反复翻阅，买书最好等着有活动再买。</p><h3 id="深入理解-Java-虚拟机"><a href="#深入理解-Java-虚拟机" class="headerlink" title="深入理解 Java 虚拟机"></a>深入理解 Java 虚拟机</h3><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-01-02-144526.jpg" alt=""></p><p>面试喜欢问的类加载、垃圾回收、调优，里面都有，最后两章，并发也讲得很好。</p><ul><li><a href="https://item.jd.com/11252778.html" target="_blank" rel="noopener">京东链接</a></li></ul><h3 id="高性能-MySQL"><a href="#高性能-MySQL" class="headerlink" title="高性能 MySQL"></a>高性能 MySQL</h3><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-01-02-144433.jpg" alt=""></p><p>如果你需要面试，看看这本书，索引、锁、MVVC、复制等等统统给你整明白。</p><ul><li><a href="https://item.jd.com/11220393.html" target="_blank" rel="noopener">京东链接</a></li></ul><p>其他如：Redis 开发与运维、Redis 设计与实现、Head First 设计模式、图解 HTTP、算法图解、码农翻身等也值得购买</p><h2 id="服装"><a href="#服装" class="headerlink" title="服装"></a>服装</h2><h3 id="90-分书包"><a href="#90-分书包" class="headerlink" title="90 分书包"></a>90 分书包</h3><p>作为程序员，这个书包给我的感觉就是，不像程序员背的！书包质感不错。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-22-143432.jpg" alt=""></p><ul><li><a href="https://www.xiaomiyoupin.com/detail?gid=890&spmref=YouPinPC.$SearchFilter$1.search_list.2.33739537" target="_blank" rel="noopener">有品链接</a>，入手价：179</li></ul><h3 id="安踏骚粉篮球鞋"><a href="#安踏骚粉篮球鞋" class="headerlink" title="安踏骚粉篮球鞋"></a>安踏骚粉篮球鞋</h3><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-22-143836.png" alt="image-20200322223710409"></p><p>如果你也喜欢这个颜色，说明我们是同道中人 😝。这款官方已经没卖了，链接失效，喜欢的可以淘宝淘一下</p><h3 id="一款好看的男士秋裤"><a href="#一款好看的男士秋裤" class="headerlink" title="一款好看的男士秋裤"></a>一款好看的男士秋裤</h3><ul><li><a href="https://detail.tmall.com/item.htm?spm=a1z10.3-b.w4011-2653083061.49.717b43c1SFHQoX&id=601881979477&rn=16b9b6a334caabe20e7c7b7668e52d29&abbucket=11" target="_blank" rel="noopener">天猫链接</a></li></ul><h2 id="居家"><a href="#居家" class="headerlink" title="居家"></a>居家</h2><h3 id="免打孔挂钩"><a href="#免打孔挂钩" class="headerlink" title="免打孔挂钩"></a>免打孔挂钩</h3><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-22-143827.png" alt="image-20200322223805701"></p><p>这挂钩太能挂了！粘性相当好，从来没掉过。节省空间，很方便，不用每次放衣柜</p><ul><li><a href="https://detail.tmall.com/item.htm?id=38645058899&spm=a1z09.2.0.0.10982e8dWUoV2y&_u=2rh8cg836ee" target="_blank" rel="noopener">天猫链接</a></li></ul><h3 id="网易严选四件套"><a href="#网易严选四件套" class="headerlink" title="网易严选四件套"></a>网易严选四件套</h3><h4 id="全棉条纹四件套"><a href="#全棉条纹四件套" class="headerlink" title="全棉条纹四件套"></a>全棉条纹四件套</h4><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-01-03-020603.png" alt="image-20200103100603090" style="zoom:50%;"><ul><li><a href="https://you.163.com/item/detail?id=1110003&_stat_area=15&_stat_referer=search&_stat_query=床单&_stat_count=20&_stat_searchversion=76" target="_blank" rel="noopener">购买链接</a>，入手价：差不多 250</li></ul><h4 id="全棉格子四件套"><a href="#全棉格子四件套" class="headerlink" title="全棉格子四件套"></a>全棉格子四件套</h4><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-01-03-042308.png" alt="image-20200103100732682" style="zoom:50%;"><ul><li><a href="https://you.163.com/item/detail?id=3822058&_stat_area=similar_8&_stat_referer=search&_stat_query=床单&_stat_count=12&_stat_searchversion=0.7" target="_blank" rel="noopener">购买链接</a>，入手价：255</li></ul><p>这两款四件套，是真全棉，非常厚实。很耐看</p><h3 id="隐私半透明玻璃膜"><a href="#隐私半透明玻璃膜" class="headerlink" title="隐私半透明玻璃膜"></a>隐私半透明玻璃膜</h3><ul><li><a href="https://detail.tmall.com/item.htm?id=41141158167&spm=a1z09.2.0.0.10982e8dyyl2ZV&_u=2rh8cg8945f" target="_blank" rel="noopener">天猫链接</a></li></ul><h3 id="3M-双面胶"><a href="#3M-双面胶" class="headerlink" title="3M 双面胶"></a>3M 双面胶</h3><ul><li><a href="https://detail.tmall.com/item.htm?id=40266373990&spm=a1z09.2.0.0.10982e8dyyl2ZV&_u=2rh8cg8de97" target="_blank" rel="noopener">天猫链接</a></li></ul><h2 id="电子设备相关"><a href="#电子设备相关" class="headerlink" title="电子设备相关"></a>电子设备相关</h2><h3 id="紫米苹果-18w-快充"><a href="#紫米苹果-18w-快充" class="headerlink" title="紫米苹果 18w 快充"></a>紫米苹果 18w 快充</h3><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-01-02-134510.jpg" alt=""></p><p>你肯定知道这两个小物件在苹果官网的原价</p><ul><li><a href="https://detail.tmall.com/item.htm?id=593066459068&spm=a1z09.2.0.0.10982e8dWUoV2y&_u=2rh8cg829c0&skuId=4416301435729" target="_blank" rel="noopener">天猫链接</a></li></ul><h3 id="数据线整理卡扣"><a href="#数据线整理卡扣" class="headerlink" title="数据线整理卡扣"></a>数据线整理卡扣</h3><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-01-02-134808.jpg" alt=""></p><p>「按住」无处安放的数据线</p><ul><li><a href="https://detail.tmall.com/item.htm?id=543704096025&spm=a1z09.2.0.0.10982e8dyyl2ZV&_u=2rh8cg8f391" target="_blank" rel="noopener">天猫链接</a></li></ul><h3 id="闪魔手机膜"><a href="#闪魔手机膜" class="headerlink" title="闪魔手机膜"></a>闪魔手机膜</h3><h4 id="闪魔-XR-全屏膜"><a href="#闪魔-XR-全屏膜" class="headerlink" title="闪魔 XR 全屏膜"></a>闪魔 XR 全屏膜</h4><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-22-143947.png" alt="image-20200322223946575"></p><p>两个优点：顶部就一个开孔，全屏覆盖。送的贴膜器很好用，基本上不会失败，人人都是贴膜师</p><ul><li><a href="https://detail.tmall.com/item.htm?id=560856092783&spm=a1z09.2.0.0.10982e8dWUoV2y&_u=2rh8cg8507f" target="_blank" rel="noopener">天猫链接</a></li></ul><h4 id="闪魔-OPPO-FindX-软膜"><a href="#闪魔-OPPO-FindX-软膜" class="headerlink" title="闪魔 OPPO FindX 软膜"></a>闪魔 OPPO FindX 软膜</h4><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-01-02-133839.jpg" alt=""></p><p>几乎跟出厂原装膜一模一样。题外话：感觉闪魔的膜都挺不错</p><ul><li><a href="https://detail.tmall.com/item.htm?id=575678608921&spm=a1z09.2.0.0.10982e8dWUoV2y&_u=2rh8cg83f32" target="_blank" rel="noopener">天猫链接</a></li></ul><h3 id="macOS-Pro-键盘膜"><a href="#macOS-Pro-键盘膜" class="headerlink" title="macOS Pro 键盘膜"></a>macOS Pro 键盘膜</h3><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-01-02-134203.jpg" alt=""></p><p>个人十分受不了直接触摸光滑键盘的感觉，这个膜有效缓解这一症状。用久了还发现一个优点，没有膜的常用按键会掉漆！</p><ul><li><a href="https://detail.tmall.com/item.htm?id=565302355120&spm=a1z09.2.0.0.10982e8dWUoV2y&_u=2rh8cg80655" target="_blank" rel="noopener">天猫链接</a></li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>就购买服饰鞋包来说，我发现大多数人其实不是怕花钱，而是买不到自己喜欢的。不管刷小红书，还是看淘宝直播视频，我觉得有两个目的：一是看有哪些好看的，怎么搭好看；二是想知道在哪里能买到。而小红书负责带货，淘宝负责卖。</p><!--我们能欣赏出服饰鞋包好看不好看，但设计确实比较困难，就像拍电影和评论电影一样。大众化的产品太多，也很平庸，需要不断的挖掘（逛街、手机），好的产品相对价格又较高，--><p>如果某个品牌能持续推出好设计、又有点性价比的产品，应该不愁卖吧。</p><!--公众号关注人数不多，现在几乎所有都是因为我原来分享的「10 分钟教会你科 ke 学 xue 上 shang 网 wang」关注的，这篇文章因人投诉，被微信删了，如果还想了解的小伙伴，请看 [这里](https://github.com/DeppWang/Science-Online)--><p>最近一直面试，后续会将这段时间面试的相关技术知识分享出来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阅读提醒，这篇文章不是技术干货。&lt;/p&gt;
&lt;p&gt;因为前些天京东买了个免打孔单杠，用起来感觉很不错，足不出户（你知道北京室外冬天有多冷&lt;code&gt;^_^&lt;/code&gt;）就能来几个引体向上，生活（身体）多了些活力。想着正好 2020 年了，你说做个总结吧，2019 年又没什么成绩，东西倒买了不少，除了单杠好像还有几个值得推荐的东西，那一块推荐一下吧，遂成了这篇软文。&lt;/p&gt;
&lt;p&gt;我发现我买东西很怕挑选，感觉很费时间，希望能快速下单，往往最后直接买了销量最好的那个，不知道有没有小伙伴跟我一样。喜欢刷小红书的女生，大多数也是希望看看别人有什么推荐吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;温馨提醒&lt;/strong&gt;：在京东、淘宝购买电子产品或者价格较高的商品，可以通过 &lt;a href=&quot;http://asd-price.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://asd-price.com/&lt;/a&gt; 查看一下商品的历史价格。&lt;/p&gt;
    
    </summary>
    
      <category term="Live" scheme="https://depp.wang/categories/Live/"/>
    
    
      <category term="推荐物品" scheme="https://depp.wang/tags/%E6%8E%A8%E8%8D%90%E7%89%A9%E5%93%81/"/>
    
  </entry>
  
  <entry>
    <title>&lt;译&gt; Alfred 官网 的 Workflows 帮助</title>
    <link href="https://depp.wang/2019/11/10/translate-alfred-workflows-help/"/>
    <id>https://depp.wang/2019/11/10/translate-alfred-workflows-help/</id>
    <published>2019-11-10T14:25:08.000Z</published>
    <updated>2020-06-11T13:09:39.062Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>翻译 Alfred 官网 的 <a href="https://www.alfredapp.com/help/workflows/" target="_blank" rel="noopener">Workflows 帮助</a></p></blockquote><p>使用工作流（workflows）扩展 Alfred 并以自己的方式完成工作，通过工作流替代重复性操作或基于鼠标的操作，你将提高你的工作效率。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135613.jpg" alt="To-Do List Example Workflow"></p><a id="more"></a><h2 id="概览：什么是工作流？"><a href="#概览：什么是工作流？" class="headerlink" title="概览：什么是工作流？"></a>概览：什么是工作流？</h2><p><em>工作流是 Alfred 可用的 <a href="https://www.alfredapp.com/powerpack/" target="_blank" rel="noopener">Powerpack</a> 功能的一部分。</em></p><p>你可以在 Alfred 的偏好设置中找到「Workflows」选项，查看以下内容，发现工作流如何能帮助你将重复性操作成为过去时，让你以一种你从来没有想到的方式更有效率的操作你的 Mac。</p><blockquote><p>提示: 双击工作流组件，每个组件在它的配置面板的左下角都有一个问号图标，单击可跳转至组件相关页面，以查找更多详细信息。</p></blockquote><p>想马上跳转？从内置 “Examples” 选项添加一些工作流，来看看你的第一个工作流是怎样工作的！:)</p><h2 id="工作流简介"><a href="#工作流简介" class="headerlink" title="工作流简介"></a>工作流简介</h2><ul><li><a href="#工作流组件类型">工作流组件类型</a></li><li><a href="#创建你的第一个工作流">创建你的第一个工作流</a></li><li><a href="#下载和发现工作流">下载和发现工作流</a></li><li><a href="#创建你自己的工作流">创建你自己的工作流</a></li></ul><h2 id="工作流组件类型"><a href="#工作流组件类型" class="headerlink" title="工作流组件类型"></a>工作流组件类型</h2><p>要查找特定组件的帮助，请点击下面组件链接，再在页面搜索。或者在  Alfred 偏好设置中点击组件设置左下角问号图标。</p><ul><li><a href="https://www.alfredapp.com/help/workflows/triggers/" target="_blank" rel="noopener">Triggers</a>（触发条件）：可以通过一个快捷键、另一个 Alfred 功能或者外部来源来激活 Alfred。</li><li><a href="https://www.alfredapp.com/help/workflows/inputs/" target="_blank" rel="noopener">Inputs</a>（输入）：基于关键字的组件，用于单独执行或者结合紧随的 {query} 执行。</li><li><a href="https://www.alfredapp.com/help/workflows/actions/" target="_blank" rel="noopener">Actions</a>（动作）：一个执行你工作流中大多数工作的组件，打开或者显示文件、网页搜索、运行脚本和执行命令。</li><li><a href="https://www.alfredapp.com/help/workflows/utilities/" target="_blank" rel="noopener">Utilities</a>（实用工具）：实用工具使你控制如何将组件连接到一起，以及如何将上一个组件输出的参数传递给下一个组件。</li><li><a href="https://www.alfredapp.com/help/workflows/outputs/" target="_blank" rel="noopener">Outputs</a>:（输出）：从你的工作流前面组件中收集信息，用于弹出通知中心消息，以大字体显示输出，复制到剪贴板或者运行一个包含工作流结果的脚本。</li></ul><h2 id="创建你的第一个工作流"><a href="#创建你的第一个工作流" class="headerlink" title="创建你的第一个工作流"></a>创建你的第一个工作流</h2><p>当你第一次切换到 Alfred 偏好设置中的「Workflows」选项时，左侧边栏没有活动的工作流，你可以从新增一个示例工作流开始。</p><p>单击侧边栏底部的 <code>+</code> ，你可以看见菜单里面有五个选项，依次是 Workflow Defaults（工作流默认值）、Getting Started（入门）、Examples（示例）、Templates（模板） 和 Blank Workflow（空工作流）。</p><p><strong>入门</strong> 和 <strong>示例</strong> 工作流是很好的路径去发现这些组件是做什么以及如何将它们连接到一起，Hotkeys（快捷键）和 Keywords（关键字）是较简单的两个例子。可以看看组件的 notes（注释），来理解组件之间如何相互作用。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135614.jpg" alt="Getting Started 工作流"></p><p>已经内置的工作流程 Google 搜索建议和 Amazon 搜索建议对于查看在线结果很有用。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135616.jpg" alt="Google Suggest Workflow"></p><p>在每个新版本中，我们都添加了「入门」和「示例」工作流，所以可以经常查看内置工作流。</p><h2 id="下载和发现工作流"><a href="#下载和发现工作流" class="headerlink" title="下载和发现工作流"></a>下载和发现工作流</h2><p>现在你知道了怎样使用工作流，并了解了内置的 <strong>入门</strong> 和 <strong>示例</strong>，你还将发现 Alfred 同伴用户开发了许多出色的工作流。</p><p>我们已经 <a href="https://www.alfredapp.com/workflows/" target="_blank" rel="noopener">重点介绍了一些我们最喜欢的工作流</a>，你还可以通过下面途径找到数百种工作流：</p><ul><li>在 <a href="https://www.alfredapp.com/blog/" target="_blank" rel="noopener">Alfred 博客</a> 中</li><li>在 <a href="https://alfredforum.com/" target="_blank" rel="noopener">Alfred 社区 </a>中，你可以为自己工作流寻找帮助</li><li>在 <a href="http://packal.org/" target="_blank" rel="noopener">Packal</a> 中，一个用户创建的网站，用于处理 Shawn Rice 创建的工作流和主题</li></ul><blockquote><p>注意: 你发现许多工作流可能是通过 Alfred 2 创建的。它们也应该可以在 Alfred 3 中导入并正常使用。但通过 Alfred  3 创建的工作流不向后兼容 Alfred 2。</p></blockquote><p>如果你没有找到你想要的，你可以 Google 搜索一下，许多用户选择在 GitHub 和个人网站上托管自己的工作流。</p><h2 id="创建自己的工作流"><a href="#创建自己的工作流" class="headerlink" title="创建自己的工作流"></a>创建自己的工作流</h2><p>在 Alfred 偏向设置选项工作流中，你可以看见左侧边栏右下角有一个 <code>[+]</code> 按钮，这是你创建新工作流的起点。</p><p>完整的功能 <strong>示例</strong> 向你展示不同类型的工作流如何工作，从简单的像 “Should I watch this movie?” ，到基于列表或基于脚本用于展示在线结果的工作流（例如 Google 建议和 Amazon 建议）。</p><p><strong>模板</strong> 提供了工作流画布的起点，模板可以预先填充你的工作流画布，以便你可以填补空白。</p><p>如果你希望从 <strong>空白工作流</strong> 开始，选择最下面的 “Blank Workflow”，然后右键单击画布任何区域选择你要加入工作流中的组件。</p><p>你随时可以在 Alfred 偏好设置中通过点击组件设置左下角的问号图标来寻找帮助。最重要的是，玩得开心。</p><h2 id="充分利用工作流"><a href="#充分利用工作流" class="headerlink" title="充分利用工作流"></a>充分利用工作流</h2><p>一旦你掌握了工作流的基础用法，你会发现很多改进工作流的方法，从简单的整理到和与其他 Alfred 用户分享，到使用变量和脚本来创建高级工作流。</p><ul><li><a href="https://www.alfredapp.com/help/workflow/organising-workflows/" target="_blank" rel="noopener">通过类型和默认来整理脚本</a></li><li><a href="https://www.alfredapp.com/help/workflows/advanced/sharing-workflows" target="_blank" rel="noopener">导出和分享脚本</a></li><li><a href="https://www.alfredapp.com/help/troubleshooting/workflows/" target="_blank" rel="noopener">工作流的故障排除</a></li><li><a href="https://www.alfredapp.com/help/workflows/utilities/debug/" target="_blank" rel="noopener">使用工作流的调试程序</a></li></ul><h2 id="高级工作流主题"><a href="#高级工作流主题" class="headerlink" title="高级工作流主题"></a>高级工作流主题</h2><ul><li><a href="https://www.alfredapp.com/help/workflows/advanced/variables/" target="_blank" rel="noopener">在工作流中设置变量</a></li><li><a href="https://www.alfredapp.com/help/workflows/script-environment-variables/" target="_blank" rel="noopener">脚本环境变量</a></li><li><a href="https://www.alfredapp.com/help/workflows/advanced/alternative-actions/" target="_blank" rel="noopener">在工作流中使用替代动作</a></li><li><a href="https://www.alfredapp.com/help/workflows/inputs/script-filter/" target="_blank" rel="noopener">使用脚本过滤器对象</a></li></ul><p>在工作流方面需要帮助？在 <a href="https://www.alfredforum.com/" target="_blank" rel="noopener">Alfred 论坛</a> 和创作者沟通并寻找你问题的答案吧。:)</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;翻译 Alfred 官网 的 &lt;a href=&quot;https://www.alfredapp.com/help/workflows/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Workflows 帮助&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用工作流（workflows）扩展 Alfred 并以自己的方式完成工作，通过工作流替代重复性操作或基于鼠标的操作，你将提高你的工作效率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135613.jpg&quot; alt=&quot;To-Do List Example Workflow&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Software &amp; Website" scheme="https://depp.wang/categories/Software-Website/"/>
    
    
      <category term="Alfred" scheme="https://depp.wang/tags/Alfred/"/>
    
      <category term="Workflows" scheme="https://depp.wang/tags/Workflows/"/>
    
  </entry>
  
  <entry>
    <title>廖雪峰 MySQL 笔记</title>
    <link href="https://depp.wang/2019/10/30/mysql-note/"/>
    <id>https://depp.wang/2019/10/30/mysql-note/</id>
    <published>2019-10-30T14:25:08.000Z</published>
    <updated>2020-06-11T13:09:39.062Z</updated>
    
    <content type="html"><![CDATA[<p>大部分内容总结于 <a href="https://www.liaoxuefeng.com/wiki/1177760294764384" target="_blank" rel="noopener">《廖雪峰 SQL 笔记》</a></p><h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>选取主键的一个基本原则是：不使用任何业务相关的字段（id）作为主键。修改了主键，会造成一系列的影响</p><p>类型：</p><ol><li>自增整数类型（id）：<code>BIGINT NOT NULL AUTO_INCREMENT</code>。</li><li>全局唯一 GUID 类型</li></ol><p>注意：如果使用 INT 自增类型，那么当一张表的记录数超过 2147483647（约21亿）时，会达到上限而出错。使用 BIGINT自增类型则可以最多约 922 亿亿条记录。</p><a id="more"></a><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>主键默认含有索引。</p><p>即该列的值如果越互不相同，那么索引效率越高。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">INDEX</span> idx_score (score);</span><br></pre></td></tr></table></figure><p>多个索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">INDEX</span> idx_name_score (<span class="keyword">name</span>, score);</span><br></pre></td></tr></table></figure><p>唯一索引保证唯一约束，又是索引，如身份证号、邮箱等字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> uni_email (email)</span><br></pre></td></tr></table></figure><p>只建唯一约束，不建索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> uni_email <span class="keyword">UNIQUE</span> (email)</span><br></pre></td></tr></table></figure><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><p>条件查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> &lt;表名&gt; <span class="keyword">WHERE</span> &lt;条件表达式&gt; (<span class="keyword">AND</span> / <span class="keyword">OR</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">条件</th><th align="left">表达式举例1</th><th align="left">表达式举例2</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">使用 &lt;&gt; 判断不相等</td><td align="left">score &lt;&gt; 80</td><td align="left">name &lt;&gt; ‘abc’</td><td align="left">常用 &lt;&gt; 代替 Not</td></tr><tr><td align="left">使用 LIKE 判断相似</td><td align="left">name LIKE ‘ab%’</td><td align="left">name LIKE ‘%bc%’</td><td align="left">%表示任意字符，例如’ab%’将匹配’ab’，’abc’，’abcd’</td></tr></tbody></table><p>投影查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, score points, <span class="keyword">name</span> <span class="keyword">FROM</span> students; // points 为别名</span><br></pre></td></tr></table></figure><p>排序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span>, gender, score <span class="keyword">FROM</span> students <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>, gender; // 表示先按 score 列倒序，如果有相同分数的，再按 gender 列排序。</span><br></pre></td></tr></table></figure><ul><li>ORDER BY 默认正序，从小到大，DESC descend 倒序</li></ul><p>分页查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span>, gender, score</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">3</span> <span class="keyword">OFFSET</span> <span class="number">0</span>; // 第 1 页，每页 3 条</span><br><span class="line"></span><br><span class="line">LIMIT 3 OFFSET 3; // 第 2 页，每页 3 条</span><br></pre></td></tr></table></figure><ul><li><code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code> 显示从 N+1 行开始，后 M 条记录。</li></ul><p>聚合查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) boys <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> gender = <span class="string">'M'</span>;</span><br></pre></td></tr></table></figure><ul><li>COUNT(*)、COUNT(id)、可用 WHERE 条件</li><li>其他函数：SUM、AVG、MAX、MIN</li><li>如果是字符类型，MAX() 和 MIN() 会返回排序最后和排序最前的字符</li><li>结合 GROUP BY 分组：<code>SELECT class_id, COUNT(*) num FROM students GROUP BY class_id;</code></li><li>多个列分组：<code>SELECT class_id, gender, COUNT(*) num FROM students GROUP BY class_id, gender;</code></li></ul><p>多表查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> students, classes; // 同时查询 students 表和 classes 表的“乘积”</span><br></pre></td></tr></table></figure><p>连接查询</p><ul><li><p>先确定一个主表作为结果集，然后，把其他表的行有选择性地「连接」在主表结果集上。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line"><span class="keyword">FROM</span> students s</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> classes c</span><br><span class="line"><span class="keyword">ON</span> s.class_id = c.id;</span><br></pre></td></tr></table></figure></li><li><p>内连接：只查询符合两个表的结果，取交集</p></li><li><p>右外连接 RIGHT OUTER JOIN：查询符合右边表所有结果，空余用 NULL 填充</p></li><li><p>左外连接 LEFT OUTER JOIN：查询符合主表所有结果，空余用 NULL 填充</p></li><li><p>FULL OUTER JOIN，并集</p></li></ul><h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><p>INSERT </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> &lt;表名&gt; (字段<span class="number">1</span>, 字段<span class="number">2</span>, ...) <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>, ...);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (class_id, <span class="keyword">name</span>, gender, score) <span class="keyword">VALUES</span></span><br><span class="line">  (<span class="number">1</span>, <span class="string">'大宝'</span>, <span class="string">'M'</span>, <span class="number">87</span>),</span><br><span class="line">  (<span class="number">2</span>, <span class="string">'二宝'</span>, <span class="string">'M'</span>, <span class="number">81</span>);</span><br></pre></td></tr></table></figure><p>UPDATE</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> &lt;表名&gt; <span class="keyword">SET</span> 字段<span class="number">1</span>=值<span class="number">1</span>, 字段<span class="number">2</span>=值<span class="number">2</span>, ... <span class="keyword">WHERE</span> ...;</span><br></pre></td></tr></table></figure><ul><li>WHERE 跟 SELECT 的 WHERE 一样使用</li><li><code>UPDATE students SET score=60;</code> 修改表的所有数据，先用 SELECT 语句测试</li></ul><p>DELETE</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> &lt;表名&gt; <span class="keyword">WHERE</span> ...;</span><br></pre></td></tr></table></figure><ul><li><code>DELETE FROM students;</code> 删除表所有数据</li></ul><h2 id="库-表-列-SQL"><a href="#库-表-列-SQL" class="headerlink" title="库/表/列 SQL"></a>库/表/列 SQL</h2><p>也可以只安装 MySQL Client，然后连接到远程 MySQL Server。假设远程 MySQL Server 的 IP 地址是 10.0.1.99，那么就使用 -h 指定 IP 或域名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h 10.0.1.99 -u root -p</span><br></pre></td></tr></table></figure><p><strong>库</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">DATABASES</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure><p><strong>表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLES</span>; </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`students`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`class_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`gender`</span> <span class="built_in">varchar</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`score`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line">DESC students; // <span class="keyword">describe</span>，查看表结构</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> students; // 查看创建表的语句</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> students; // 删除表</span><br></pre></td></tr></table></figure><ul><li>bigint(20) 后面的 20 指的是字段的长度。最长不超过 20 位（922亿亿）</li><li>NOT NULL：插入数据时，必须有值</li><li>CHARSET( character set )</li><li>ENGINE=InnoDB DEFAULT：默认引擎 InnoDB</li></ul><p><strong>列</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> birth <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>; // 给 students 表新增一列 birth</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students <span class="keyword">CHANGE</span> <span class="keyword">COLUMN</span> birth birthday <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>; // 把列名改为 birthday，类型改为 VARCHAR(20)</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> studens <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> birthday; // 删除 birthday 列</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXIT // 退出</span><br></pre></td></tr></table></figure><h2 id="实用-SQL"><a href="#实用-SQL" class="headerlink" title="实用 SQL"></a>实用 SQL</h2><p>插入或替换</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REPLACE</span> <span class="keyword">INTO</span> students (<span class="keyword">id</span>, class_id, <span class="keyword">name</span>, gender, score) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="string">'小明'</span>, <span class="string">'F'</span>, <span class="number">99</span>);</span><br></pre></td></tr></table></figure><p>插入或更新</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (<span class="keyword">id</span>, class_id, <span class="keyword">name</span>, gender, score) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="string">'小明'</span>, <span class="string">'F'</span>, <span class="number">99</span>) <span class="keyword">ON</span> <span class="keyword">DUPLICATE</span> <span class="keyword">KEY</span> <span class="keyword">UPDATE</span> <span class="keyword">name</span>=<span class="string">'小明'</span>, gender=<span class="string">'F'</span>, score=<span class="number">99</span>;</span><br></pre></td></tr></table></figure><p>插入或忽略：存在就忽略</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">IGNORE</span> <span class="keyword">INTO</span> students (<span class="keyword">id</span>, class_id, <span class="keyword">name</span>, gender, score) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="string">'小明'</span>, <span class="string">'F'</span>, <span class="number">99</span>);</span><br></pre></td></tr></table></figure><p>快照：复制当前表的数据到一个新表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 对 class_id=1 的记录进行快照，并存储为新表 students_of_class1:</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> students_of_class1 <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> class_id=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>写入查询结果集</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">statistics</span> (class_id, average) <span class="keyword">SELECT</span> class_id, <span class="keyword">AVG</span>(score) <span class="keyword">FROM</span> students <span class="keyword">GROUP</span> <span class="keyword">BY</span> class_id;</span><br></pre></td></tr></table></figure><p>处理数据表被锁</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show open tables where in_use&gt;0; // 查看表是否被锁</span><br><span class="line">show processlist // 查看所有进程</span><br><span class="line">kill id // 杀进程</span><br></pre></td></tr></table></figure><p>用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="keyword">concat</span>(<span class="string">'User:'''</span>,<span class="keyword">USER</span>,<span class="string">'''@'''</span>,HOST,<span class="string">''';'</span>) <span class="keyword">AS</span> <span class="keyword">QUERY</span> <span class="keyword">FROM</span> mysql. <span class="keyword">USER</span>; // 查看数据库的所有用户</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">grants</span> <span class="keyword">for</span> <span class="string">'label'</span>@<span class="string">'%'</span> // 查看用户所有表的权限</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'label'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'label123'</span>;  // 创建用户</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'label'</span>@<span class="string">'localhost'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'label123'</span>; // 创建用户</span><br></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>这种把多条语句作为一个整体进行操作的功能，被称为数据库 「事务」。</p><p>对于单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为<em>隐式事务</em>。</p><p>使用<code>BEGIN</code>开启一个事务，使用<code>COMMIT</code>提交一个事务，这种事务被称为 <em>显式事务</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance = balance - <span class="number">100</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance = balance + <span class="number">100</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>; // 如果 <span class="keyword">COMMIT</span> 语句执行失败了，整个事务也会失败。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance = balance - <span class="number">100</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance = balance + <span class="number">100</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span>; // 回滚前面执行的 sql</span><br></pre></td></tr></table></figure><p>事务有四大特性：原子性：不可分割，要么成功，要么失败；一致性：事务完成后，所有数据的状态是一致的。隔离性：并发执行的事务，对数据的操作要具有隔离性；持久性：事务完成后，数据就持久化到数据库中</p><p>事务有隔离性有级别，共 4 种，隔离级别由低到高</p><table><thead><tr><th align="left">Isolation Level</th><th align="left">脏读（Dirty Read）</th><th align="left">不可重复读（Non Repeatable Read）</th><th align="left">幻读（Phantom Read）</th></tr></thead><tbody><tr><td align="left">Read Uncommitted</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">Yes</td></tr><tr><td align="left">Read Committed</td><td align="left">-</td><td align="left">Yes</td><td align="left">Yes</td></tr><tr><td align="left">Repeatable Read</td><td align="left">-</td><td align="left">-</td><td align="left">Yes</td></tr><tr><td align="left">Serializable</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from students;</span><br><span class="line">+<span class="comment">----+-------+</span></span><br><span class="line">| id | name  |</span><br><span class="line">+<span class="comment">----+-------+</span></span><br><span class="line">|  1 | Alice |</span><br><span class="line">+<span class="comment">----+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="Read-Uncommitted（可读到未提交）"><a href="#Read-Uncommitted（可读到未提交）" class="headerlink" title="Read Uncommitted（可读到未提交）"></a>Read Uncommitted（可读到未提交）</h3><p>一个事务可以读到另一个事务更新，但未提交的数据。如果另一个事务回滚，当前读取的值就是脏数据，称为脏读。</p><table><thead><tr><th align="left">时刻</th><th align="left">事务 A</th><th align="left">事务 B</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</td><td align="left">SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</td></tr><tr><td align="left">2</td><td align="left">BEGIN;</td><td align="left">BEGIN;</td></tr><tr><td align="left">3</td><td align="left">UPDATE students SET name = ‘Bob’ WHERE id = 1;</td><td align="left"></td></tr><tr><td align="left">4</td><td align="left"></td><td align="left">SELECT * FROM students WHERE id = 1; // ‘Bob’</td></tr><tr><td align="left">5</td><td align="left">ROLLBACK;</td><td align="left"></td></tr><tr><td align="left">6</td><td align="left"></td><td align="left">SELECT * FROM students WHERE id = 1; // ‘Alice’</td></tr><tr><td align="left">7</td><td align="left"></td><td align="left">COMMIT;</td></tr></tbody></table><h3 id="Read-Commited（可读到已提交）"><a href="#Read-Commited（可读到已提交）" class="headerlink" title="Read Commited（可读到已提交）"></a>Read Commited（可读到已提交）</h3><p>存在不可重复读的问题，事务重复读时，可能数据不一致。</p><table><thead><tr><th align="left">时刻</th><th align="left">事务A</th><th align="left">事务B</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</td><td align="left">SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</td></tr><tr><td align="left">2</td><td align="left">BEGIN;</td><td align="left">BEGIN;</td></tr><tr><td align="left">3</td><td align="left"></td><td align="left">SELECT * FROM students WHERE id = 1; // ‘Alice’</td></tr><tr><td align="left">4</td><td align="left">UPDATE students SET name = ‘Bob’ WHERE id = 1;</td><td align="left"></td></tr><tr><td align="left">5</td><td align="left">COMMIT;</td><td align="left"></td></tr><tr><td align="left">6</td><td align="left"></td><td align="left">SELECT * FROM students WHERE id = 1; // ‘Bob’</td></tr><tr><td align="left">7</td><td align="left"></td><td align="left">COMMIT;</td></tr></tbody></table><ul><li>第一种情况：两次读取都是 Alice</li></ul><h3 id="Repeatable-Commited（可重复读）"><a href="#Repeatable-Commited（可重复读）" class="headerlink" title="Repeatable Commited（可重复读）"></a>Repeatable Commited（可重复读）</h3><p>存在幻读的问题，幻读就是没有读取的记录，以为不存在，但可以更新成功，再次读取时，就出现了。</p><table><thead><tr><th align="left">时刻</th><th align="left">事务A</th><th align="left">事务B</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</td><td align="left">SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</td></tr><tr><td align="left">2</td><td align="left">BEGIN;</td><td align="left">BEGIN;</td></tr><tr><td align="left">3</td><td align="left"></td><td align="left">SELECT * FROM students WHERE id = 99; // Empty</td></tr><tr><td align="left">4</td><td align="left">INSERT INTO students (id, name) VALUES (99, ‘Bob’);</td><td align="left"></td></tr><tr><td align="left">5</td><td align="left">COMMIT;</td><td align="left"></td></tr><tr><td align="left">6</td><td align="left"></td><td align="left">SELECT * FROM students WHERE id = 99; // Empty</td></tr><tr><td align="left">7</td><td align="left"></td><td align="left">UPDATE students SET name = ‘Alice’ WHERE id = 99;</td></tr><tr><td align="left">8</td><td align="left"></td><td align="left">SELECT * FROM students WHERE id = 99; // Alice</td></tr><tr><td align="left">9</td><td align="left"></td><td align="left">COMMIT;</td></tr></tbody></table><p>其实幻读影响不大，没有脏读和不可重复读的问题，Mysql 默认隔离级别就是 Repeatable Commited。</p><ul><li>第一种情况：两次读取都是 Alice</li><li>第二种情况：两次读取都是 Alice</li></ul><h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p>串行操作，没有并发。</p><table><thead><tr><th align="left">时刻</th><th align="left">事务A</th><th align="left">事务B</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">SET TRANSACTION ISOLATION LEVEL Serializable;</td><td align="left">SET TRANSACTION ISOLATION LEVEL Serializable;</td></tr></tbody></table><p>上面三种情况均会报错。</p><hr><p>数据库语句顺序</p><ul><li>写的顺序：select … from… where…. group by… having… order by.. limit [offset,] (rows)</li><li>执行顺序：from… where…group by… having…. select … order by… limit</li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">select</span> host,<span class="keyword">user</span> <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135809.jpg" alt="image-20191126122815557"></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> host,<span class="keyword">user</span>,<span class="keyword">password</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135810.jpg" alt="image-20191126123141389"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大部分内容总结于 &lt;a href=&quot;https://www.liaoxuefeng.com/wiki/1177760294764384&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《廖雪峰 SQL 笔记》&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;主键&quot;&gt;&lt;a href=&quot;#主键&quot; class=&quot;headerlink&quot; title=&quot;主键&quot;&gt;&lt;/a&gt;主键&lt;/h2&gt;&lt;p&gt;选取主键的一个基本原则是：不使用任何业务相关的字段（id）作为主键。修改了主键，会造成一系列的影响&lt;/p&gt;
&lt;p&gt;类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自增整数类型（id）：&lt;code&gt;BIGINT NOT NULL AUTO_INCREMENT&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;全局唯一 GUID 类型&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意：如果使用 INT 自增类型，那么当一张表的记录数超过 2147483647（约21亿）时，会达到上限而出错。使用 BIGINT自增类型则可以最多约 922 亿亿条记录。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="https://depp.wang/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://depp.wang/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>什么是测试驱动开发？（TDD）</title>
    <link href="https://depp.wang/2019/10/08/what-is-the-test-driven-development/"/>
    <id>https://depp.wang/2019/10/08/what-is-the-test-driven-development/</id>
    <published>2019-10-08T00:30:01.000Z</published>
    <updated>2020-06-11T13:09:39.062Z</updated>
    
    <content type="html"><![CDATA[<p>测试驱动开发简称 TDD，英文全称 Test Driven Development</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135819.jpg" alt=""></p><ul><li>结对编程：一个写，一个看；另一个写，一个看</li></ul><p>编写一个函数，返回小于给定 max 值的所有素数组成的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getPrimes(<span class="keyword">int</span> max)</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="1、思考"><a href="#1、思考" class="headerlink" title="1、思考"></a>1、思考</h2><p>任务分解</p><ul><li>边界条件：getPrimes(2)、getPrimes(0)、getPrimes(-1)</li><li>正常输入：getPrimes(9)、getPrimes(17)、getPrimes(30)</li></ul><h2 id="2、运行失败"><a href="#2、运行失败" class="headerlink" title="2、运行失败"></a>2、运行失败</h2><p>写一个测试用例，运行失败（Tests failed）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeUtilTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetPrimesForeEmptyResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] expected = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        Assert.assertArrayEquals(expected, PrimeUtil.getPrimes(<span class="number">2</span>));</span><br><span class="line">        Assert.assertArrayEquals(expected, PrimeUtil.getPrimes(<span class="number">0</span>));</span><br><span class="line">        Assert.assertArrayEquals(expected, PrimeUtil.getPrimes(-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getPrimes(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、测试通过"><a href="#3、测试通过" class="headerlink" title="3、测试通过"></a>3、测试通过</h2><p>just enough 代码 1，测试通过（Tests pass）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getPrimes(<span class="keyword">int</span> max) &#123;</span><br><span class="line">        <span class="keyword">if</span> (max &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>just enough 代码 2，测试通过（Tests pass）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeUtilTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetPrimesForeEmptyResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] expected = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        Assert.assertArrayEquals(expected, PrimeUtil.getPrimes(<span class="number">2</span>));</span><br><span class="line">        Assert.assertArrayEquals(expected, PrimeUtil.getPrimes(<span class="number">0</span>));</span><br><span class="line">        Assert.assertArrayEquals(expected, PrimeUtil.getPrimes(-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetPrimes</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Assert.assertArrayEquals(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;, PrimeUtil.getPrimes(<span class="number">9</span>));</span><br><span class="line">        Assert.assertArrayEquals(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;, PrimeUtil.getPrimes(<span class="number">17</span>));</span><br><span class="line">        Assert.assertArrayEquals(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>&#125;, PrimeUtil.getPrimes(<span class="number">30</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getPrimes(<span class="keyword">int</span> max) &#123;</span><br><span class="line">        <span class="keyword">if</span> (max &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span>[] newArray = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">            <span class="keyword">int</span> size = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; max; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; i / <span class="number">2</span> + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// 结束内循环</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j == i / <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">                    newArray[size++] = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            newArray = Arrays.copyOf(newArray, size); <span class="comment">// 去除数组中多余的数据</span></span><br><span class="line">            <span class="keyword">return</span> newArray;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判断是否为质数：当一个数 i 除以所有<code>大于 2，小于 i / 2 + 1</code>都不等于 0，那他就是质数。</li><li>所有：遍历<code>大于 2，小于 max</code>的所有数，判断是否为质数。</li><li>放入到数组中：通过判断此时的<code>j 是否已经是最大值，即 j = i / 2 + 1</code>。<h2 id="4、重构"><a href="#4、重构" class="headerlink" title="4、重构"></a>4、重构</h2></li></ul><p>重构代码（Refactor）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getPrimes(<span class="keyword">int</span> max) &#123;</span><br><span class="line">        <span class="comment">// 提前准备</span></span><br><span class="line">        <span class="keyword">if</span> (max &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] primes = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 控制</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">2</span>; num &lt; max; num++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime(num)) &#123;</span><br><span class="line">                primes[count++] = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        primes = Arrays.copyOf(primes, count);</span><br><span class="line">        <span class="keyword">return</span> primes;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 策略</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; num / <span class="number">2</span> + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/DeppWang/litespring" target="_blank" rel="noopener">源码</a></li></ul><h2 id="常用断言"><a href="#常用断言" class="headerlink" title="常用断言"></a>常用断言</h2><ul><li>Assert.assertEquals(expected, actual);</li><li>Assert.assertTrue(condition);</li><li>Assert.assertFalse(condition);</li><li>Assert.assertNull(condition);</li><li>Assert.assertNotNull(object);</li><li>Assert.assertArrayEquals(expecteds, actuals);</li><li>Assert.fail();</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、先写测试用例；2、根据测试用例去实现代码；3、重构代码</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;测试驱动开发简称 TDD，英文全称 Test Driven Development&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135819.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;结对编程：一个写，一个看；另一个写，一个看&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;编写一个函数，返回小于给定 max 值的所有素数组成的数组。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] getPrimes(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; max)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Programming" scheme="https://depp.wang/categories/Programming/"/>
    
    
      <category term="TDD" scheme="https://depp.wang/tags/TDD/"/>
    
  </entry>
  
  <entry>
    <title>Git 笔记：常用命令与原理</title>
    <link href="https://depp.wang/2019/09/23/git-note/"/>
    <id>https://depp.wang/2019/09/23/git-note/</id>
    <published>2019-09-23T14:32:33.000Z</published>
    <updated>2020-06-11T13:09:39.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、安装-Git"><a href="#一、安装-Git" class="headerlink" title="一、安装 Git"></a>一、安装 Git</h2><ul><li>Windows：下载并安装 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Git</a>.</li><li>Mac：使用 <a href="http://mxcl.github.com/homebrew/" target="_blank" rel="noopener">Homebrew</a>, <a href="http://www.macports.org/" target="_blank" rel="noopener">MacPorts</a> 或者下载 <a href="http://sourceforge.net/projects/git-osx-installer/" target="_blank" rel="noopener">安装程序</a>。</li><li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></li><li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code></li></ul><a id="more"></a><h2 id="二、设置-Git"><a href="#二、设置-Git" class="headerlink" title="二、设置 Git"></a>二、设置 Git</h2><p>如果需要使用 SSH 协议连接</p><p>添加 <code>SSH-Key</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"yourmail@xxx.com"</span> <span class="comment"># 第一次添加，key generator(密匙生成器)、rsa 一种算法</span></span><br><span class="line">ssh-keygen -t rsa -f ~/.ssh/id_rsa_x -C <span class="string">"yourmail@xxx.com"</span> <span class="comment"># 非第一次添加</span></span><br><span class="line"><span class="built_in">cd</span> ~/.ssh </span><br><span class="line">open ~/.ssh <span class="comment"># mac 下打开</span></span><br></pre></td></tr></table></figure><p>SSH Key 是一对，分为私钥和公钥，是非对称加密，当本地仓库需要往远程仓库 push 时，私钥加密传输内容，而只有对应的公钥才能解密，所以远程仓库需要添加公钥。</p><p> <strong>一台电脑要连多个远程仓库，可以就用一对 SSH Key。</strong>如果在一台电脑上，要为不同远程仓库对应不同私钥时，需要新增 <code>config</code> 文件，为不同远程仓库指定使用不同的私钥。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 第一个账号，默认使用的账号</span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">User git</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line"></span><br><span class="line"># 第二个账号</span><br><span class="line">Host second.github.com # second 为前缀名，可以任意设置</span><br><span class="line">HostName github.com</span><br><span class="line">User git</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_2</span><br><span class="line"></span><br><span class="line"># 第三个账号</span><br><span class="line">Host e.coding.net</span><br><span class="line">User git</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_3</span><br></pre></td></tr></table></figure><ul><li>原理分析：本地 SSH 客户端（Git）使用类似 <code>git@github.com:deppwang/deppwang.github.io.git</code> 地址来连接远程仓库（可通过 <code>git remote</code> 命令查看）。<code>@</code> 后面跟的是 <code>Host</code>，<code>@github.com</code> 代表使用 id_rsa 这个私钥</li></ul><p>测试 <code>SSH-Key</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清空本地的 SSH 缓存，添加新的 SSH 密钥 到 SSH agent 中</span></span><br><span class="line">ssh-add -D</span><br><span class="line">ssh-add id_rsa</span><br><span class="line">ssh-add id_rsa_x</span><br><span class="line"></span><br><span class="line">ssh-add -l <span class="comment"># 最后确认一下新密钥已经添加成功</span></span><br><span class="line"></span><br><span class="line">ssh -T git@github.com <span class="comment"># 测试是否连接成功</span></span><br></pre></td></tr></table></figure><p>用户配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局配置 用户名 / 邮箱</span></span><br><span class="line">git config --global user.name <span class="string">"Your Name"</span></span><br><span class="line">git config --global user.email <span class="string">"email@example.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消全局 用户名 / 邮箱 配置</span></span><br><span class="line">git config --global --<span class="built_in">unset</span> user.name</span><br><span class="line">git config --global --<span class="built_in">unset</span> user.email</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置使用 https 使用代理</span></span><br><span class="line">git config --global http.proxy socks5://127.0.0.1:1080</span><br><span class="line">git config --global https.proxy socks5://127.0.0.1:1080</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入项目文件夹，单独设置每个 repo 用户名 / 邮箱</span></span><br><span class="line">git config user.email <span class="string">"xxxx@xx.com"</span></span><br><span class="line">git config user.name <span class="string">"xxxx"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --list <span class="comment"># 查看当前仓库所有配置</span></span><br><span class="line"></span><br><span class="line">git config --global color.ui <span class="literal">true</span> <span class="comment"># 显示颜色</span></span><br></pre></td></tr></table></figure><p>LF 与 CRLF</p><ul><li>LF (Line Feed) 代表换行，对应字符 <code>\n</code>，Unix 系统使用；CR(Carriage Return) ，CRLF 对应字符 <code>\r</code>，Windows 系统使用<blockquote><p>标准化 指在提交代码到 Git 版本库中时，将文本文件中的换行符 CRLF 转为 LF 的过程<br>转换 指在检出 Git 版本库代码过程中，将文本文件中的换行符 LF 转换为 CRLF 的过程</p></blockquote></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf  [<span class="literal">true</span> | input | <span class="literal">false</span>]  <span class="comment"># 全局设置</span></span><br><span class="line">git config --<span class="built_in">local</span> core.autocrlf  [<span class="literal">true</span> | input | <span class="literal">false</span>] <span class="comment"># 针对本项目设置</span></span><br></pre></td></tr></table></figure><ul><li>true 自动完成标准化与转换</li><li>input 只做标准化操作，不做转换操作</li><li>false 提交与检出的代码都保持文件原有的换行符不变</li></ul><p>Git 安装后默认为 false，常用设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf  <span class="literal">true</span> <span class="comment"># Windows</span></span><br><span class="line">git config --global core.autocrlf  input <span class="comment"># Unix</span></span><br></pre></td></tr></table></figure><p>配置别名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.st status</span><br><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.unstage <span class="string">'reset HEAD'</span></span><br><span class="line">git config --global alias.last <span class="string">'log -1'</span></span><br><span class="line">git config --global alias.lg <span class="string">"log --color --graph --pretty=format:'% Cred% h% Creset -% C(yellow)% d% Creset % s % Cgreen(% cr) % C(bold blue)&lt;% an&gt;% Creset' --abbrev-commit"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># macOS 版 Git 默认设置的别名</span></span><br><span class="line">git config --global alias.aa <span class="string">'!git add . &amp;&amp; git add -u . &amp;&amp; git status'</span></span><br><span class="line">git config --global alias.d diff</span><br><span class="line">git config --global alias.cm <span class="string">'commit -m'</span></span><br></pre></td></tr></table></figure><h2 id="三、常用命令"><a href="#三、常用命令" class="headerlink" title="三、常用命令"></a>三、常用命令</h2><p>远程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:username/repo.git <span class="comment"># 关联远程库，可关联多个</span></span><br><span class="line">git remote <span class="comment"># 查看远程库</span></span><br><span class="line">git remote -v <span class="comment"># 查看更详细信息</span></span><br><span class="line">git remote rename origin orgin2 <span class="comment">#  origin 重命名为 origin2</span></span><br><span class="line"></span><br><span class="line">git co -b dev origin/dev <span class="comment"># 将远程 dev 分支切换为本地 dev 分支</span></span><br><span class="line"></span><br><span class="line">git push origin (-u) &lt;branch-name&gt; <span class="comment"># 推送到远程分支，'-u' 参数，将当前分支和远程的 master 分支关联起来。不能 push 空到远程去</span></span><br><span class="line">git push origin :branch-name /git branch -dr &lt;remote/branch&gt; <span class="comment"># 删除远程分支</span></span><br><span class="line">git push -f origin master <span class="comment"># 回滚远程分支，让其跟本地分支一致</span></span><br><span class="line"></span><br><span class="line">git pull <span class="comment"># pull 所有的分支到本地，如果不是直接 clone 的项目，直接使用此命令会报错</span></span><br><span class="line">git fetch <span class="comment"># 拉取所有分支到本地，不 merge</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:username/repo.git <span class="comment"># clone 后 不用再关联远程库</span></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:username/repo.git new-name  <span class="comment"># 将克隆的仓库重命名为 new-name</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立本地分支和远程分支的关联，git pull 失败时执行</span></span><br><span class="line">git br --<span class="built_in">set</span>-upstream-to=origin/branch-name branch-name</span><br><span class="line">git br --<span class="built_in">set</span>-upstream branch-name origin/branch-name</span><br></pre></td></tr></table></figure><p>常规</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">git add . /git add -A  /git add --all <span class="comment"># 添加所有的文件</span></span><br><span class="line">git add -u <span class="comment"># update，add 所有 modified 文件</span></span><br><span class="line"></span><br><span class="line">git st <span class="comment"># 查看状态</span></span><br><span class="line"></span><br><span class="line">git ci -m &lt;message&gt; <span class="comment">## Commit</span></span><br><span class="line"></span><br><span class="line">git ci --amend <span class="comment"># 修改最后一次 commit，已提交到远程的 commit 不要修改</span></span><br><span class="line"></span><br><span class="line">git merge dev <span class="comment"># 将 dev 分支合并到当前分支（默认 Fast-forward 模式，看不出来合并历史）</span></span><br><span class="line">git merge --no-ff -m <span class="string">"merge with no-ff"</span> dev <span class="comment"># 禁用 Fast-forward，可以看出合并历史</span></span><br><span class="line"></span><br><span class="line">git diff &lt;file&gt; <span class="comment"># 查看修改的内容 (工作区和暂存区的不同，工作区和原来的不同)</span></span><br><span class="line">git diff HEAD -- &lt;file&gt; <span class="comment"># 查看工作区与版本库最新版本（分支的最新 commit）的不同</span></span><br><span class="line">git diff --cached &lt;file&gt; <span class="comment"># 查看暂存区和分支的不同</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span> -p &lt;file&gt; <span class="comment"># 查看当前文件 commit 记录</span></span><br><span class="line">git <span class="built_in">log</span> -p -1 <span class="comment"># 查看最近一次 commit 修改记录</span></span><br><span class="line">git blame &lt;file&gt; <span class="comment"># 查看当前文件被谁修改过</span></span><br><span class="line"></span><br><span class="line">Ctrl + C <span class="comment"># 命令错误时，退出编辑页面</span></span><br><span class="line">Ctrl + Z <span class="comment"># 退出</span></span><br></pre></td></tr></table></figure><ul><li>rebase 让分支变为一根直线，更加清晰</li></ul><p>分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git br dev <span class="comment"># 创建分支</span></span><br><span class="line">git br -m oldName newName <span class="comment"># 修改分支名字</span></span><br><span class="line">git br <span class="comment"># 查看当前分支</span></span><br><span class="line">git br -v <span class="comment"># 查看本地分支详情</span></span><br><span class="line">git br -a <span class="comment"># 查看所有分支</span></span><br><span class="line">git br -av <span class="comment"># 查看所有分支详情</span></span><br><span class="line">git br -d dev <span class="comment"># 删除 dev 分支，只是删除了 dev 指针。</span></span><br><span class="line">git br -D &lt;branch-name&gt; <span class="comment"># 强行删除没有合并的分支</span></span><br><span class="line">git br | grep -v <span class="string">"dev"</span> | xargs git branch -D <span class="comment"># 删除除 dev 外的所有分支</span></span><br><span class="line">git co -b dev <span class="comment"># 创建并切换分支</span></span><br></pre></td></tr></table></figure><p>撤销、删除与回退</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">git co -- &lt;file&gt; <span class="comment"># 把文件在工作区的修改全部撤销掉（回到最近 git commit 或 git add 时的状态）</span></span><br><span class="line">git co -- . <span class="comment"># 全部撤销</span></span><br><span class="line"></span><br><span class="line">git unstage &lt;file&gt; <span class="comment"># 撤销 add 操作，将修改的内容放回工作区</span></span><br><span class="line">git unstage . <span class="comment"># 全部撤销</span></span><br><span class="line"></span><br><span class="line">rm file <span class="comment"># 删除工作区的文件，需要 commit 生效。删错了可以使用 `git co -- file` 还原</span></span><br><span class="line">git rm --cache &lt;file&gt; <span class="comment"># 从暂存区删除文件</span></span><br><span class="line">git rm -rf --cache &lt;file&gt; <span class="comment"># 从暂存区中清除文件文件</span></span><br><span class="line">git rm &lt;file&gt; <span class="comment"># 从分支上删除文件</span></span><br><span class="line"></span><br><span class="line">git merge --abort <span class="comment"># 撤销 pull/merge 操作，常用于 pull 冲突时</span></span><br><span class="line"></span><br><span class="line">git reset --hard HEAD^ <span class="comment"># 回退到上一版本</span></span><br><span class="line">git reset --hard &lt;commit&gt; <span class="comment"># 回退到某一版本</span></span><br></pre></td></tr></table></figure><!--HEAD 指向 master，master 指向提交，HEAD 指向当前分支 --><!--"master 分支 " 是一条线，master 是一个指针 --><!-- 创建分支 dev，创建一个指针 dev，指向相同的提交点，再把 HEAD 指向 dev，表示当前分支再 dev 上 --><!-- 如果切换分支，commit 后，再切换回 master 分支，会提示当前 master 分支比远程的 master 分支要超前 1 个提交，不提示 "git push"。??，如果是 master 分支自己 commit，会提示 "git push"--><!-- 当将两个都提交的分支合并时，不能 “快速合并”，如果有冲突，会提示 “MERGING", 手动处理冲突，add、commit--><!-- 回退之后 commit，图形化视图怎样展示？--><!-- 使用 Fast-forward 模式，删除分支后，会丢失分支信息？  --><!----- 就看不出来曾经做过合并 --><!-- 从哪个分支修改 bug 就从哪个分支创建临时分支，提交，切换，再**删除**临时分支 --><p>储藏</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git stash save <span class="string">"message"</span> <span class="comment"># 把未提交的，当前现场「储藏」起来。</span></span><br><span class="line">git stash list <span class="comment"># 查看所有的 “储藏”</span></span><br><span class="line">git stash apply <span class="comment"># 恢复不删除</span></span><br><span class="line">git stash drop <span class="comment">## 删除</span></span><br><span class="line">git stash pop <span class="comment"># 恢复顺便删除</span></span><br><span class="line">git stash apply stash@&#123;x&#125; <span class="comment"># 恢复指定下标 stash</span></span><br></pre></td></tr></table></figure><p>标签</p><!--git pull origin <name> 出现 vim 的处理步骤 --><!--1. 按键盘字母 i 进入 insert 模式 --><!--2. 修改最上面那行黄色合并信息，可以不修改 --><!--3. 按键盘左上角 "Esc"--><!--4. 输入 ":wq", 注意是冒号 + wq, 按回车键即可 --><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git tag &lt;name&gt; <span class="comment"># 打标签</span></span><br><span class="line">git tag <span class="comment"># 查看所有标签</span></span><br><span class="line">git tag &lt;name&gt; &lt;commitId&gt; <span class="comment"># 将标签打在某个 commit 上</span></span><br><span class="line">git show &lt;name&gt; <span class="comment"># 查看标签信息</span></span><br><span class="line">git tag -a &lt;name&gt; -m <span class="string">"***"</span> &lt;commitId&gt; <span class="comment"># -a 指定标签名，- </span></span><br><span class="line">git tag -d &lt;name&gt; <span class="comment"># 删除标签</span></span><br><span class="line">git push origin --tags <span class="comment"># 推送所有未推送的标签</span></span><br><span class="line">git tag -d &lt;name&gt; /git push origin :refs/tags/&lt;name&gt; <span class="comment"># 删除远程标签</span></span><br></pre></td></tr></table></figure><p>.gitignore</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忽略除 .sh/.py 结尾的其他文件</span></span><br><span class="line">*</span><br><span class="line">!*.sh</span><br><span class="line">!*.py</span><br></pre></td></tr></table></figure><ul><li>不提交本地文件：从暂存区中清除，再在.gitignore 中忽略<!--1. 在项目根目录上查看是否有.gitignore 文件，没有就用 notepad++ 新增一个。--></li></ul><!--2. 在文件中添加你要忽略的文件相对于根目录的文件路径。--><!--3. 此时你要忽略的文件已经加入版本控制了，被 Git 跟踪（track），所以即使文件路径添加进.gitignore 后，文件也没有反应。使用以下命令清除暂存区的文件 --><p>Commit</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git ci -m <span class="string">"Article updated: `date +'% Y-% m-% d % H:% M:% S'`"</span> <span class="comment"># Article updated: 2019-05-29 21:11:06</span></span><br><span class="line">git ci -m <span class="string">"`date +'% Y-% m-% d'`"</span> <span class="comment"># 2019-05-29</span></span><br><span class="line">git ci -m <span class="string">"`date`"</span></span><br><span class="line">current=<span class="string">"`date +'% Y-% m-% d % H:% M:% S'`"</span></span><br><span class="line">msg=<span class="string">"Article updated: <span class="variable">$current</span>"</span></span><br><span class="line">git ci -m <span class="string">"<span class="variable">$msg</span>"</span> <span class="comment"># Article updated: 2019-05-29 21:11:06</span></span><br><span class="line">git ci -m <span class="string">":bug: Fixing a bug."</span>  <span class="comment"># 🐛 Fixing a bug.</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://gitmoji.carloscuesta.me" target="_blank" rel="noopener">Git commit emoji</a></li></ul><p>IDEA Git</p><ul><li>IDEA 版本控制是默认记录工作区和暂存区与分支上的不同，即：直接修改工作区的内容，不同；add 到暂存区后，还是不同</li><li>IDEA 可以直接 commit 文件而不用 add，可以理解为默认帮助 add</li><li>IDEA 的 revert 相当 <code>git co -- file</code></li><li>修改 commit 描述：<code>Undo commit</code></li></ul><h2 id="四、原理"><a href="#四、原理" class="headerlink" title="四、原理"></a>四、原理</h2><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135148.png" alt="image.png"></p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135204.png" alt="image.png"></p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135209.png" alt="image.png"></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">廖雪峰大佬 Git 教程</a></li><li><a href="https://gitee.com/liaoxuefeng/learn-java/raw/master/teach/git-cheatsheet.pdf" target="_blank" rel="noopener">git-cheatsheet</a></li><li><a href="https://www.jianshu.com/p/04e9a885c5c8" target="_blank" rel="noopener">Git 之同一台电脑连接多个远程仓库</a></li><li><a href="https://stackoverflow.com/questions/4654437/how-to-set-current-date-as-git-commit-message" target="_blank" rel="noopener">How-to-set-current-date-as-git-commit-message</a></li><li><a href="https://stackoverflow.com/questions/14741383/add-date-to-git-commit-message-automatically" target="_blank" rel="noopener">Add-date-to-git-commit-message-automatically</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、安装-Git&quot;&gt;&lt;a href=&quot;#一、安装-Git&quot; class=&quot;headerlink&quot; title=&quot;一、安装 Git&quot;&gt;&lt;/a&gt;一、安装 Git&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Windows：下载并安装 &lt;a href=&quot;https://git-scm.com/download/win&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Git&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Mac：使用 &lt;a href=&quot;http://mxcl.github.com/homebrew/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Homebrew&lt;/a&gt;, &lt;a href=&quot;http://www.macports.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MacPorts&lt;/a&gt; 或者下载 &lt;a href=&quot;http://sourceforge.net/projects/git-osx-installer/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;安装程序&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;Linux (Ubuntu, Debian)：&lt;code&gt;sudo apt-get install git-core&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Linux (Fedora, Red Hat, CentOS)：&lt;code&gt;sudo yum install git-core&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Software &amp; Website" scheme="https://depp.wang/categories/Software-Website/"/>
    
    
      <category term="Git" scheme="https://depp.wang/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Linux 笔记：核心思想、常用命令以及脚本语法</title>
    <link href="https://depp.wang/2019/09/18/linux-note/"/>
    <id>https://depp.wang/2019/09/18/linux-note/</id>
    <published>2019-09-18T13:26:55.000Z</published>
    <updated>2020-06-11T13:09:39.058Z</updated>
    
    <content type="html"><![CDATA[<p>总结于 <a href="http://linux.vbird.org/linux_basic/" target="_blank" rel="noopener">《鸟哥的 Linux 私房菜 - 基础学习篇》</a> ，图片也来自于此。</p><!--可在「阅读原文」中查看其他核心笔记：如 Git 等--><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><h3 id="目录树结构（directory-tree）"><a href="#目录树结构（directory-tree）" class="headerlink" title="目录树结构（directory tree）"></a>目录树结构（directory tree）</h3><p><strong>Linux 系统是基于目录树结构的，这是它的核心思想</strong>。目录，即文件夹。Linux 系统相当于一个文件夹，Linux 系统的所有数据要么对应一个文件夹，要么就是一个文件。比如，你新建一个用户，其实就是新建了一个文件夹。一个用户对应一个文件夹。目录树结构：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135116.png" alt="图片来自《鸟哥的 Linux 私房菜 - 基础学习篇》"></p><a id="more"></a><p>上图中 <strong>长方形是文件夹</strong>， <strong>波浪形是文件</strong>，根目录是 <code>/</code> 。这个 <code>/</code> 很巧妙，在 macOS 中，假设你下载文件 test.md 到 <code>/Users/username/Desktop/</code>，那么文件会下载到桌面，最前面这个 <code>/</code> 就是根目录。如果你写成 <code>Users/username/Desktop/</code>，那么文件就会下载到<code>currentDerectory/Users/username/Desktop/</code>下。</p><p>Linux 系统使用的是目录树架构，但其实数据是存放在 <a href="https://baike.baidu.com/item/磁盘分区" target="_blank" rel="noopener">磁盘分区</a> 当中的，那么问题来了：目录树和磁盘分区是神马关系？这个时候就牵扯到一个叫「挂载（mount）」的概念了。</p><h3 id="目录树和磁盘分区的关系"><a href="#目录树和磁盘分区的关系" class="headerlink" title="目录树和磁盘分区的关系"></a>目录树和磁盘分区的关系</h3><p>挂载其实就是建立目录树和磁盘分区之间的关系。目录只是一个标识，叫什么我们可以自定义，一个磁盘分区对应一个目录。</p><p>我们经常用 U 盘，假设一个 U 盘是一个磁盘分区，我们把一个假设叫 partition1 的 U 盘插到 Windows 电脑上，可能电脑就多了个 F 盘，那么目录就是 F ，相当于将目录 F 挂载到了 U 盘上，访问 F 就可以访问 partition1 里的内容。如果再插一个假设叫 partition2 的 U 盘，系统应该就会多了一个 H 盘，相当于目录 H 就挂载到了 partition2 上。假设 F 盘下将会有一个存放很多视频的 moive 文件夹，我们可以直接将 movie 文件夹挂载到 partition2 上，这样 movie 里的视频就存到 partition2 里面了，就不占用 F 盘的空间了。</p><p>在 Linux 系统中道理也是一样的，比如在搭建 Linux 环境的时候，可以将 /home 单独挂载到一个磁盘分区上。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135121.png" alt="图片来自《鸟哥的 Linux 私房菜 - 基础学习篇》"></p><ul><li>更多内容请看鸟哥 <a href="http://linux.vbird.org/linux_basic/0130designlinux.php#partition_install" target="_blank" rel="noopener">Linux 安装模式下，磁碟分割的选择</a></li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><!--![](https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135122.jpg)--><table><thead><tr><th>命令</th><th>含义</th><th>选项</th><th>示例</th></tr></thead><tbody><tr><td></td><td></td><td><code>--help</code></td><td><code>ls --help</code></td></tr><tr><td>man</td><td>manual</td><td></td><td><code>man man</code></td></tr><tr><td>grep</td><td>file pattern searcher</td><td><code>-i, --ignore-case</code><br><code>-c, --count</code></td><td><code>grep &quot;some string&quot; &lt;file&gt;</code><br><code>grep -i &quot;some string&quot; &lt;file&gt;</code><br><code>grep -c &quot;github&quot; index.md</code> // 7</td></tr><tr><td>ls</td><td>list</td><td><code>-a, --all</code><br><code>-h, --human-readable</code><br><code>-l, --long listing format</code></td><td><code>ls -ah</code>：显示目录下所有文件夹，包括隐藏文件夹 <br> <code>ls -l</code> == <code>ll</code></td></tr><tr><td>cd</td><td>change directory</td><td></td><td><code>cd</code> 相当于 <code>cd ~</code>，<code>~</code> 当前用户根目录<br><code>cd /</code> 根目录<br><code>cd ..</code> 上一层<br><code>cd ../..</code> 上两层<br><code>cd ../&lt;directory&gt;</code> 上一层里面某个目录<br><code>cd &lt;directory&gt;/&lt;directory&gt;</code> 当前目录下的某个目录下的某个目录</td></tr><tr><td>rm</td><td>remove</td><td><code>-d, --direcorty</code><br><code>-r, --recursive</code><br><code>-f, --force</code></td><td><code>rm &lt;file&gt;</code><br><code>rm -d &lt;directory&gt;</code><br><code>rm -rf &lt;directory&gt;</code><br><code>rm *.pdf</code></td></tr><tr><td>rmdir</td><td>remove directory</td><td></td><td><code>rmdir &lt;directroy&gt;</code></td></tr><tr><td>cat</td><td>concatenate</td><td></td><td><code>cat &lt;file&gt;</code></td></tr><tr><td>mkdir</td><td>make direcotry</td><td></td><td><code>mkdir &lt;directory&gt;</code></td></tr><tr><td>touch</td><td>create a file</td><td></td><td><code>touch &lt;file&gt;</code></td></tr><tr><td>mv</td><td>move</td><td></td><td><code>mv oldname name</code><br><code>mv &lt;file&gt;/&lt;directory&gt; &lt;directory&gt;</code></td></tr><tr><td>cp</td><td>copy</td><td><code>-R</code></td><td><code>cp test test.bak</code><br><code>cp -R &lt;direction&gt; &lt;direction&gt;</code></td></tr><tr><td>pwd</td><td>print working directory</td><td></td><td><code>pwd</code></td></tr><tr><td>echo</td><td>output</td><td></td><td><code>echo &quot;some text&quot;</code></td></tr><tr><td>find</td><td>find a file or derectory</td><td></td><td><code>find path -name filename</code><br> <code>find . -name index.js</code></td></tr><tr><td>zip</td><td></td><td><code>-r, --recurse</code></td><td><code>zip -r test.zip test/</code></td></tr><tr><td>unzip</td><td></td><td></td><td><code>unzip test.zip</code></td></tr><tr><td>tar</td><td>tape or archive</td><td><code>-f, --file=ARCHIVE</code><br><code>-c, --create</code><br><code>-t, --list</code><br><code>-v, --verbose</code><br><code>-x, --extract</code><br><code>-z, --gzip, --gunzip, --ungzip</code></td><td><code>tar -cf archive.tar foo bar</code>：将文件 foo 和 bar 创建为 archive.tar<br><code>tar -tvf archive.tar</code>： 详细列出 archive.tar 中所有文件<br><code>tar -xf archive.tar</code>：从 archive.tar 中提取所有文件<br><code>tar xvzf redis-stable.tar.gz</code>：从 <code>redis-stable.tar.gz</code> 中详细提取所有文件</td></tr><tr><td>sh</td><td>run a script</td><td></td><td><code>sh test.sh</code> 相当于 <code>./test.sh</code></td></tr><tr><td>start</td><td></td><td></td><td><code>start notepad++ &lt;file&gt;</code><br><code>start Typora &lt;file&gt;</code></td></tr><tr><td>vi</td><td>visual</td><td></td><td><code>vi &lt;file&gt;</code></td></tr><tr><td>vim</td><td>vi improved</td><td></td><td><code>vim &lt;file&gt;</code></td></tr></tbody></table><p>control + w 删除输入字符</p><p>option + &lt; 像左移动</p><h3 id="vi-vim-的三种模式"><a href="#vi-vim-的三种模式" class="headerlink" title="vi/vim 的三种模式"></a>vi/vim 的三种模式</h3><p><code>vi &lt;file&gt;</code> 和 <code>vim &lt;file&gt;</code> 都是修改 <code>&lt;file&gt;</code> 的命令，后者为前者的增强版，输入此命令后，会有三种模式修改 <code>&lt;file&gt;</code> 文件。</p><ul><li>一般指令模式（command mode）：你看不见你输入的内容</li><li>编辑模式（insert mode）：直接修改文件内容</li><li>指令列命令模式（command-line mode）：最下面一行，<code>:</code> 或<code>/</code> 或 <code>?</code> 开头</li></ul><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135124.png" alt="图片来自《鸟哥的 Linux 私房菜 - 基础学习篇》"></p><ul><li>以下指令详细含义请看 <a href="http://linux.vbird.org/linux_basic/0310vi.php#vi" target="_blank" rel="noopener">vim 程式编辑器</a><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3></li></ul><ul><li>一般指令模式：</li></ul><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td>i</td><td>当前位置进入 insert 模式</td></tr><tr><td>I</td><td>第一个字符</td></tr><tr><td>a</td><td>下一个字符</td></tr><tr><td>A</td><td>末尾</td></tr><tr><td>o</td><td>下一列开头</td></tr><tr><td>O</td><td>上一列开头</td></tr><tr><td>r</td><td>Replace 模式，取代一次</td></tr><tr><td>R</td><td>一直取代</td></tr><tr><td>u</td><td>撤销</td></tr><tr><td>Ctrl + r</td><td>取消撤销，相当于 U？</td></tr><tr><td>0</td><td>行首</td></tr><tr><td>end / $</td><td>行尾</td></tr><tr><td>G</td><td>最后一列</td></tr><tr><td>gg</td><td>1 G，第一列</td></tr><tr><td>n<code>&lt;enter&gt;</code></td><td>向下移动 n 列</td></tr><tr><td>Ctrl + f</td><td>fall，向下一页</td></tr><tr><td>Ctrl + b</td><td>before，向上一页</td></tr><tr><td>x</td><td>删除</td></tr><tr><td>X</td><td>删除前一个</td></tr><tr><td>dd</td><td>删除当前列</td></tr><tr><td>d$</td><td>删除从当前位置到列尾</td></tr><tr><td>yy (yank)</td><td>复制当前列</td></tr><tr><td>p (paste)</td><td>粘贴当前列</td></tr></tbody></table><ul><li>编辑模式：</li></ul><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td>Esc</td><td>退出编辑模式，进入一般指令模式</td></tr></tbody></table><ul><li>指令列命令模式：</li></ul><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td>:w</td><td>保存</td></tr><tr><td>:w!</td><td>强制保存</td></tr><tr><td>:q</td><td>退出</td></tr><tr><td>:q!</td><td>强制退出</td></tr><tr><td>:wq</td><td>退出并保存，相当于 <code>ZZ</code></td></tr><tr><td>/word</td><td>查找关键字</td></tr><tr><td>:set nu</td><td>显示行号</td></tr><tr><td>:1,$s/word1/word2/gc</td><td>word1 替换为 word2</td></tr></tbody></table><p><code>/word</code> 查找时，可使用 n 跳转到下一个查找结果，N 跳转到上一个查找结果</p><!--## 常用快捷键 --><h2 id="脚本语法"><a href="#脚本语法" class="headerlink" title="脚本语法"></a>脚本语法</h2><ul><li>遍历。示例：一个打印出当前路径下所有文件夹的目录的脚本，名叫 <code>traverse.sh</code> ，内容如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(ls $(PWD))</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="variable">$i</span> ];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$i</span></span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="keyword">fi</span> <span class="comment"># if 反向，代表 if 结束</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>执行脚本： <code>sh traverse.sh</code></p><ul><li>更多内容请看 <a href="http://linux.vbird.org/linux_basic/0340bashshell-scripts.php" target="_blank" rel="noopener">学习 Shell Scripts</a></li></ul><!--# $(ls <dir>) == `(ls <dir>)` example: $(ls $(PWD)) == `(ls $(PWD))`--><!--# filepath=$(ls <dir>)--><!--# for i in ${filepath}--><!--# 相当于--><!--# for i in $(ls <dir>)--><h2 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 用户</span></span><br><span class="line">passwd &lt;username&gt; <span class="comment"># 修改用户的密码</span></span><br><span class="line">whoami <span class="comment"># 查看当前用户名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 日志</span></span><br><span class="line">less &lt;file&gt; <span class="comment"># 查看最新日志</span></span><br><span class="line">tail -f &lt;file&gt; <span class="comment"># 查看实时日志</span></span><br><span class="line">grep -5 &lt;key&gt; &lt;file&gt; <span class="comment"># 查看日志 &lt;file&gt; 关键字 key 上下五行</span></span><br><span class="line">grep -5 &lt;key&gt; &lt;file1&gt; &lt;file2&gt; <span class="comment"># 输出日志 &lt;file1&gt; 关键字 key 上下五行的内容到 &lt;file2&gt; 中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 进程</span></span><br><span class="line">ps -ef|grep WeChat <span class="comment"># 查看进程名叫 WeChat 的信息，最开头的数字为 id</span></span><br><span class="line"><span class="built_in">kill</span> -9 6002（最开头的数字） <span class="comment"># 杀死进程 id 为 6002 的进程</span></span><br><span class="line"></span><br><span class="line">sed -i<span class="string">'s/word1/werd2/g'</span> &lt;file&gt; <span class="comment"># 替换 &lt;file&gt; 的 word1 为 word2（sed -- stream editor）</span></span><br><span class="line">xclip -sel c &lt; &lt;file&gt; <span class="comment"># 不打开 &lt;file&gt; 的情况下复制其内容</span></span><br><span class="line">df -h <span class="comment"># 查看磁盘分区和目录信息（df -- display free disk space）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span><span class="comment"># 输出 $PATH 的内容</span></span><br><span class="line"></span><br><span class="line">sftp -i ~/.ssh/id_rsa_4 username@your_server_ip_or_remote_hostname <span class="comment"># SSH File Transfer Protocal</span></span><br><span class="line">ls / <span class="built_in">pwd</span></span><br><span class="line">lls / lpwd</span><br><span class="line">get romote_directory_filename [local_directory] <span class="comment"># get Linux 文件到本地到指定路径，不填则默认当前路径</span></span><br><span class="line">put local_directory_filename [remote] <span class="comment"># put 本地文件到 Linux</span></span><br></pre></td></tr></table></figure><!--fdisk -h # 查看磁盘挂载？--><!--fdisk -l # --><!--chmod a+w -R <path/file># chmod: change file modes，修改文件的权限--><!--scp <file> root@127.0.0.1:/opt/# 本地向 Linux 传输数据--><!--scp root@127.0.0.1:/opt/<file># Linux 向本地传输数据--><!--umount /app# 取消挂载--><!--mount /dev/vdb1 trialweg # 挂载--><!--| tail | |||--><!--| wget||||--><h2 id="Bash-VS-Zsh"><a href="#Bash-VS-Zsh" class="headerlink" title="Bash VS Zsh"></a>Bash VS Zsh</h2><blockquote><p>Bash，<a href="https://zh.wikipedia.org/wiki/Unix_shell" target="_blank" rel="noopener">Unix shell</a> 的一种，能运行于大多数 <a href="https://zh.wikipedia.org/wiki/类Unix系统" target="_blank" rel="noopener">类Unix系统</a> 的操作系统之上，包括 <a href="https://zh.wikipedia.org/wiki/Linux" target="_blank" rel="noopener">Linux</a> 与 <a href="https://zh.wikipedia.org/wiki/macOS" target="_blank" rel="noopener">macOS</a> 都将它作为默认shell。</p><p>是 <a href="https://zh.wikipedia.org/wiki/Bourne_shell" target="_blank" rel="noopener">Bourne shell</a> 的后继兼容版本与开放源代码版本，它的名称来自 <a href="https://zh.wikipedia.org/wiki/Bourne_shell" target="_blank" rel="noopener">Bourne shell</a>（sh）的一个双关语（<em>Bourne again</em> / born again）：<strong>B</strong>ourne-<strong>A</strong>gain <strong>SH</strong>ell。</p><p>Bash是一个命令处理器，通常运行于文本窗口中，并能执行用户直接输入的命令。</p><p>来自 <a href="https://zh.wikipedia.org/wiki/Bash" target="_blank" rel="noopener">Bash 维基百科</a></p></blockquote><blockquote><p><strong>Z shell</strong>（<strong>Zsh</strong>）是一款可用作 [交互式](<a href="https://zh.wikipedia.org/w/index.php?title" target="_blank" rel="noopener">https://zh.wikipedia.org/w/index.php?title</a> = 交互式 &amp; action=edit&amp;redlink=1) 登录的 [shell](<a href="https://zh.wikipedia.org/wiki/" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/</a> 殼層) 及 [脚本编写](<a href="https://zh.wikipedia.org/wiki/Shell" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Shell</a> 脚本) 的 [命令解释器](<a href="https://zh.wikipedia.org/wiki/" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/</a> 命令行界面)。Zsh 对 <a href="https://zh.wikipedia.org/wiki/Bourne_shell" target="_blank" rel="noopener">Bourne shell</a> 做出了大量改进，同时加入了 <a href="https://zh.wikipedia.org/wiki/Bash" target="_blank" rel="noopener">Bash</a>、<a href="https://zh.wikipedia.org/wiki/Korn_shell" target="_blank" rel="noopener">ksh</a> 及 <a href="https://zh.wikipedia.org/wiki/Tcsh" target="_blank" rel="noopener">tcsh</a> 的某些功能。</p><p>来自 <a href="https://zh.wikipedia.org/wiki/Z_shell" target="_blank" rel="noopener">Z shell 维基百科</a></p></blockquote><p>总结： Bash 是默认 shell，Zshl 是 Bash 的增强版。有的命令 Bash 和 Zsh 不通用，如 Bash 中的 start 命令在 Zsh 总</p><h2 id="Referen-ces"><a href="#Referen-ces" class="headerlink" title="Referen ces"></a>Referen ces</h2><ul><li><a href="https://www.geeksforgeeks.org/linux-commands/" target="_blank" rel="noopener">Linux Commands</a></li><li><a href="https://medium.com/better-programming/here-are-11-console-commands-every-developer-should-know-54e348ef22fa" target="_blank" rel="noopener">Here Are 11 Console Commands Every Developer Should Know</a></li><li><a href="http://man.he.net/" target="_blank" rel="noopener">LINUX MAN PAGES ONLINE</a></li><li><a href="https://stackoverflow.com/questions/36121672/set-table-column-width-via-markdown" target="_blank" rel="noopener">Set table column width via Markdown</a></li><li><a href="https://www.rapidtables.com/code/linux/linux-current-directory.html" target="_blank" rel="noopener">How to get current working directory</a></li><li><a href="https://linuxhint.com/bash_loop_list_strings/" target="_blank" rel="noopener">Bash Loop Through a List of Strings</a></li><li><a href="https://unix.stackexchange.com/questions/211817/copy-the-contents-of-a-file-into-the-clipboard-without-displaying-its-contents" target="_blank" rel="noopener">Copy the contents of a file into the clipboard without displaying its contents</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结于 &lt;a href=&quot;http://linux.vbird.org/linux_basic/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《鸟哥的 Linux 私房菜 - 基础学习篇》&lt;/a&gt; ，图片也来自于此。&lt;/p&gt;
&lt;!--可在「阅读原文」中查看其他核心笔记：如 Git 等--&gt;

&lt;h2 id=&quot;核心思想&quot;&gt;&lt;a href=&quot;#核心思想&quot; class=&quot;headerlink&quot; title=&quot;核心思想&quot;&gt;&lt;/a&gt;核心思想&lt;/h2&gt;&lt;h3 id=&quot;目录树结构（directory-tree）&quot;&gt;&lt;a href=&quot;#目录树结构（directory-tree）&quot; class=&quot;headerlink&quot; title=&quot;目录树结构（directory tree）&quot;&gt;&lt;/a&gt;目录树结构（directory tree）&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Linux 系统是基于目录树结构的，这是它的核心思想&lt;/strong&gt;。目录，即文件夹。Linux 系统相当于一个文件夹，Linux 系统的所有数据要么对应一个文件夹，要么就是一个文件。比如，你新建一个用户，其实就是新建了一个文件夹。一个用户对应一个文件夹。目录树结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135116.png&quot; alt=&quot;图片来自《鸟哥的 Linux 私房菜 - 基础学习篇》&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://depp.wang/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://depp.wang/tags/Linux/"/>
    
  </entry>
  
</feed>
