<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DeppWang&#39;s Blog</title>
  
  <subtitle>这是副标题</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://depp.wang/"/>
  <updated>2020-04-10T13:36:08.719Z</updated>
  <id>https://depp.wang/</id>
  
  <author>
    <name>DeppWang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>你真的会写单例模式吗</title>
    <link href="https://depp.wang/2020/04/10/singleton-pattern/"/>
    <id>https://depp.wang/2020/04/10/singleton-pattern/</id>
    <published>2020-04-10T08:09:37.000Z</published>
    <updated>2020-04-10T13:36:08.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="你真的会写单例模式吗"><a href="#你真的会写单例模式吗" class="headerlink" title="你真的会写单例模式吗"></a>你真的会写单例模式吗</h2><blockquote><p>人生在世，谁不面试。单例模式：一个搞懂不加分，不搞懂减分的知识点</p></blockquote><p>又一篇一抓一大把的博文，可是你真的的搞懂了吗？点开看看。。事后，你也来一篇。</p><p>单例模式是面试中非常喜欢问的了，我们往往自认为已经完全理解了，没什么问题了。但要把它手写出来的时候，可能出现各种小错误，下面是我总结的快速准确的写出单例模式的方法。</p><p>单例模式有各种写法，什么「双重检锁法」、什么「饿汉式」、什么「饱汉式」，总是记不住、分不清。这就对了，人的记忆力是有限的，我们应该记的是最基本的单例模式怎么写。</p><p>单例模式：一个类有且只能有一个对象（实例）。单例模式的 3 个要点：</p><ol><li>外部不能通过 new 关键字（构造函数）的方式新建对象，所以构造函数为私有：<code>private Singleton(){}</code></li><li>只能通过类方法获取对象，所以获取对象的方法为公有、且为静态：<code>public static Singleton getInstance()</code></li><li>对象只能有一个，那只能作为类变量的「数据」，类变量为静态 （另一种记忆：静态方法只能使用静态变量）：<code>private static Singleton instance</code></li></ol><a id="more"></a><h2 id="最基础、最简单的写法"><a href="#最基础、最简单的写法" class="headerlink" title="最基础、最简单的写法"></a>最基础、最简单的写法</h2><p>类加载的时候就新建实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Singleon using static initialization in Java"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here is how to access this Singleton class</span></span><br><span class="line">Singleton.getInstance().show();</span><br></pre></td></tr></table></figure><p>当执行 Singleton.getInstance() 时，类加载器加载 Singleton.class 进虚拟机，虚拟机在方法区（元数据区）为类变量分配一块内存，并赋值为空。再执行 <code>&lt;client&gt;()</code> 方法，新建对象指向类变量 instance。这个过程在类加载阶段执行，并由虚拟机保证线程安全。所以执行 getInstance() 前，对象就已经存在，所以 getInstance() 是线程安全的。</p><p>很多博文说 instance 还需要声明为 final，其实不用。final 的作用在于不可变，使引用 instance 不能指向另一个对象，这里用不上。当然，加上也没问题。</p><!--// final 修饰的基本数据类型，在编译期时，初始化数据放在常量池--><p>这个写法有一个不足之处，就是如果需要通过参数设置对象，则无法做到。举个栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能设置 name！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Singleon using static initialization in Java"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here is how to access this Singleton class</span></span><br><span class="line">Singleton.getInstance(String name).show();</span><br></pre></td></tr></table></figure><h2 id="可通过参数设置对象的写法"><a href="#可通过参数设置对象的写法" class="headerlink" title="可通过参数设置对象的写法"></a>可通过参数设置对象的写法</h2><p>考虑到这种情况，就在调用 getInstance() 方法时，再新建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton.getInstance(String name).show();</span><br></pre></td></tr></table></figure><p>这里加了 <code>synchronized</code> 关键字，能保证只会生成一个实例，但效率不高。因为对象创建成功后，再获取对象时就不用加锁了。</p><p>当不加 synchronized 时，会发生什么：</p><p>instance 是类的变量，类存放在方法区（元数据区），元数据区线程共享，所以类变量 instance 线程共享，类变量也是在主内存中。线程执行 getInstance() 时，在自己工作内存新建一个栈帧，将主内存的 instance 拷贝到工作内存。多个线程并发访问时，都认为 <code>instance == null</code>，就将新建多个实例，那单例模式就不是单例模式了。</p><h2 id="改良版加锁的写法"><a href="#改良版加锁的写法" class="headerlink" title="改良版加锁的写法"></a>改良版加锁的写法</h2><p>实现只在创建的时候加锁，获取时不加锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么要判断两次：</strong></p><p>多个线程将 instance 拷贝进工作内存，即多个线程读取到 instance == null，虽然每次只有一个线程进入 synchronized 方法，当进入线程成功新建了实例，synchronized 保证了可见性（在 unlock 操作前将变量写回了主内存），此时 instance 不等于 null 了，但其他线程已经执行到 synchronized 这里了，某个线程就又会进入 synchronized 方法，如果不判断一次，又会再次新建一个实例。</p><p><strong>为什么要用 volatile 修饰 instance：</strong></p><p>synchronized 可以实现原子性、可见性、有序性。其中实现原子性：一次只有一个线程执行同步块的代码。但计算机为了提升运行效率，会指令重排序。</p><p>代码 instance = new Singleton(); 会被拆为 3 步执行。</p><ul><li>A：分配一块内存空间</li><li>B：在内存空间位置新建一个实例</li><li>C：将引用指向实例，即，引用存放实例的内存空间地址</li></ul><p>如果 instance 都在 synchronized 里面，那么没啥问题，问题出现在 instance 在 synchronized 外边，因为此时外边一群饿狼（线程），就在等待一个 instance 这块肉不为 null。</p><p>模拟一下指令重排序的出错场景：多线程环境下，正好一个线程，在同步块中按 ACB 执行，执行到 AC 时（并将 instance 写回了主内存），另一个线程执行第一个判断时，认为 instance 不为空，返回 instance，但此时 instance 还没被正确初始化，所以出错。</p><p>当 instance 被 volatile 修饰时，只有 ACB 执行完了之后，其他线程才能读取 instance</p><p>为什么 volatile 能禁止指令重排序：它在 ACB 后添加一个 lock 指令，lock 指令之前的操作执行完成后，后面的操作才能执行</p><p>你可能认为上面的解释太复杂，理解不了。对，确实比较复杂，我也搞了很久才搞明白。你可以看看这个是不是更好理解，Java 虚拟机规范的其中一条先行发生原则：对 volatile 修饰的变量，读操作，必须等写操作完成。</p><h2 id="其他非主流写法"><a href="#其他非主流写法" class="headerlink" title="其他非主流写法"></a>其他非主流写法</h2><p>枚举写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EasySingleton&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当面试官让我写一个单例模式，我总是觉得写这个好像有点另类</p><p>静态内部类写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE; </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>单例模式主要为了节省内存开销，Spring 容器的 Bean 就是通过单例模式创建出来的。</p><h1 id="单例模式没写出来，那也没啥事，因为那下一个问题你也不一定能答出来-。"><a href="#单例模式没写出来，那也没啥事，因为那下一个问题你也不一定能答出来-。" class="headerlink" title="单例模式没写出来，那也没啥事，因为那下一个问题你也不一定能答出来 :)。"></a>单例模式没写出来，那也没啥事，因为那下一个问题你也不一定能答出来 :)。</h1><blockquote><p>你以为文章是写给别看的，其实是写给自己看的。哈哈</p></blockquote><h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul><li><a href="http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/" target="_blank" rel="noopener">如何正确写出单例模式</a></li><li><a href="http://javarevisited.blogspot.com/2012/12/how-to-create-thread-safe-singleton-in-java-example.html" target="_blank" rel="noopener">How to create thread safe Singleton in Java</a></li><li><a href="https://javarevisited.blogspot.com/2012/07/why-enum-singleton-are-better-in-java.html" target="_blank" rel="noopener">Why Enum Singleton are better in Java</a></li><li><a href="https://stackoverflow.com/questions/228164/on-design-patterns-when-should-i-use-the-singleton" target="_blank" rel="noopener">On design patterns: When should I use the singleton? </a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;你真的会写单例模式吗&quot;&gt;&lt;a href=&quot;#你真的会写单例模式吗&quot; class=&quot;headerlink&quot; title=&quot;你真的会写单例模式吗&quot;&gt;&lt;/a&gt;你真的会写单例模式吗&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;人生在世，谁不面试。单例模式：一个搞懂不加分，不搞懂减分的知识点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;又一篇一抓一大把的博文，可是你真的的搞懂了吗？点开看看。。事后，你也来一篇。&lt;/p&gt;
&lt;p&gt;单例模式是面试中非常喜欢问的了，我们往往自认为已经完全理解了，没什么问题了。但要把它手写出来的时候，可能出现各种小错误，下面是我总结的快速准确的写出单例模式的方法。&lt;/p&gt;
&lt;p&gt;单例模式有各种写法，什么「双重检锁法」、什么「饿汉式」、什么「饱汉式」，总是记不住、分不清。这就对了，人的记忆力是有限的，我们应该记的是最基本的单例模式怎么写。&lt;/p&gt;
&lt;p&gt;单例模式：一个类有且只能有一个对象（实例）。单例模式的 3 个要点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;外部不能通过 new 关键字（构造函数）的方式新建对象，所以构造函数为私有：&lt;code&gt;private Singleton(){}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;只能通过类方法获取对象，所以获取对象的方法为公有、且为静态：&lt;code&gt;public static Singleton getInstance()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;对象只能有一个，那只能作为类变量的「数据」，类变量为静态 （另一种记忆：静态方法只能使用静态变量）：&lt;code&gt;private static Singleton instance&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java" scheme="https://depp.wang/categories/Java/"/>
    
    
      <category term="Singleton Pattern" scheme="https://depp.wang/tags/Singleton-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>随意修改你文章的 url 吧，一个 js 解决原 url 不能访问的问题</title>
    <link href="https://depp.wang/2020/03/27/redirect-404-url-by-js/"/>
    <id>https://depp.wang/2020/03/27/redirect-404-url-by-js/</id>
    <published>2020-03-27T20:48:37.000Z</published>
    <updated>2020-04-10T13:36:08.719Z</updated>
    
    <content type="html"><![CDATA[<p>作者：<a href="https://depp.wang">DeppWang</a></p><p>阅读提示：此文适用于有自己博客的同学。</p><p>昨天在公众号分享了一篇在 <a href="https://depp.wang/2020/03/26/how-to-insert-slide-in-markdown/">如何在 Markdown 里面插入幻灯片</a>的文章，微信公众号由于平台限制，幻灯片只能在原文里面才能看到效果，不巧，原文链接手误写错了一个单词，本来是 insert，写成了 inset。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">https</span>://depp.wang/<span class="number">2020</span>/<span class="number">03</span>/<span class="number">26</span>/how-<span class="built_in">to</span>-inset-slide-<span class="keyword">in</span>-markdown/</span><br><span class="line">应该是</span><br><span class="line"><span class="keyword">https</span>://depp.wang/<span class="number">2020</span>/<span class="number">03</span>/<span class="number">26</span>/how-<span class="built_in">to</span>-insert-slide-<span class="keyword">in</span>-markdown/</span><br></pre></td></tr></table></figure><p>作为一个强迫症患者，不能忍受这样的问题。可一旦我修改了原文链接，公众号这边要么删了重发，要么来个留言，说原文链接已经修改。两种方式可以解决问题，但是不爽。</p><p>除了像我手误写错链接单词的情况，<strong>很多时候，我们文章修改题目后，如果想修改 url（url 是文章题目的英文），就会面临原 url 失效的问题。</strong></p><p>如果你也有上面这种困扰，那么可以看看我的解决思路。</p><a id="more"></a><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>我的思路是这样：自定义一个 404 页面，链接失效就显示 404 页面，404 页面引入一个重定向指定 url 的 js。</p><p>重定向指定 url 的 js 的代码很简单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">redirectUrl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> redirectObj = &#123;</span><br><span class="line">        <span class="string">"https://depp.wang/2020/03/26/how-to-inset-slide-in-markdown/"</span>: <span class="string">"https://depp.wang/2020/03/26/how-to-insert-slide-in-markdown/"</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> newUrl = redirectObj[<span class="built_in">window</span>.location.href];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> newUrl !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="built_in">window</span>.location = newUrl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">redirectUrl();</span><br></pre></td></tr></table></figure><ul><li>此 js 使用条件：显示 404 页面时，原 url 不变，不能是重定向到 404 页面</li></ul><p>404 页面引入 js，404 页面可以用<a href="https://www.qq.com/404/" target="_blank" rel="noopener">腾讯公益 404 页面</a>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--404.html--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-type"</span> <span class="attr">content</span>=<span class="string">"text/html;charset=utf-8;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge,chrome=1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"robots"</span> <span class="attr">content</span>=<span class="string">"all"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"robots"</span> <span class="attr">content</span>=<span class="string">"index,follow"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"https://qzone.qq.com/gy/404/style/404style.css"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"https://depp.wang/redirectUrl.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> // 此处修改为你自己的 js 地址</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/plain"</span> <span class="attr">src</span>=<span class="string">"http://www.qq.com/404/search_children.js"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">charset</span>=<span class="string">"utf-8"</span> <span class="attr">homePageUrl</span>=<span class="string">"/"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">homePageName</span>=<span class="string">"回到主页"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://qzone.qq.com/gy/404/data.js"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://qzone.qq.com/gy/404/page.js"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>代码来源：<a href="http://theme-next.iissnan.com/theme-settings.html#volunteer-404" target="_blank" rel="noopener">http://theme-next.iissnan.com/theme-settings.html#volunteer-404</a></li><li>如果你使用 <a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">Hexo </a>+ <a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="noopener">Next</a>，注意 404.html 放在主题的 source 目录下。</li></ul><p>引入 js 代码时要注意路径，最好直接使用绝对路径。使用相对路径要考虑原文章所在路径与 js 文件路径之间的关联。</p><p>多说一嘴，相对路径有时候有点不好理解，需要理解相对路径常用两个符号 <code>.</code> 和 <code>..</code> 的含义：</p><ul><li><code>.</code>：一个点代表当前文件所在的文件夹（路径）。在 Linux 中，复制文件到当前路径的命令：<code>cp **/test.md .</code>。示例：<code>src=&quot;./redirectUrl.js&quot;</code>，代表引入和当前文件在同一个文件夹的 redirectUrl.js</li><li><code>..</code>：两个点代表当前文件所在的上一层文件夹（路径）。在 Linux 中，切换到上一层的命令： <code>cd ..</code></li></ul><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-27-074330.gif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者：&lt;a href=&quot;https://depp.wang&quot;&gt;DeppWang&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;阅读提示：此文适用于有自己博客的同学。&lt;/p&gt;
&lt;p&gt;昨天在公众号分享了一篇在 &lt;a href=&quot;https://depp.wang/2020/03/26/how-to-insert-slide-in-markdown/&quot;&gt;如何在 Markdown 里面插入幻灯片&lt;/a&gt;的文章，微信公众号由于平台限制，幻灯片只能在原文里面才能看到效果，不巧，原文链接手误写错了一个单词，本来是 insert，写成了 inset。&lt;/p&gt;
&lt;figure class=&quot;highlight livecodeserver&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;https&lt;/span&gt;://depp.wang/&lt;span class=&quot;number&quot;&gt;2020&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;03&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;26&lt;/span&gt;/how-&lt;span class=&quot;built_in&quot;&gt;to&lt;/span&gt;-inset-slide-&lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;-markdown/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;应该是&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;https&lt;/span&gt;://depp.wang/&lt;span class=&quot;number&quot;&gt;2020&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;03&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;26&lt;/span&gt;/how-&lt;span class=&quot;built_in&quot;&gt;to&lt;/span&gt;-insert-slide-&lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;-markdown/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;作为一个强迫症患者，不能忍受这样的问题。可一旦我修改了原文链接，公众号这边要么删了重发，要么来个留言，说原文链接已经修改。两种方式可以解决问题，但是不爽。&lt;/p&gt;
&lt;p&gt;除了像我手误写错链接单词的情况，&lt;strong&gt;很多时候，我们文章修改题目后，如果想修改 url（url 是文章题目的英文），就会面临原 url 失效的问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你也有上面这种困扰，那么可以看看我的解决思路。&lt;/p&gt;
    
    </summary>
    
      <category term="Software &amp; Website" scheme="https://depp.wang/categories/Software-Website/"/>
    
    
      <category term="URL" scheme="https://depp.wang/tags/URL/"/>
    
  </entry>
  
  <entry>
    <title>如何在 Markdown 里面插入幻灯片</title>
    <link href="https://depp.wang/2020/03/26/how-to-insert-slide-in-markdown/"/>
    <id>https://depp.wang/2020/03/26/how-to-insert-slide-in-markdown/</id>
    <published>2020-03-26T20:48:37.000Z</published>
    <updated>2020-04-10T13:36:08.719Z</updated>
    
    <content type="html"><![CDATA[<p>作者：<a href="https://depp.wang">DeppWang</a></p><p><strong>效果示例</strong>：</p><script async class="speakerdeck-embed" data-id="9780d352c95f4361bd8c6fa164554afc" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script><ul><li>幻灯片来自：<a href="https://deepu.tech/memory-management-in-jvm/" target="_blank" rel="noopener">https://deepu.tech/memory-management-in-jvm/</a></li></ul><a id="more"></a><p><strong>使用前提</strong>：博客（网站）使用可渲染 js 脚本的 markdown 解析器，如 hexo 静态博客。我测试了一下，掘金、博客园等将 markdown 转换（解析）为 html 时，会忽略幻灯片 js 脚本。</p><p><strong>原理</strong>：在网页中内嵌一个 js 脚本。</p><p><strong>步骤</strong>： </p><ol><li>将多个图片转换为一个 PDF，可使用 <a href="https://smallpdf.com/jpg-to-pdf" target="_blank" rel="noopener">Smallpdf</a> 转换。pdf 示例：<a href="https://drive.google.com/file/d/1RJ3j2F5hh4oR-RWOBRNI5DJCcT6Oh2VE/view?usp=sharing" target="_blank" rel="noopener">presentation.pdf</a></li><li>在  <a href="https://speakerdeck.com/" target="_blank" rel="noopener">Speaker Deck</a> 上传 PDF，生成<a href="https://speakerdeck.com/deppwang/google-drive-presentation" target="_blank" rel="noopener">幻灯片</a>，点击分享按钮，获取幻灯片可内嵌（Embed）到 markdown 的 js 脚本</li><li>在 markdown 粘贴 js 脚本即可</li></ol><p><strong>js 脚本</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">class</span>=<span class="string">"speakerdeck-embed"</span> <span class="attr">data-id</span>=<span class="string">"69f38a5da6a64b4086368afca27bc7e1"</span> <span class="attr">data-ratio</span>=<span class="string">"1.77777777777778"</span> <span class="attr">src</span>=<span class="string">"//speakerdeck.com/assets/embed.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>最终效果</strong>：</p><script async class="speakerdeck-embed" data-id="69f38a5da6a64b4086368afca27bc7e1" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者：&lt;a href=&quot;https://depp.wang&quot;&gt;DeppWang&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;效果示例&lt;/strong&gt;：&lt;/p&gt;
&lt;script async class=&quot;speakerdeck-embed&quot; data-id=&quot;9780d352c95f4361bd8c6fa164554afc&quot; data-ratio=&quot;1.77777777777778&quot; src=&quot;//speakerdeck.com/assets/embed.js&quot;&gt;&lt;/script&gt;

&lt;ul&gt;
&lt;li&gt;幻灯片来自：&lt;a href=&quot;https://deepu.tech/memory-management-in-jvm/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://deepu.tech/memory-management-in-jvm/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Markdown" scheme="https://depp.wang/categories/Markdown/"/>
    
    
      <category term="幻灯片" scheme="https://depp.wang/tags/%E5%B9%BB%E7%81%AF%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>互联网协议入门</title>
    <link href="https://depp.wang/2020/03/20/internet-protocol-suite-introduction/"/>
    <id>https://depp.wang/2020/03/20/internet-protocol-suite-introduction/</id>
    <published>2020-03-20T20:48:37.000Z</published>
    <updated>2020-04-10T13:36:08.719Z</updated>
    
    <content type="html"><![CDATA[<p>作者：<a href="https://depp.wang">DeppWang</a></p><p>互联网上的数据能从一台设备发送到另一台设备，整个过程由<a href="https://zh.wikipedia.org/wiki/TCP/IP协议族" target="_blank" rel="noopener">互联网协议</a>（ Internet Protocol Suite）实现的。 </p><p>对于互联网协议，一直一知半解。知道会分为几层，但为什么分层，分层有什么好处，都不甚理解。通过<a href="www.ruanyifeng.com">阮一峰</a>的这两篇文章，大概有了一个初步认识，下面是我对互联网协议的理解。</p><ul><li><a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="noopener">互联网协议入门（一）<em>阮一峰</em></a></li><li><a href="http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html" target="_blank" rel="noopener">互联网协议入门（二）<em>阮一峰</em></a></li></ul><a id="more"></a><!--一直以来的疑惑：--><!--为什么说 Dubbo 基于 TCP 协议，Spring Cloud 基于 HTTP 协议？难道 Spring Cloud 就没有使用应用层吗？HTTP 协议没有用到 TCP 协议吗（没有经过传输层吗）？怎么好像两者是并列的关系。为什么基于 TCP 协议的 Dubbo 就更快一些呢？--><!--一个打开网页的请求如何从客户端发送到服务端，并接受到请求的，其请求包是格式是怎样的。--><!--对于手机来说，这几层体现在哪里？或者说是哪个软件实现这几层的？--><h2 id="一、五层模型"><a href="#一、五层模型" class="headerlink" title="一、五层模型"></a>一、五层模型</h2><p>我也认为将互联网协议分为五层，可以更好的去理解它，从上往下分别是：应用层、传输层、网络层、（数据）链路层（链接层）和物理层（实体层）。如果死记硬背，往往过几天就忘了，所以需要了解其原理，当我们理解了全文，让我们去说文章的名字，那还不是轻而易举吗！</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-16-091651.png" alt="图片来自阮一峰博客"></p><p>大多数文章或书籍都是从上往下来讲解互联网协议，但是个人感觉总是没有深入其理，阮一峰<strong>自下而上</strong>的讲解每一层的功能，让人记忆深刻。我也依葫芦画瓢，先自下而上分析一下每一层的功能，再结合 <a href="https://www.wireshark.org/" target="_blank" rel="noopener">Wireshark</a> 抓包工具，来稍稍看看互联网协议的真面目。</p><h3 id="1-1-层与协议"><a href="#1-1-层与协议" class="headerlink" title="1.1 层与协议"></a>1.1 层与协议</h3><p>为什么叫某某层？为什么要分层？层是什么？</p><p>我觉得层这个叫法很形象，一层一层，好像平行，各自独立。维基百科的解释是：「<strong>整个通信网络的任务，可以划分成不同的功能区块，即所谓的层级（<a href="https://zh.wikipedia.org/w/index.php?title=Layer&action=edit&redlink=1" target="_blank" rel="noopener">layer</a>）</strong>」，我们可以理解为，每一层是实现了一个功能，有不同的分工。就跟写代码一样，如果把所有功能放一起，改一行代码就可能影响全部，所以根据不同功能拆成不同的方法。我觉得叫什么不重要，可以叫应用块、应用组，等等。<strong>主要知道，每一层是为了完成一个功能就行。</strong></p><p>我们知道，每一层都有自己对应的协议（Protocol），比如，网络层有 IP 协议。那何为协议？跟这个层又有什么关联？维基百科上有这么一句话：「网络层功能由 IP 协议规定和实现，故又称 IP 层」。我们可以看出，每一层的功能其实是协议来规定和实现的。所以，协议可以理解为，<strong>有大家都遵守的规则（规定），并负责去实现这个规则。</strong></p><h2 id="二、物理层（Physcial-Layer）"><a href="#二、物理层（Physcial-Layer）" class="headerlink" title="二、物理层（Physcial Layer）"></a>二、物理层（Physcial Layer）</h2><p>我们电脑现在不用插网线就能上网（连 WIFI），但是路由器插网线了，在家里，路由器一般又需要通过一根网线连接入户光纤盒（又称为光猫），光纤盒又需要通过一根光纤连接到其他设备。电脑连接 WiFi，电脑的数据发送到路由器，是通过无线电波。所以传输数据需要物理载体，类似网线、光纤、无线电波。<strong>我们将传输数据的物理载体称为物理层（Physcial Layer）</strong>。为什么我们访问美国的网站就慢一些，因为美国网站的服务器在美国，数据通过海底光缆传输，耗时会久一些。这也是为什么很多公司要在不同城市部署服务器的原因之一吧。</p><p>数据在物理载体中传输，传输的是什么呢？<strong>是 0 和 1 组成的电信号</strong>，为什么是 0 和 1 组成的电信号呢？这个吧，姑且通过类比的方式来解释，因为计算机只能识别 0 1 二进制，所以要传输 0 和 1 组成的电信号吧。</p><!--问好脸：网速的快慢由每 1 秒能传输电信号的多少决定？--><h2 id="三、链路层（Link-Layer）"><a href="#三、链路层（Link-Layer）" class="headerlink" title="三、链路层（Link Layer）"></a>三、链路层（Link Layer）</h2><p>物理层只是一个传输载体，没有「自主意识」， 我们需要借助物理层上的<a href="https://zh.wikipedia.org/wiki/数据链路层" target="_blank" rel="noopener">链路层</a>（Link Layer），<strong>链路层的功能：将数据从一处发送到另一处</strong>，链路层在发送方和接收方都有，在发送方：链路层将数据转换为电信号，并将其发送出去；在接收方：链路层收到电信号，并将电信号转换为数据。链路层和物理层之间的关系可以这样表示：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-131628.jpg" alt=""></p><p>在<a href="https://zh.wikipedia.org/wiki/局域网" target="_blank" rel="noopener">局域网</a>内，将数据从一处发送到另一处需要使用<a href="https://zh.wikipedia.org/wiki/以太网" target="_blank" rel="noopener">以太网</a>（Ethernet）。<strong>局域网的通俗理解，连接同一个 <a href="https://zh.wikipedia.org/wiki/Wi-Fi" target="_blank" rel="noopener">WiFi</a> （路由器 Router）的设备在同一个局域网内。</strong></p><h3 id="3-1-以太网"><a href="#3-1-以太网" class="headerlink" title="3.1 以太网"></a>3.1 以太网</h3><p>以太网是一种局域网技术，它可以实现局域网内的设备通信，我们现在电脑一般连 WiFi，WiFi 可以认为是「无线以太网」。</p><p>我们可以理解为，<strong>在局域网内，链路层的功能其实是由以太网实现的</strong>（局域网外的链路层比较复杂，本文不讨论）。 局域网内的链路层和以太网的关系可以这样表示（物理层作为以太网的传输载体）：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-121930.jpg" alt=""></p><p><strong>以太网需要规定电信号的格式，以便双方解读</strong>。以太网规定一组电信号为一个数据包，叫帧（Frame），帧包含两部分，标头（Head）和数据（Data），标头包含发送方地址、接收方地址等信息，数据则是数据包的具体内容。我们一般将帧称为以太网数据包，或者<a href="https://zh.wikipedia.org/wiki/以太网帧格式" target="_blank" rel="noopener">以太帧</a>，以太帧格式类似下面这样：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-17-065355.png" alt="以太帧，图片来自阮一峰博客"></p><p>每台网络设备都有自己的网卡，<strong>以太网是将数据从一块<a href="https://zh.wikipedia.org/wiki/网卡" target="_blank" rel="noopener">网卡</a>发送到另一块网卡</strong>，每块网卡需要有自己的「身份证号」，叫 <a href="https://zh.wikipedia.org/wiki/MAC地址" target="_blank" rel="noopener">MAC 地址</a>（iPhone 手机的 MAC 地址叫无线局域网地址），由 12 个十六进制数表示：</p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-121841.jpg" style="zoom:50%;"><blockquote><p>MAC地址：（<strong>M</strong>edia <strong>A</strong>ccess <strong>C</strong>ontrol Address），直译为媒体存取控制位址，也称为局域网地址（LAN Address），<strong>以太网地址</strong>（Ethernet Address）或<strong>物理地址</strong>（Physical Address），它是一个用来确认网络设备位置的地址。</p></blockquote><p>所以以太网发送前需要知道接收方网卡的 MAC 地址，即标头的接收方地址，但正常情况下，不知道接收方 MAC 地址，需要使用 <a href="https://zh.wikipedia.org/wiki/地址解析协议" target="_blank" rel="noopener">ARP 协议</a>得到（这个本文后面解释）</p><p>假设已经知道了 MAC 地址，那么在局域网内，以太网可以根据 MAC 地址，将数据发送给对方。但如果对方没有在一个局域网内，如何发送给对方呢？此时，就需要<a href="https://zh.wikipedia.org/wiki/网络层" target="_blank" rel="noopener">网络层</a>（Network Layer）出马了！</p><hr><p>以太网在 Windows 中的体现：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-123642.jpg" alt=""></p><p>在 macOS 的体现： <a href="https://zh.wikipedia.org/wiki/PPPoE" target="_blank" rel="noopener">PPPoE</a>（英语：<strong>P</strong>oint-to-<strong>P</strong>oint <strong>P</strong>rotocol <strong>o</strong>ver <strong>E</strong>thernet），以太网上的点对点协议。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-123706.jpg" alt=""></p><h2 id="四、网络层（Network-Layer）"><a href="#四、网络层（Network-Layer）" class="headerlink" title="四、网络层（Network Layer）"></a>四、网络层（Network Layer）</h2><p>首先，我们要区分接收方是否在一个局域网，使用 MAC 地址不能区分，需要设备有另外一个地址，能代表它所处的具体是哪个网络（局域网），我们称这个地址为「<strong>网络地址</strong>」。</p><p><strong>网络层的作用，就是根据网络地址找到目的主机处于哪一个局域网</strong>。实现这一功能的协议称为网络协议，即 <a href="https://zh.wikipedia.org/wiki/网际协议" target="_blank" rel="noopener">IP 协议</a> 。网络地址用于 IP 协议，所以网络地址也可以叫它 IP 地址。<strong>注意</strong>：我们叫 IP 协议，是一种习惯，其实 IP(<strong>I</strong>nternet <strong>P</strong>rotocol) 本身就有协议的意思。</p><!--如果设备连 WiFi，WiFi 是局域网，路由器会为设备分配一个局域网 IP 地址，它只能在局域网内部使用，所以也叫内部（本地） IP。局域网有一个对外访问互联网的 IP，称为外部 IP，**一个局域网内的所有设备共用一个外部 IP 地址**。在百度输入IP，显示的 IP 就是外部 IP，在「设置->网络」中看到的 IP 是内部 IP。我们称局域网为内网，内是相对的概念，代表没有外部 IP 就不能访问。--><p>如果设备连 WiFi，路由器会为设备分配一个 IP 地址。</p><h3 id="4-1-IP-协议"><a href="#4-1-IP-协议" class="headerlink" title="4.1 IP 协议"></a>4.1 IP 协议</h3><blockquote><p><strong>IP</strong> 协议：英语全称为：<strong>I</strong>nternet <strong>P</strong>rotocol，即<strong>网络协议</strong>，也称<strong>网际协议</strong>。</p></blockquote><p>现在大部分使用的还是 IP 协议第四版，简称 IPv4，IP 地址为 32 位（4*8，二进制）。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052908.png" alt="图片来自阮一峰博客"></p><p>有了 IP 地址，网络层可以通过 IP 地址来区分是否处于一个局域网。如何根据 IP 地址判断设备是否处于同一个局域网？答案是利用<a href="https://zh.wikipedia.org/wiki/子网#网络掩码" target="_blank" rel="noopener">子网掩码</a>。IP 地址分为两部分，网络部分和主机部分，如果子网掩码为 <code>255.255.255.0</code>（二进制表示：<code>11111111.11111111.11111111.00000000</code>），表示前 24 位代表网络部分，如果两个 IP 地址前 24 位相同，则代表是在同一个局域网中。</p><h3 id="4-2-IP-数据包"><a href="#4-2-IP-数据包" class="headerlink" title="4.2 IP 数据包"></a>4.2 IP 数据包</h3><p>数据经过网络层，IP 协议为数据加上包含发送方 IP 地址和接收方 IP 地址的标头，包装为 IP 数据包：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-17-134735.png" alt="图片来自阮一峰博客"></p><p>IP 数据包到达链路层时，直接作为作为以太帧的数据部分，嵌入以太帧。此时的以太帧的格式如下：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-17-134810.png" alt="图片来自阮一峰博客"></p><p>如果通过子网掩码判断接收方在一个局域网，就通过以太网发送，此时需要得到其 MAC 地址，前面说，需要 ARP 协议得到其 MAC 地址，何为 ARP 协议？</p><h3 id="4-3-ARP-协议"><a href="#4-3-ARP-协议" class="headerlink" title="4.3 ARP 协议"></a>4.3 ARP 协议</h3><p>ARP 协议，英语全称为：<strong>A</strong>ddress <strong>R</strong>esolution <strong>P</strong>rotocol，即地址解析协议，是一种通过 IP 地址得到 MAC 地址的协议。默认情况，发送方知道接收方的 IP 地址（通过 <a href="https://zh.wikipedia.org/wiki/域名系统" target="_blank" rel="noopener">DNS</a> 得到，这个又后面解释），所以发送方使用「广播」（broadcasting）的方式给当前局域网所有主机发送一个以太帧，包含对方的 IP 地址，对方 MAC 地址设为 <code>ff:ff:ff:ff:ff:ff</code>，接收方根据接收者 IP 地址判断自己是否为接收者，是，就发送一个数据包告诉对方自己的 MAC 地址，不是，就丢弃这个包。</p><p>通过这种方式，发送方就可以通过接收方的 IP 地址得到 MAC 地址。</p><p>如果通过子网掩码判断接收方不在一个局域网，通过 APR 协议就得不到对方的 MAC 地址，那就要使用<a href="https://zh.wikipedia.org/wiki/路由" target="_blank" rel="noopener">路由</a>（Route）的方式发送了。</p><h3 id="4-4-路由"><a href="#4-4-路由" class="headerlink" title="4.4 路由"></a>4.4 路由</h3><p>路由，简单来说，就是得到路由器的 MAC 地址，数据先发送到<a href="https://zh.wikipedia.org/wiki/路由器" target="_blank" rel="noopener">路由器</a>（Router），由路由器来发送下一个路由器，通过一系列路由中转，最后发给目标主机。</p><!--路由器往外发送时，使用的是外部 IP（互联网 IP）。使用外部 IP 才能和互联网通信，外部 IP 是名片--><p>其实就像发送快递一样，在快递上写上收件人的地址，由快递点发送给下一个中转站，再中转，最后收件人收到快递。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-030924.png" alt=""></p><p>一个简单的路由器，需要实现 IP 协议和链路层协议。</p><p>如果把上面的过程说的仔细一点，以太网是将以太帧发送给路由器链路层，路由器链路层将数据包发送给路由器网络层，路由器有一个路由表，网络层在路由表找到跟当前路由器相连的、离目的主机最近的路由器，路由器通过 ARP 协议，得到下一个路由器的 MAC 地址，让路由器链路层根据 MAC 地址，发送给下一个路由器。通过一系列中转，来到目的主机所在的路由器。使用同样的方式，通过以太网将以太帧发送给目的主机。整个过程大概是这样：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-030834.png" alt=""></p><p>我们常说，网络层负责寻址和路由，寻址就是寻找最近的 IP 地址，路由就是找到最近的路由 MAC 地址（我这么理解，不一定正确）。我们可以理解为：整个通信过程中的网络层负责寻址和路由，发送方的网络层其实负责它自己的寻址和路由。</p><!--前面说，局域网内的链路层是由以太网实现的。那么局域网外的后链路层呢？是通过骨干网等实现。--><h2 id="五、传输层（Transport-Layer）"><a href="#五、传输层（Transport-Layer）" class="headerlink" title="五、传输层（Transport Layer）"></a>五、传输层（Transport Layer）</h2><p>网络层和链路层实现了互联网任意两台主机之间的网络通信，此时还有两个问题，<strong>1、设备不止一个程序，具体发送给哪一个程序？2、没有保证数据包能发送成功。</strong></p><p>这时候就需要<a href="https://zh.wikipedia.org/wiki/传输层" target="_blank" rel="noopener">传输层</a>（Transport Layer），<strong>传输层的功能是保证数据能可靠传输到对方主机的应用程序上。</strong></p><p>应用是进程，<strong>每个进程使用网卡时，需要有一个编号，这个编号就是端口</strong>。系统默认占用 0 到 1023 的端口，系统会为软件随机分配 1024 到 65535 之间的端口。 常见术语套接字（Socket）就是 IP 地址 + 端口的组合称谓。</p><p>传输层要为发送的数据包中增加发送方和接收方的端口号。</p><p>传输层功能实现一般有两种协议，1 是 <a href="https://zh.wikipedia.org/wiki/传输控制协议" target="_blank" rel="noopener">TCP 协议</a>，2 是 <a href="https://zh.wikipedia.org/wiki/用户数据报协议" target="_blank" rel="noopener">UDP 协议</a>。</p><h3 id="5-1-TCP-协议"><a href="#5-1-TCP-协议" class="headerlink" title="5.1 TCP 协议"></a>5.1 TCP 协议</h3><blockquote><p><strong>TCP</strong> 协议，英语全称为：<strong>T</strong>ransmission <strong>C</strong>ontrol <strong>P</strong>rotocol，即，<strong>传输控制协议</strong></p></blockquote><p>TCP 协议使用用三次握手来保证线路的可靠，失败后，有失败重传机制，它是一个很复杂的协议，传输层的称谓，也是来源于 TCP 这个 <strong>传输控制协议</strong>。</p><p>TCP 协议发送的数据包叫 TCP 数据包，它的标头包含发送方端口和接收方端口，</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-17-141857.png" alt="图片来自阮一峰博客"></p><p>它发送数据包给网络层，网络层将 TCP 数据包作为 IP 数据包的数据部分，再发给链路层。此时以太帧格式如下：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-17-141939.png" alt="图片来自阮一峰博客"></p><p>因为以太帧有长度限制，TCP 协议没有规定数据的长度，所以当 TCP 数据包过长时，以太帧装不下，此时 TCP 数据包需要切分为多个 TCP 数据包。我们常常看到有的书籍说：传输层负责「请求报文」的分割。这就是传输层为什么要分割「请求报文」的缘故。</p><p>传输层保证数据的「可靠传输」，这句话常常被我们误解为，是由传输层传输数据，现在我们知道，传输数据的其实是链路层，传输层其实只是失败重传（当然不止这一个功能，这里这么说是为了方便理解）。所以这句话的重点在于<strong>可靠</strong>，不在传输。</p><h3 id="5-2-UDP-协议"><a href="#5-2-UDP-协议" class="headerlink" title="5.2 UDP 协议"></a>5.2 UDP 协议</h3><blockquote><p><strong>UDP 协议</strong>，英语全称为： <strong>U</strong>ser <strong>D</strong>atagram <strong>P</strong>rotocol，即<strong>用户数据包协议</strong></p></blockquote><p>传输层有一种简单的协议，叫 UDP 协议，UDP 协议只是为数据简单的加上包含发送方端口和接收方端口的标头，就将 UDP 数据包扔给网络层，它不保证是否能成功的发送给接收方，它是一种不可靠的传输协议。因为简单，减少了时间开销，常用于对时间有较高要求的应用程序。</p><h2 id="六、应用层（Application-Layer）"><a href="#六、应用层（Application-Layer）" class="headerlink" title="六、应用层（Application Layer）"></a>六、应用层（Application Layer）</h2><p>链路层、网络层、传输层实现了数据包能从主机应用发送到目的主机应用。正常情况下，网络上主要传输的数据是应用产生的。传输的数据各种各样，有网络请求，有电子邮件等等。数据需要由<a href="https://zh.wikipedia.org/wiki/应用层" target="_blank" rel="noopener">应用层</a>（Application Layer）封装，即规定数据的格式。</p><p>规定「HTML 数据」格式的是 <a href="https://zh.wikipedia.org/wiki/超文本传输协议" target="_blank" rel="noopener">HTTP 协议</a>。可以说，HTTP 协议是应用层的一种实现。</p><h3 id="6-1-HTTP-协议"><a href="#6-1-HTTP-协议" class="headerlink" title="6.1 HTTP 协议"></a>6.1 HTTP 协议</h3><blockquote><p><strong>HTTP 协议</strong>：英文全称为：H<strong>yper</strong>T<strong>ext **T</strong>ransfer <strong>P</strong>rotocol，即超文本转移（传输）协议</p></blockquote><p>当我们打开百度首页时，输入的就是一个网址 <code>www.baidu.com</code>，这是一个 GET 请求，HTTP 协议将请求封装为应用层数据包。这样，百度的服务器应用层就可以根据 HTTP 协议来解析数据包。</p><p>HTTP 请求的数据包一般称为请求报文，分为报文首部和报文主题，报文首部即为请求头，请求头格式如下：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-123839.jpg" alt=""></p><p>包含的应用层数据包的以太帧格式如下：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-17-143436.png" alt="图片来自阮一峰博客"></p><h3 id="6-2-DNS"><a href="#6-2-DNS" class="headerlink" title="6.2 DNS"></a>6.2 DNS</h3><blockquote><p> <strong>DNS</strong>：英语全称为： <strong>D</strong>omain <strong>N</strong>ame <strong>S</strong>ystem，即<strong>域名系统</strong></p></blockquote><p>类似  <code>www.baidu.com</code> 这样的网址域名，是为了用户方便记忆，网络通信时，需要将域名转换为 IP 地址，这是由 <a href="https://zh.wikipedia.org/wiki/域名系统" target="_blank" rel="noopener">DNS</a> 负责的，它也属于应用层。</p><h2 id="七、WireShark-抓包分析"><a href="#七、WireShark-抓包分析" class="headerlink" title="七、WireShark 抓包分析"></a>七、WireShark 抓包分析</h2><p>当 Mac 连 WIFI 后，可以在「设置-&gt;网络」中看见下面这些内容：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-123927.jpg" alt="TCP/IP"></p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-123948.jpg" alt="MAC 地址"></p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-124038.jpg" alt="DNS 地址"></p><p>此时电脑，有自己的 IP 地址、MAC 地址、还知道路由器的 IP 地址、DNS 服务器地址（由路由器负责域名解析，所以 DNS 地址其实就是 IP 地址）和当前的子网掩码。还可以看出，路由器动态分配 IP 地址是由 <a href="https://zh.wikipedia.org/wiki/动态主机设置协议" target="_blank" rel="noopener">DHCP</a> 实现的。</p><p>通过打开百度首页，结合抓包工具 Wireshark 来看看网络通信过程中的数据包的内容。</p><p>关于如何使用 Wireshark，请看 <a href="https://juejin.im/post/5c87059ae51d452f3f64b110" target="_blank" rel="noopener">使用 wireshark 学习网络协议</a>。通过 <code>ping www.baidu.com</code> 得到百度的 IP 地址为 <code>61.135.169.121</code>，在 Wireshark 中配置过滤条件后，通过使用命令 <code>curl www.baidu.com</code> 来模拟打开百度首页：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-124128.jpg" alt=""></p><p>此时在 Wireshark 中可以看出，TCP 协议发送了以太帧，以太帧的格式是：Ethernet II 标头 + IP 4 标头 + TCP 标头 + TCP 数据，TCP 标头显示源端口为 53732，目的地端口为 80；IP 标头显示源 IP 地址为 <code>192.168.31.206</code>，目的地 IP 地址为 <code>61.135.169.121</code>；以太网标头显示源 MAC 地址为 <code>f0:18:98:46:bf:65</code>，目的地 MAC 地址为 <code>28:6c:07:9d:e2:8e</code>（小米路由器地址）。帧的长度为 78 字节，TCP 数据包的长度为 44 个字节。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-124202.jpg" alt=""></p><p>这与我们前面说的相符合，目的主机不在同一个局域网，通过以太网发送以太帧给路由器，再由路由器负责路由发送。</p><p>前三个数据包为 TCP 的 3 次握手，接着发送了 HTTP 数据包，HTTP 数据包包含了请求的内容：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-124319.jpg" alt="">整个过程：先使用 TCP 协议完成了 3 次握手，然后使用 HTTP 协议发送了 GET 请求，接收到了百度的 HTTP 响应，最后使用 TCP 协议完成了 4 次挥手。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-124357.jpg" alt=""></p><h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>互联网协议整个网络通信过程可以用下面这张图描述：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-083129.png" alt="图片来自 Wiki"></p><p>对于发送方的数据处理，<strong>这个过程像是一个俄罗斯套娃的过程</strong>：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-17-150358.png" alt="图片来自 Wiki"></p><p>如果用发快递来类比一下：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">应用层：将物体打包为快递  </span><br><span class="line">      <span class="string">|</span></span><br><span class="line">传输层：为快递填上收件人门牌号；如果快递丢失重新发送</span><br><span class="line">      <span class="string">|</span></span><br><span class="line">网络层：为快递填上收件人小区地址；并根据收件人小区地址，找到下一个快递中转站的地址，最终找到整个线路</span><br><span class="line">      <span class="string">|</span></span><br><span class="line">链路层：为快递填上下一个中转地地址；并负责将快递发往到下一个中转站</span><br><span class="line">      <span class="string">|</span></span><br><span class="line">物理层：运快递的车</span><br></pre></td></tr></table></figure><p>在互联网协议中，因为 TCP/IP 协议最重要，所以互联网协议也可以叫做 「<strong>TCP/IP 协议族</strong>」。</p><p>此文只是个人对互联网协议的浅显理解，毕竟没有深入研究，可能有诸多不当处，欢迎留言指出。</p><p>最后我想说一句，阮一峰牛逼。有的知识点是知道怎么回事，就是不能正确的表达出来，遣词排句真的很需要功力，真的需要常年累月的积累。</p><!--解疑现在来说说，为什么说 SpringCloud 基于 HTTP 协议，Dubbo 基于 TCP 协议。我是这么理解的，因为 SpringClout 框架直接接受 HTTP 请求，而 Dubbo 让数据没有使用 HTTP 协议包装数据包。直接将数据包装为 TCP 数据包。--><h2 id="九、延伸阅读"><a href="#九、延伸阅读" class="headerlink" title="九、延伸阅读"></a>九、延伸阅读</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="noopener">互联网协议入门（一）<em>阮一峰</em></a></li><li><a href="http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html" target="_blank" rel="noopener">互联网协议入门（二）<em>阮一峰</em></a></li><li><a href="https://juejin.im/post/5c87059ae51d452f3f64b110" target="_blank" rel="noopener">使用wireshark学习网络协议</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者：&lt;a href=&quot;https://depp.wang&quot;&gt;DeppWang&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;互联网上的数据能从一台设备发送到另一台设备，整个过程由&lt;a href=&quot;https://zh.wikipedia.org/wiki/TCP/IP协议族&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;互联网协议&lt;/a&gt;（ Internet Protocol Suite）实现的。 &lt;/p&gt;
&lt;p&gt;对于互联网协议，一直一知半解。知道会分为几层，但为什么分层，分层有什么好处，都不甚理解。通过&lt;a href=&quot;www.ruanyifeng.com&quot;&gt;阮一峰&lt;/a&gt;的这两篇文章，大概有了一个初步认识，下面是我对互联网协议的理解。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;互联网协议入门（一）&lt;em&gt;阮一峰&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;互联网协议入门（二）&lt;em&gt;阮一峰&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="网络" scheme="https://depp.wang/categories/Network/"/>
    
    
      <category term="互联网协议" scheme="https://depp.wang/tags/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + NexT 博客优化（修改）记录</title>
    <link href="https://depp.wang/2020/03/12/hexo-next-all-change/"/>
    <id>https://depp.wang/2020/03/12/hexo-next-all-change/</id>
    <published>2020-03-12T20:48:37.000Z</published>
    <updated>2020-04-10T13:36:08.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、样式修改"><a href="#一、样式修改" class="headerlink" title="一、样式修改"></a>一、样式修改</h2><p>注意：重新部署后，样式若没更新，清除浏览器缓存</p><h3 id="分类横向展示"><a href="#分类横向展示" class="headerlink" title="分类横向展示"></a>分类横向展示</h3><p><code>themes\next\source\css\_common\component\pages\categories.styl</code> 中修改：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.category-list-item</span> &#123; </span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">5px</span> <span class="number">10px</span>; </span><br><span class="line">  display: inline-block; // 新增</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>display: inline-block</code>：可以不换行，让其他元素元素显示在旁边；并且可以设置高度，<a href="https://www.w3schools.com/css/css_inline-block.asp" target="_blank" rel="noopener">w3schools: CSS Layout - display: inline-block</a></li></ul><a id="more"></a><h3 id="设置图片居中"><a href="#设置图片居中" class="headerlink" title="设置图片居中"></a>设置图片居中</h3><p>Mist 主题： <code>themes\next\source\css\_schemes\Mist\_posts-expanded.styl</code> 中修改</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.post-body img &#123; margin: auto; &#125; // 0 - &gt; auto</span><br></pre></td></tr></table></figure><ul><li>_schemes：方案</li></ul><h3 id="设置字体大小"><a href="#设置字体大小" class="headerlink" title="设置字体大小"></a>设置字体大小</h3><p><code>themes\next\source\css\_variables\base.styl</code> 中修改：</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$font</span>-size-base           = <span class="number">16px</span> <span class="comment">// 14px -&gt; 16px</span></span><br></pre></td></tr></table></figure><ul><li><code>_variables\base</code>：存放公共基础变量</li></ul><h3 id="显示宽度设置"><a href="#显示宽度设置" class="headerlink" title="显示宽度设置"></a>显示宽度设置</h3><p><code>themes\next\source\css\_variables\base.styl</code> 中修改：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">$content</span>-desktop                = 800px</span></span><br></pre></td></tr></table></figure><h3 id="更改-h1-h2-字体大小，并设置下划线"><a href="#更改-h1-h2-字体大小，并设置下划线" class="headerlink" title="更改 h1 h2 字体大小，并设置下划线"></a>更改 h1 h2 字体大小，并设置下划线</h3><p>更改 h1 h2 字体大小： <code>themes\next\source\css\_custom\custom.styl</code> 中修改</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Custom styles.</span><br><span class="line">// 新增</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  font-size: 2em; // 2em = 32px</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">  font-size: 1.5em; // 1.5em = 24px, 1em = 16px</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>_custom\custom.styl</code> 为全局自定义样式</li></ul><p>设置下划线： <code>themes\next\source\css\_common\component\post\post-expand.styl</code> 中修改</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.posts-expand</span> <span class="selector-class">.post-body</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  // 新增</span><br><span class="line">  <span class="selector-tag">h1</span>, <span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: .<span class="number">3em</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#eaecef</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>也可以在  <code>themes\next\source\css\_schemes\Mist\_posts-expanded.styl</code> 修改？</li><li>只为文章内容中的 h1 h2 标题添加下划线</li></ul><h3 id="URL-中文改为英文"><a href="#URL-中文改为英文" class="headerlink" title="URL 中文改为英文"></a>URL 中文改为英文</h3><p>文章标题块添加 english-tile，站点配置文件修改 permalink</p><p>站点配置文件设置 tag_map、category_map</p><h2 id="二、功能添加"><a href="#二、功能添加" class="headerlink" title="二、功能添加"></a>二、功能添加</h2><ul><li>底部添加版权声明、微信公众号图片、分享按钮</li></ul><h3 id="添加-Disqus-评论"><a href="#添加-Disqus-评论" class="headerlink" title="添加 Disqus 评论"></a>添加 Disqus 评论</h3><p>教程：<a href="https://depp.wang/2017/06/15/hexo-disqus">Hexo 添加 Disqus 评论</a></p><p>缺点：只能科学上网后才能评论</p><hr><h5 id="也可以使用-Gitalk"><a href="#也可以使用-Gitalk" class="headerlink" title="也可以使用 Gitalk"></a>也可以使用 <a href="https://github.com/gitalk/gitalk" target="_blank" rel="noopener">Gitalk</a></h5><p>教程：</p><ul><li><a href="https://asdfv1929.github.io/2018/01/20/gitalk/" target="_blank" rel="noopener">使用 gitalk 评论插件</a></li><li><a href="https://liujunzhou.top/2018/8/10/gitalk-error/" target="_blank" rel="noopener">gitalk-error</a></li><li><a href="https://priesttomb.github.io/%E6%97%A5%E5%B8%B8/2018/02/12/%E5%A4%84%E7%90%86Gitalk%E4%B8%AD%E7%94%B1%E4%BA%8E%E6%96%87%E7%AB%A0URL%E8%BF%87%E9%95%BF%E5%AF%BC%E8%87%B4%E7%9A%84Validation-Failed(422)/" target="_blank" rel="noopener">处理Gitalk中由于文章URL过长导致的Validation Failed(422)</a></li></ul><p>缺点：发布文章后需要页面点击初始化</p><h3 id="添加-Algolia-搜索"><a href="#添加-Algolia-搜索" class="headerlink" title="添加 Algolia 搜索"></a>添加 Algolia 搜索</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export HEXO_ALGOLIA_INDEXING_KEY=*** // 使用 export 临时设置一个环境变量</span><br><span class="line">echo $HEXO_ALGOLIA_INDEXING_KEY  // 查看环境变量是否设置成功</span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li><a href="https://www.npmjs.com/package/hexo-algolia" target="_blank" rel="noopener">hexo-algolia</a> 和  <a href="https://www.npmjs.com/package/hexo-algoliasearch" target="_blank" rel="noopener">hexo-algoliasearch</a> 不要同时使用</li><li>使用 hexo-algolia 时，如果你删除了文章，需要更新 Algolia 里面的链接，需要使用 <code>hexo algolia --flush true</code> 命令</li></ol><p>hexo-algolia 模块的作用：将博客文章链接发送给自己的 Algolia 账户。搜索原理：输入关键字，调用 Algolia 提供接口，返回相应文章链接</p><p>可参考教程：</p><ul><li><a href="https://juejin.im/post/5af3f9d1518825673e35a6eb" target="_blank" rel="noopener">Hexo + Next 集成 Algolia 搜索</a></li><li><a href="http://theme-next.iissnan.com/third-party-services.html#algolia-search" target="_blank" rel="noopener">Next Algolia</a> </li></ul><p>缺点：</p><ol><li>新增文章后需要运行 <code>hexo algolia</code> 将当前文章发送到 Algolia</li><li>删除文章后还能搜索到，需要再次去 Algolia 删除？可使用  <code>hexo algolia --flush true</code> 命令更新</li></ol><p>可能遇到的问题：</p><ul><li>每次运行 <code>hexo algolia</code> 都需要设置环境变量，解决方式：直接「永久」设置环境变量</li></ul><p>macOS「永久」设置环境变量：</p><ul><li>默认为 bash，修改 .bash_profile</li><li>如果为 oh-my-zsh，修改 .zshrc</li><li>打印环境变量命令：printenv</li></ul><h3 id="添加文章阅读次数统计、网站访问次数统计"><a href="#添加文章阅读次数统计、网站访问次数统计" class="headerlink" title="添加文章阅读次数统计、网站访问次数统计"></a>添加文章阅读次数统计、网站访问次数统计</h3><p>可参考文章：<a href="https://depp.wang/2017/06/14/hexo-statistical/">Hexo 添加不蒜子和 LeanCloud 统计</a></p><h2 id="三、外部设置"><a href="#三、外部设置" class="headerlink" title="三、外部设置"></a>三、外部设置</h2><ul><li><a href="https://depp.wang/2020/02/17/use-github-actions-to-achieve-hexo-blog-auto-deploy/">使用 GitHub Actions 实现 Hexo 博客自动部署</a></li></ul><h3 id="自定义域名加密为-HTTPS"><a href="#自定义域名加密为-HTTPS" class="headerlink" title="自定义域名加密为 HTTPS"></a>自定义域名加密为 HTTPS</h3><p>直接利用 <a href="https://www.cloudflare.com/" target="_blank" rel="noopener">cloudfire</a> 加密网站</p><p>访问域名时，需要先由 DNS 服务来将域名解析为 ip 地址</p><p>DNS 服务器负责域名解析，需要先将域名的 DNS 服务器修改为  cloudfire 的服务器，由 cloudfiere 的 DNS 服务器负责域名解析，在 cloudfire 中设置规则，如：将 depp.wang 解析到 deppwang.gihub.io</p><p>在项目 GitHub Pages 中设置：访问 deppwang.gihub.io 重定向到 depp.wang，访问 depp.wang 时，cloudfiere 的 DNS 服务器又将 depp.wang 指向到 deppwang.github.io，最终访问的还是 deppwang.github.io。ping depp.wang  会发现是 github 节点，如果 ip 地址为  cloudfiere 节点，那是因为 cloudfiere 设置了代理。</p><ul><li>DNS：Domain Name System 域名系统</li></ul><p>可参考文章：<a href="https://crossoverjie.top/%2F2017%2F05%2F07%2Fhttps%2Fl" target="_blank" rel="noopener">科普-为自己的博客免费加上小绿锁</a></p><h3 id="提交到-Google-搜索引擎"><a href="#提交到-Google-搜索引擎" class="headerlink" title="提交到 Google 搜索引擎"></a>提交到 Google 搜索引擎</h3><p>一般不主动提交 url  给 Google 搜索引擎，Google 也可以凭借强大的爬虫（蜘蛛）抓取你网址的 url，但为了让谷歌更好更快的抓取你的文章，还是给他提供一个参考，一个站点地图（sitemap.xml）</p><p>先在 <a href="https://search.google.com/search-console" target="_blank" rel="noopener">Search Console</a> 验证你拥有网站的所有权，可以使用 HTML 文件、HTML 标记等方式验证。将 HTML 文件添加到网站中。每个用户拥有自己的 HTML 文件，如果网站有多个管理员，每个管理员的 HTML 文件不同。</p><p>如果使用 HTML 文件验证失败，HTML 文件添加 <code>layout: false</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">layout: false</span><br><span class="line">---</span><br><span class="line">google-site-verification: googlec27ee4754ff2e800.html</span><br></pre></td></tr></table></figure><p>使用 hexo-generator-sitemap 包生成站点地图，hexo-generator-sitemap 包的作用：</p><ul><li>每次 hexo g 时，根据_post 的文章生成站点地图：sitemap.xml，</li><li>如果能生成说明配置没有问题</li></ul><p>Google 定期抓取你设置的 sitemap</p><ul><li>站点地图抓取时间不更新解释：<a href="https://metinsaylan.com/9642/how-to-solve-search-console-sitemap-could-not-be-read-error/" target="_blank" rel="noopener">[How To] Solve Search Console “Sitemap could not be read” Error</a></li></ul><h2 id="四、其他可能遇到的问题"><a href="#四、其他可能遇到的问题" class="headerlink" title="四、其他可能遇到的问题"></a>四、其他可能遇到的问题</h2><ul><li>Google 不收录网址的问题</li><li>博客源文件每次被覆盖的问题</li></ul><h3 id="网址描述不显示问题"><a href="#网址描述不显示问题" class="headerlink" title="网址描述不显示问题"></a>网址描述不显示问题</h3><p>原因在于 NexT 开起了 SEO，SEO 覆盖掉了原来的代码</p><p>思路：找到不显示字样的 class，IDEA 打开文件，全局搜索 class，找到代码位置，进行修改</p><p>修改文件位置</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/next/</span>layout<span class="regexp">/_macro/</span>sidebar.swig</span><br></pre></td></tr></table></figure><p><code>theme.signature</code> 修改为 <code>config.description</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"site-description motion-element"</span> <span class="attr">itemprop</span>=<span class="string">"description"</span>&gt;</span>&#123;&#123; config.description &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>SEO: Search engine optimization 搜索引擎优化</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、样式修改&quot;&gt;&lt;a href=&quot;#一、样式修改&quot; class=&quot;headerlink&quot; title=&quot;一、样式修改&quot;&gt;&lt;/a&gt;一、样式修改&lt;/h2&gt;&lt;p&gt;注意：重新部署后，样式若没更新，清除浏览器缓存&lt;/p&gt;
&lt;h3 id=&quot;分类横向展示&quot;&gt;&lt;a href=&quot;#分类横向展示&quot; class=&quot;headerlink&quot; title=&quot;分类横向展示&quot;&gt;&lt;/a&gt;分类横向展示&lt;/h3&gt;&lt;p&gt;&lt;code&gt;themes\next\source\css\_common\component\pages\categories.styl&lt;/code&gt; 中修改：&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-class&quot;&gt;.category-list-item&lt;/span&gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;margin&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;5px&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;10px&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  display: inline-block; // 新增&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;display: inline-block&lt;/code&gt;：可以不换行，让其他元素元素显示在旁边；并且可以设置高度，&lt;a href=&quot;https://www.w3schools.com/css/css_inline-block.asp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;w3schools: CSS Layout - display: inline-block&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://depp.wang/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://depp.wang/tags/Hexo/"/>
    
      <category term="NexT" scheme="https://depp.wang/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>使用 GitHub Actions 实现 Hexo 博客自动部署</title>
    <link href="https://depp.wang/2020/02/17/use-github-actions-to-achieve-hexo-blog-auto-deploy/"/>
    <id>https://depp.wang/2020/02/17/use-github-actions-to-achieve-hexo-blog-auto-deploy/</id>
    <published>2020-02-17T13:26:55.000Z</published>
    <updated>2020-04-10T13:36:08.715Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-02-17-084920.png" alt="Image result for image Hexo"></p><h2 id="一、Hexo-相关知识点"><a href="#一、Hexo-相关知识点" class="headerlink" title="一、Hexo 相关知识点"></a>一、Hexo 相关知识点</h2><p>静态博客简单，但是发布博文时稍显麻烦，一般需要下面两步：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g -d // 相当于 hexo g + hexo d</span><br></pre></td></tr></table></figure><p>如果考虑到同步源文件，还需要每次更改后，将源文件 push 到指定仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><a id="more"></a><p>我们可以将 Hexo 文件分为两类，一类是源文件，即下面这些文件：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── <span class="variable">_config</span>.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── <span class="variable">_drafts</span></span><br><span class="line">|   └── <span class="variable">_posts</span></span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p>一类是 public 文件，即网站文件：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line">├── <span class="number">2020</span></span><br><span class="line">├── categories</span><br><span class="line">├── tags</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>发布博文的这三个操作代表：</p><ul><li>hexo clean：删除网站（public）文件</li><li>hexo g：生成网站（public）文件</li><li>hexo d：将本地网站（public）文件同步到指定仓库（如：yourname.github.io）中</li></ul><p>我使用一个私有仓库存放 Hexo 源文件，在 deppwang/deppwang.github.io 中存放网站文件。所以每次发布或者更新博文时，需要使用 push 操作更新源文件，再执行 <code>hexo clean</code>、<code>hexo g -d</code> 更新博客，比较麻烦。</p><p>所以我们希望能在 push 源文件后，由 <a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank" rel="noopener">CI/CD</a>（持续集成 / 持续部署）工具为我们执行  <code>hexo clean</code>、<code>hexo g -d</code> 这两个操作。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-02-15-105934.png" alt="Image result for github action"></p><h2 id="二、GitHub-Actions"><a href="#二、GitHub-Actions" class="headerlink" title="二、GitHub Actions"></a>二、GitHub Actions</h2><p>CI/CD 工具前有 Travis CI，现有 GitHub Actions，这里使用 GitHub Actions。</p><p>GitHub Actions 的工作原理：我们提前设置好需要自动化执行的任务，GitHub Actions 监控当前仓库的某一个操作（如：push），一旦有此操作，就自动化执行这些任务。</p><p>所以我们希望使用 GitHub Actions 后，只需要往源文件仓库 push 更新源文件，GitHub Actions 监控到 push 操作时，就自动化执行  <code>hexo clean</code>、<code>hexo g -d</code>  操作，完成博文发布。</p><p>Action 存放在项目根目录的 <code>.github/workflows</code> 下，后缀为 <code>.yml</code>。一个 Action 相当于一个工作流 workflow，一个工作流可以有多个任务 job，每个任务可以分为几步 step。任务、步骤依次执行。</p><p>每个 Action 是一个独立脚本，所以可以作为代码仓库。</p><ul><li><code>actions/setup-node</code> 就表示 <code>github.com/actions/setup-node</code> 这个 <a href="https://github.com/actions/setup-node" target="_blank" rel="noopener">仓库</a>，代表安装 node.js。Action 为 action.yml </li></ul><p>可以通过下面这种格式来使用别人写好的 action，@借用了指针的概念：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">actions/setup-<span class="keyword">node</span><span class="title">@74bc508</span> <span class="comment"># 指向一个 commit</span></span><br><span class="line">actions/setup-<span class="keyword">node</span><span class="title">@v1</span>.<span class="number">0</span>    <span class="comment"># 指向一个标签</span></span><br><span class="line">actions/setup-<span class="keyword">node</span><span class="title">@master</span>  <span class="comment"># 指向一个分支</span></span><br></pre></td></tr></table></figure><p>关于 GitHub Actions 更多知识，请看 <a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html" target="_blank" rel="noopener">GitHub Actions 入门教程 - 阮一峰</a>。</p><p>现在需要实现一个 Action，使其能够执行  <code>hexo clean</code>、<code>hexo g -d</code>  操作。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-02-17-115214.png" alt="Image result for hexo action"></p><h2 id="三、Hexo-Action"><a href="#三、Hexo-Action" class="headerlink" title="三、Hexo Action"></a>三、Hexo Action</h2><p>我是使用的 <a href="https://github.com/sma11black/" target="_blank" rel="noopener">sma11black</a> 已经开发好的 <a href="https://github.com/DeppWang/hexo-action" target="_blank" rel="noopener">Hexo Action</a>，这个 Action <strong>针对的是存放 Hexo 源文件和网站文件分开存放的场景</strong>。请先看 <a href="https://github.com/marketplace/actions/hexo-action" target="_blank" rel="noopener">教程</a>，以下为教程的补充。</p><p>非第一次生成 SSH Key：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -f ~/.ssh/id_rsa_x -C "yourmail@xxx.com"</span><br></pre></td></tr></table></figure><p>将生成的 <code>private key</code> 作为 Hexo 源文件仓库 <code>Settings &gt; Secrets</code> 的 一个名叫 <code>DEPLOY_KEY</code> 的 <code>Secret</code>。注意：需要复制包括 <code>-----BEGIN OPENSSH PRIVATE KEY-----</code> 和 <code>-----END OPENSSH PRIVATE KEY-----</code> 的整个内容。Secret 相当于一个变量，可以使私有变量不公开。</p><p>将生成的 <code>public key</code> 作为网站文件仓库 <code>Settings &gt; Deploy Keys</code> 的 Deploy Key。Deploy Keys 中的公钥针对于当前仓库。</p><p>为什么要用 SSH Key？</p><ul><li><p>SSH Key，是一对密匙：公钥 + 私钥，用于加密本地仓库和远程仓库的传输内容。</p><blockquote><p>在 RSA 加密算法中，公钥用于对数据进行加密，私钥用于对数据进行解密<br>在 RSA 签名算法中，私钥用于对数据进行签名，公钥用于对签名进行验证。</p></blockquote><blockquote><p>pull 的时候公钥用于对数据进行加密，私钥用于对数据进行解密，<br>push 的时候私钥用于对数据进行签名，公钥用于对签名进行验证。</p></blockquote></li><li><p>使用 GitHub Actions 是借助 GitHub 提供的环境，跟本地环境一样，也需要有私钥。当 GitHub Action 执行 <code>hexo g -d</code> 时，是一个 push 的过程，用私钥 DEPLOY_KEY 签名，GitHub 用网站文件仓库的公钥 Deploy Key 进行验证。</p></li></ul><p>下面是具体的 action.yml：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span> <span class="comment"># workflow name</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="string">[push]</span> <span class="comment"># 触发事件</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line"><span class="attr">  build:</span> <span class="comment"># job1 id</span></span><br><span class="line"><span class="attr">    runs-on:</span> <span class="string">ubuntu-latest</span> <span class="comment"># 运行环境为最新版 Ubuntu</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">A</span> <span class="string">job</span> <span class="string">to</span> <span class="string">deploy</span> <span class="string">blog.</span></span><br><span class="line"><span class="attr">    steps:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Checkout</span> <span class="comment"># step1 获取 hexo 源码</span></span><br><span class="line"><span class="attr">      uses:</span> <span class="string">actions/checkout@v1</span> <span class="comment"># 使用 actions/checkout@v1</span></span><br><span class="line"><span class="attr">      with:</span> <span class="comment"># 条件</span></span><br><span class="line"><span class="attr">        submodules:</span> <span class="literal">true</span> <span class="comment"># Checkout private submodules(themes or something else). 当有子模块时时，同步子模块</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Caching dependencies to speed up workflows. (GitHub will remove any cache entries that have not been accessed in over 7 days.) 根据 package-lock.json 压缩缓存 node_modules，不用每次下载，使用时解压，可以加快工作流的执行过程，超过 7 天没有使用将删除压缩包。</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Cache</span> <span class="string">node</span> <span class="string">modules</span> <span class="comment"># step2</span></span><br><span class="line"><span class="attr">      uses:</span> <span class="string">actions/cache@v1</span></span><br><span class="line"><span class="attr">      id:</span> <span class="string">cache</span></span><br><span class="line"><span class="attr">      with:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">node_modules</span></span><br><span class="line"><span class="attr">        key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.os</span> <span class="string">&#125;&#125;-node-$&#123;&#123;</span> <span class="string">hashFiles('**/package-lock.json')</span> <span class="string">&#125;&#125;</span> <span class="comment"># 使用 Hexo 项目的 package-lock.json 安装、缓存 node_moudules</span></span><br><span class="line"><span class="attr">        restore-keys:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          $<span class="template-variable">&#123;&#123; runner.os &#125;&#125;</span>-node-</span></span><br><span class="line"><span class="string">          </span></span><br><span class="line"><span class="string"></span><span class="attr">    - name:</span> <span class="string">Install</span> <span class="string">Dependencies</span> <span class="comment"># step3</span></span><br><span class="line"><span class="attr">      if:</span> <span class="string">steps.cache.outputs.cache-hit</span> <span class="string">!=</span> <span class="string">'true'</span> <span class="comment"># 如果没有缓存 node_modules</span></span><br><span class="line"><span class="attr">      run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="comment"># 根据 package.json 在 node_modules 下载相关包（依赖）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Deploy hexo blog website.</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Deploy</span> <span class="comment"># step4</span></span><br><span class="line"><span class="attr">      id:</span> <span class="string">deploy</span></span><br><span class="line"><span class="attr">      uses:</span> <span class="string">deppwang/hexo-action@v1.0.0</span></span><br><span class="line"><span class="attr">      with:</span></span><br><span class="line"><span class="attr">        deploy_key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEPLOY_KEY</span> <span class="string">&#125;&#125;</span> </span><br><span class="line"><span class="attr">        user_name:</span> <span class="string">your</span> <span class="string">github</span> <span class="string">username</span> <span class="comment"># 自定义</span></span><br><span class="line"><span class="attr">        user_email:</span> <span class="string">your</span> <span class="string">github</span> <span class="string">useremail</span> <span class="comment"># 自定义</span></span><br></pre></td></tr></table></figure><h2 id="四、运行过程"><a href="#四、运行过程" class="headerlink" title="四、运行过程"></a>四、运行过程</h2><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-02-24-135152.png" alt=""></p><h3 id="1、-Build-deppwang-hexo-action-master（新建-hexo-action-Docker-容器）"><a href="#1、-Build-deppwang-hexo-action-master（新建-hexo-action-Docker-容器）" class="headerlink" title="1、 Build deppwang/hexo-action@master（新建 hexo-action Docker 容器）"></a>1、 Build deppwang/hexo-action@master（新建 hexo-action Docker 容器）</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## action.yml</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">runs:</span></span><br><span class="line"><span class="attr">  using:</span> <span class="string">'docker'</span></span><br><span class="line"><span class="attr">  image:</span> <span class="string">'Dockerfile'</span></span><br><span class="line"><span class="attr">  args:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">$&#123;&#123;</span> <span class="string">inputs.user_name</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">$&#123;&#123;</span> <span class="string">inputs.user_email</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">$&#123;&#123;</span> <span class="string">inputs.deploy_key</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Dockerfile</span></span></span><br><span class="line">FROM node:13-alpine  # node:13-alpine 是一个 Dockerfile</span><br><span class="line"></span><br><span class="line">LABEL version="1.0.0"</span><br><span class="line">LABEL repository="https://github.com/sma11black/hexo-action"</span><br><span class="line">LABEL homepage="https://sma11black.github.io"</span><br><span class="line">LABEL maintainer="sma11black &lt;smallblack@outlook.com&gt;"</span><br><span class="line"></span><br><span class="line">RUN apk add --no-cache git # 安装 Git</span><br><span class="line">RUN apk add --no-cache openssh # 安装 openssh</span><br><span class="line"></span><br><span class="line">COPY entrypoint.sh /entrypoint.sh</span><br><span class="line">RUN chmod +x /entrypoint.sh</span><br><span class="line"></span><br><span class="line">ENTRYPOINT ["/entrypoint.sh"]</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Run Log</span></span></span><br><span class="line">Build container for action use: '/home/runner/work/_actions/sma11black/hexo-action/v1.0.0/Dockerfile'.</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Step 1/10 : FROM node:13-alpine</span><br><span class="line">...</span><br><span class="line">Status: Downloaded newer image for node:13-alpine</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="2、Check-Out（下载代码存放在容器中）"><a href="#2、Check-Out（下载代码存放在容器中）" class="headerlink" title="2、Check Out（下载代码存放在容器中）"></a>2、Check Out（下载代码存放在容器中）</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">Checkout</span> <span class="comment"># step1 获取 hexo 网站源码</span></span><br><span class="line"><span class="attr">  uses:</span> <span class="string">actions/checkout@v1</span> <span class="comment"># 使用 actions/checkout@v1</span></span><br><span class="line"><span class="attr">  with:</span> <span class="comment"># 条件</span></span><br><span class="line"><span class="attr">    submodules:</span> <span class="literal">true</span> <span class="comment"># Checkout private submodules(themes or something else). 当有子模块时切换分支？</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Run Log</span></span></span><br><span class="line">...</span><br><span class="line">git init "/home/runner/work/HexoBlog/HexoBlog"</span><br><span class="line">Initialized empty Git repository in /home/runner/work/HexoBlog/HexoBlog/.git/ # Hexo 项目位置</span><br><span class="line">....</span><br><span class="line">Resolving deltas: 100% (1226/1226), done.</span><br><span class="line">From https://github.com/DeppWang/HexoBlog</span><br><span class="line"> * [new branch]      master     -&gt; origin/master</span><br><span class="line">git checkout --progress --force da857124acdb52ed76426dccf6309c2944d8be86</span><br><span class="line">Note: switching to 'da857124acdb52ed76426dccf6309c2944d8be86'.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="3、Cache-node-modules（解压-node-modules-压缩包）"><a href="#3、Cache-node-modules（解压-node-modules-压缩包）" class="headerlink" title="3、Cache node modules（解压 node_modules 压缩包）"></a>3、Cache node modules（解压 node_modules 压缩包）</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Caching dependencies to speed up workflows. (GitHub will remove any cache entries that have not been accessed in over 7 days.) 根据 package-lock.json 压缩缓存 node_modules，不用每次下载，使用时解压，可以加快工作流的执行过程，超过 7 天没有使用将删除压缩包。</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Cache</span> <span class="string">node</span> <span class="string">modules</span> <span class="comment"># step2</span></span><br><span class="line"><span class="attr">      uses:</span> <span class="string">actions/cache@v1</span></span><br><span class="line"><span class="attr">      id:</span> <span class="string">cache</span></span><br><span class="line"><span class="attr">      with:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">node_modules</span></span><br><span class="line"><span class="attr">        key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.os</span> <span class="string">&#125;&#125;-node-$&#123;&#123;</span> <span class="string">hashFiles('**/package-lock.json')</span> <span class="string">&#125;&#125;</span> <span class="comment"># 使用 Hexo 项目的 package-lock.json 安装、缓存 node_moudules</span></span><br><span class="line"><span class="attr">        restore-keys:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          $<span class="template-variable">&#123;&#123; runner.os &#125;&#125;</span>-node-</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Run Log</span></span></span><br><span class="line">...</span><br><span class="line">Cache Size: ~9 MB (8961261 B)</span><br><span class="line">/bin/tar -xz -f /home/runner/work/_temp/e7af5c7e-5251-4125-8eea-dbd9f8574796/cache.tgz -C /home/runner/work/HexoBlog/HexoBlog/node_modules # 将 cache.tgz 解压为 node_modules。-C, --directory=DIR change to directory DIR</span><br><span class="line">Cache restored from key: Linux-node-85c3344f19ab8bd53e79be4d334a61c6c60f0730b275ad9bcbe1c9bc06076575</span><br></pre></td></tr></table></figure><h3 id="4、-Install-Dependencies（如有必要，更新-node-modules）"><a href="#4、-Install-Dependencies（如有必要，更新-node-modules）" class="headerlink" title="4、 Install Dependencies（如有必要，更新 node_modules）"></a>4、 Install Dependencies（如有必要，更新 node_modules）</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">Install</span> <span class="string">Dependencies</span> <span class="comment"># step3</span></span><br><span class="line"><span class="attr">  if:</span> <span class="string">steps.cache.outputs.cache-hit</span> <span class="string">!=</span> <span class="string">'true'</span> <span class="comment"># 如果没有缓存 node_modules</span></span><br><span class="line"><span class="attr">  run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="comment"># 根据 package.json 在 node_modules 下载相关包（依赖）</span></span><br></pre></td></tr></table></figure><h3 id="5、Deploy（生成、发布博文）"><a href="#5、Deploy（生成、发布博文）" class="headerlink" title="5、Deploy（生成、发布博文）"></a>5、Deploy（生成、发布博文）</h3><ul><li>hexo g 生成 public 网站静态文件</li><li>hexo d 将静态文件 push 到指定仓库（会强制覆盖原文件，如何不覆盖源文件呢？）</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">Deploy</span> <span class="comment"># step4</span></span><br><span class="line"><span class="attr">  id:</span> <span class="string">deploy</span></span><br><span class="line"><span class="attr">  uses:</span> <span class="string">sma11black/hexo-action@v1.0.0</span></span><br><span class="line"><span class="attr">  with:</span></span><br><span class="line"><span class="attr">    deploy_key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEPLOY_KEY</span> <span class="string">&#125;&#125;</span> </span><br><span class="line"><span class="attr">    user_name:</span> <span class="string">your</span> <span class="string">github</span> <span class="string">username</span> <span class="comment"># 自定义</span></span><br><span class="line"><span class="attr">    user_email:</span> <span class="string">your</span> <span class="string">github</span> <span class="string">useremail</span> <span class="comment"># 自定义</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">set -e</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> setup ssh-private-key</span></span><br><span class="line">mkdir -p /root/.ssh/</span><br><span class="line">echo "$INPUT_DEPLOY_KEY" &gt; /root/.ssh/id_rsa</span><br><span class="line">chmod 600 /root/.ssh/id_rsa</span><br><span class="line">ssh-keyscan -t rsa github.com &gt;&gt; /root/.ssh/known_hosts</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> setup deploy git account</span></span><br><span class="line">git config --global user.name "$INPUT_USER_NAME"</span><br><span class="line">git config --global user.email "$INPUT_USER_EMAIL"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> install hexo env</span></span><br><span class="line">npm install hexo-cli -g</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> deployment</span></span><br><span class="line">hexo g -d</span><br><span class="line"></span><br><span class="line">echo ::set-output name=notify::"Deploy complate."</span><br><span class="line">© 2020 GitHub, Inc.</span><br></pre></td></tr></table></figure><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-02-17-115552.jpg" alt="Image result for error"></p><h2 id="五、可能出现的问题：Deploy-失败"><a href="#五、可能出现的问题：Deploy-失败" class="headerlink" title="五、可能出现的问题：Deploy 失败"></a>五、可能出现的问题：Deploy 失败</h2><p>可能出现以下 3 三种情况：</p><p><strong>1、</strong></p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-02-15-140504.png" alt="image-20200215220503185"></p><p>重点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Host key verification failed</span><br><span class="line">fatal: Could not read from remote repository.</span><br></pre></td></tr></table></figure><p>原因：<code>站点配置文件</code> 配置项 deploy 存在出 GitHub 以外的仓库 — 如：Coding ，而 Hexo-Action 不能识别此仓库</p><p>解决方式：</p><ol><li>要么去除 GitHub 以外的仓库；</li><li>要么 *<em>entrypoint.sh *</em> 添加 <code>ssh-keyscan -t rsa e.coding.net &gt;&gt; /root/.ssh/known_hosts</code></li></ol><p><strong>2、</strong></p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-02-15-140636.png" alt="image-20200215220635619"></p><p>重点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Load key "/root/ssh/id_rsa": invalid format</span><br><span class="line">git@github.com: Permission denied (publickey)</span><br><span class="line">fatal: Could not read from remote repository.</span><br></pre></td></tr></table></figure><p>原因：SSH Key 的公钥和私钥没有正确复制，或者设置错误</p><p>解决方式：正确且完整的复制并设置</p><p><strong>3、</strong></p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-02-16-103927.png" alt="image-20200216183926423"></p><p>重点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR Local hexo not found in /github/workspace</span><br><span class="line">ERROR Try running: 'npm install hexo --save'</span><br></pre></td></tr></table></figure><p>原因：<code>hexo-deployer-git</code> 的版本过低，导致删除了 hexo 包。</p><p>解决方式：</p><ol><li>参考 <a href="https://github.com/sma11black/hexo-action/issues/1" target="_blank" rel="noopener">此 issue</a> 升级 <code>hexo-deployer-git</code></li><li>使用 <code>deppwang/hexo-aciton@v1.0.1</code> 重装，他重新安装了 hexo 包</li></ol><h2 id="六、解决-github-io-丢失-commit-记录"><a href="#六、解决-github-io-丢失-commit-记录" class="headerlink" title="六、解决 **.github.io 丢失 commit 记录"></a>六、解决 **.github.io 丢失 commit 记录</h2><p><code>hexo d</code> 其实分为 3 步：</p><ol><li>将 public 文件复制到 .deploy_git</li><li>commit</li><li>push 到远程仓库</li></ol><p>执行 hexo d 命令时，如果没有 .doploy_git 文件，它将新建一个 .deploy_git 文件，所以旧的 commit 记录将丢失。</p><p>可以在 entrypoint.sh 中添加一行命令来解决这个问题：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/username/username.github.io.git .deploy_git</span><br></pre></td></tr></table></figure><h2 id="七、参考"><a href="#七、参考" class="headerlink" title="七、参考"></a>七、参考</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html" target="_blank" rel="noopener">GitHub Actions 入门教程 - 阮一峰</a></li><li><a href="https://github.com/marketplace/actions/hexo-action" target="_blank" rel="noopener">Hexo Action</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-02-17-084920.png&quot; alt=&quot;Image result for image Hexo&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、Hexo-相关知识点&quot;&gt;&lt;a href=&quot;#一、Hexo-相关知识点&quot; class=&quot;headerlink&quot; title=&quot;一、Hexo 相关知识点&quot;&gt;&lt;/a&gt;一、Hexo 相关知识点&lt;/h2&gt;&lt;p&gt;静态博客简单，但是发布博文时稍显麻烦，一般需要下面两步：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo clean&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo g -d // 相当于 hexo g + hexo d&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;如果考虑到同步源文件，还需要每次更改后，将源文件 push 到指定仓库：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git push origin master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://depp.wang/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://depp.wang/tags/Hexo/"/>
    
      <category term="GitHub Actions" scheme="https://depp.wang/tags/GitHub-Actions/"/>
    
  </entry>
  
  <entry>
    <title>Java 的几种运算符</title>
    <link href="https://depp.wang/2020/01/11/java-operator/"/>
    <id>https://depp.wang/2020/01/11/java-operator/</id>
    <published>2020-01-11T17:58:35.000Z</published>
    <updated>2020-04-10T13:36:08.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-种移位运算符"><a href="#3-种移位运算符" class="headerlink" title="3 种移位运算符"></a>3 种移位运算符</h2><ul><li><code>&lt;&lt;</code>  : 左移运算符，<code>num &lt;&lt; 1</code>，num 转换为二进制，丢弃最左边指定位数，1 位，整体向左移动 1 位，后面补 0。<code>num &lt;&lt; 1</code> 相当于 num 乘以 2。最左位是符号位，0 为正数，1 为负数。移位后可能出现正数变负数的情况。</li><li><code>&gt;&gt;</code> : 右移运算符，<code>num &gt;&gt; 1</code>，num 转换为二进制，丢弃最右边指定位数，1 位，整体向右移动 1 位，后面补符号位，如果 num 为正数，补 0。<code>num &gt;&gt; 1</code> 相当于 num 除以 2（num 为偶数时）。<ul><li>int 类型 4 字节，移位 32  位相当于不移位，当大于 32 位时，先求余，再移位。long 类型 64 位取余。</li></ul></li><li><code>&gt;&gt;&gt;</code> : 无符号右移运算符，丢弃最右边指定位数，整体右移指定位，忽略符号位，后面空位都以 0 补齐</li></ul><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> intValue = <span class="number">733183670</span>;</span><br><span class="line">    <span class="keyword">int</span> intValue2 = -<span class="number">733183670</span>;</span><br><span class="line">    System.out.println(intValue + <span class="string">" 左移 1 位："</span> + (intValue &lt;&lt; <span class="number">1</span>)); <span class="comment">// 1466367340</span></span><br><span class="line">    System.out.println(intValue2 + <span class="string">" 左移 1 位："</span> + (intValue2 &lt;&lt; <span class="number">1</span>)); <span class="comment">// -1466367340</span></span><br><span class="line">    System.out.println(intValue + <span class="string">" 右移 8 位："</span> + (intValue &gt;&gt; <span class="number">8</span>)); <span class="comment">// 2863998 (733183670/256)</span></span><br><span class="line">    System.out.println(intValue2 + <span class="string">" 右移 8 位："</span> + (intValue2 &gt;&gt; <span class="number">8</span>)); <span class="comment">// -2863999</span></span><br><span class="line">    <span class="comment">// 无符号右移，将数据变小，且最终为正数</span></span><br><span class="line">    System.out.println(intValue + <span class="string">" 无符号右移 8 位："</span> + (intValue &gt;&gt;&gt; <span class="number">8</span>)); <span class="comment">// 2863998</span></span><br><span class="line">    System.out.println(intValue2 + <span class="string">" 无符号右移 8 位："</span> + (intValue2 &gt;&gt;&gt; <span class="number">8</span>)); <span class="comment">// 13913217</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>733183670 &lt;&lt; 1，左移 1 位：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-02-16-131127.png" alt="image.png"></p><p>-733183670 &gt;&gt; 8，右移 8 位“</p><p><img src="https://i.loli.net/2019/09/29/uh9QMjPAS2mCaKV.png" alt=""></p><p>-733183670 &gt;&gt;&gt; 8，无符号右移 8 位：</p><p><img src="https://i.loli.net/2019/09/29/nRvDGa2xfoejL59.png" alt=""></p><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><ul><li>先转换为二进制后再运算</li><li><code>&amp;</code> 按位与：<code>1&amp;1==1</code> / <code>1&amp;0==0</code> / <code>0&amp;0==0</code>，都为 1，则为 1，否则为 0</li><li><code>|</code> 按位或：<code>1|1==1</code> / <code>1|0==1</code> / <code>0|0==0</code>，有一个为 1，则为 1，否则 为 0</li><li><code>~</code> 按位非：<code>~1==0</code> / <code>~0==1</code>, 单位为 bit，整数类型的话：<code>~1==-2</code> –&gt;<code>~0b00000000000000000000000000000001==0b11111111111111111111111111111110</code></li><li><code>^</code>: 异或运算符  <code>1^1==0</code> / <code>1^0==1</code> / <code>0^0==0</code>，相同为 0，不同为 、1</li></ul><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><ul><li><code>&amp;&amp;</code> 逻辑与：当左边表达式为 false 时，不再计算，直接为 false。规则跟 <code>&amp;</code> 一致</li><li><code>||</code> 逻辑或：当左边表达式为 true 时，不再计算，直接为 true。规则跟 <code>|</code> 一致</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/30108890" target="_blank" rel="noopener">Java中的移位运算符</a></li><li><a href="https://www.jianshu.com/p/8cf5af30f245" target="_blank" rel="noopener">Java &amp;、&amp;&amp;、|、||、^、&lt;&lt;、&gt;&gt;、~、&gt;&gt;&gt;等运算符</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;3-种移位运算符&quot;&gt;&lt;a href=&quot;#3-种移位运算符&quot; class=&quot;headerlink&quot; title=&quot;3 种移位运算符&quot;&gt;&lt;/a&gt;3 种移位运算符&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;  : 左移运算符，&lt;code&gt;num &amp;lt;&amp;lt; 1&lt;/code&gt;，num 转换为二进制，丢弃最左边指定位数，1 位，整体向左移动 1 位，后面补 0。&lt;code&gt;num &amp;lt;&amp;lt; 1&lt;/code&gt; 相当于 num 乘以 2。最左位是符号位，0 为正数，1 为负数。移位后可能出现正数变负数的情况。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; : 右移运算符，&lt;code&gt;num &amp;gt;&amp;gt; 1&lt;/code&gt;，num 转换为二进制，丢弃最右边指定位数，1 位，整体向右移动 1 位，后面补符号位，如果 num 为正数，补 0。&lt;code&gt;num &amp;gt;&amp;gt; 1&lt;/code&gt; 相当于 num 除以 2（num 为偶数时）。&lt;ul&gt;
&lt;li&gt;int 类型 4 字节，移位 32  位相当于不移位，当大于 32 位时，先求余，再移位。long 类型 64 位取余。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; : 无符号右移运算符，丢弃最右边指定位数，整体右移指定位，忽略符号位，后面空位都以 0 补齐&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="https://depp.wang/categories/Java/"/>
    
    
      <category term="运算符 Operator" scheme="https://depp.wang/tags/%E8%BF%90%E7%AE%97%E7%AC%A6-Operator/"/>
    
  </entry>
  
  <entry>
    <title>2019 年买过哪些值得推荐的物品？</title>
    <link href="https://depp.wang/2020/01/03/which-recommended-items-bought-in-2019/"/>
    <id>https://depp.wang/2020/01/03/which-recommended-items-bought-in-2019/</id>
    <published>2020-01-03T14:25:08.000Z</published>
    <updated>2020-04-10T13:36:08.719Z</updated>
    
    <content type="html"><![CDATA[<p>阅读提醒，这篇文章不是技术干货。</p><p>因为前些天京东买了个免打孔单杠，用起来感觉很不错，足不出户（你知道北京室外冬天有多冷<code>^_^</code>）就能来几个引体向上，生活（身体）多了些活力。想着正好 2020 年了，你说做个总结吧，2019 年又没什么成绩，东西倒买了不少，除了单杠好像还有几个值得推荐的东西，那一块推荐一下吧，遂成了这篇软文。</p><p>我发现我买东西很怕挑选，感觉很费时间，希望能快速下单，往往最后直接买了销量最好的那个，不知道有没有小伙伴跟我一样。喜欢刷小红书的女生，大多数也是希望看看别人有什么推荐吧。</p><p><strong>温馨提醒</strong>：在京东、淘宝购买电子产品或者价格较高的商品，可以通过 <a href="http://asd-price.com/" target="_blank" rel="noopener">http://asd-price.com/</a> 查看一下商品的历史价格。</p><a id="more"></a><p>再次申明一下哈，下面不是打广告，不是打广告，关注不多，没人找我打广告 。。。</p><h2 id="个人提升"><a href="#个人提升" class="headerlink" title="个人提升"></a>个人提升</h2><h3 id="李宁室内免打孔单杠"><a href="#李宁室内免打孔单杠" class="headerlink" title="李宁室内免打孔单杠"></a>李宁室内免打孔单杠</h3><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-01-03-024348.jpg" alt=""></p><p>单杠优点是免打孔，对墙面基本没有伤害（可以垫两张纸），没有发生过脱落，挺安全。</p><ul><li><a href="https://item.jd.com/100005078689.html" target="_blank" rel="noopener">京东链接</a>，入手价：194</li></ul><h3 id="Kindle-paperwhite-4-代-8-G"><a href="#Kindle-paperwhite-4-代-8-G" class="headerlink" title="Kindle paperwhite 4 代 8 G"></a>Kindle paperwhite 4 代 8 G</h3><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-01-02-132230.jpg" alt=""></p><p>买它主要是想睡前看书，虽然手机也能看，但没这个专注，熄灯后用黑暗模式挺好。平时零碎时间也可以用，如果兜够大的话，直接揣兜更好。可以配合一个翻盖皮套，避免刮花。</p><p>可以在 <a href="https://www.jiumodiary.com/" target="_blank" rel="noopener">鸠摩搜书</a> 搜索免费书籍，推荐 <a href="https://pan.baidu.com/s/12fBAZ" target="_blank" rel="noopener">人类简史</a>。</p><p>京东平时：998，双十一和 619 一般 898，我是转转在买了二手全新，820。</p><ul><li><a href="https://item.jd.com/100000667370.html" target="_blank" rel="noopener">京东链接</a>，转转价：820</li></ul><h3 id="Suavecito-骷髅发油"><a href="#Suavecito-骷髅发油" class="headerlink" title="Suavecito 骷髅发油"></a>Suavecito 骷髅发油</h3><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-01-02-131003.jpg" alt="img" style="zoom:50%;"><p>虽然人长得一般，但发型不能乱。淘宝这款发油，使用一段时间了，应该是正品。主要用于油头，但每次弄少点，定型也挺好，主要优点是好洗。</p><ul><li><a href="https://item.taobao.com/item.htm?spm=a1z09.2.0.0.10982e8dWUoV2y&id=41149726970&_u=2rh8cg8348b" target="_blank" rel="noopener">淘宝链接</a>，入手价：103</li></ul><h2 id="食物"><a href="#食物" class="headerlink" title="食物"></a>食物</h2><h3 id="统一开小灶自热土豆牛腩饭"><a href="#统一开小灶自热土豆牛腩饭" class="headerlink" title="统一开小灶自热土豆牛腩饭"></a>统一开小灶自热土豆牛腩饭</h3><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-01-02-141438.jpg" alt=""></p><p>马上又要一年一度的大迁移了，这款是火车食物链的顶级存在，统一方便面不好吃，这个倒挺好吃</p><ul><li><a href="https://item.jd.com/100001449314.html" target="_blank" rel="noopener">京东链接</a>：入手价：43.5（2 盒）</li></ul><h3 id="拉面说重庆麻辣肉酱小面"><a href="#拉面说重庆麻辣肉酱小面" class="headerlink" title="拉面说重庆麻辣肉酱小面"></a>拉面说重庆麻辣肉酱小面</h3><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-01-02-141055.jpg" alt=""></p><p>这个还是我看 <a href="https://www.bilibili.com/video/av80809511" target="_blank" rel="noopener">司徒视频</a> 发现的，买回来尝了一下，非常辣，按 13 均价来评价的话，还行。</p><ul><li><a href="https://item.jd.com/62789652518.html" target="_blank" rel="noopener">京东链接</a>：入手价：39.9（3 盒）</li></ul><h2 id="纸质书"><a href="#纸质书" class="headerlink" title="纸质书"></a>纸质书</h2><p>好书还是需要纸质书反复翻阅，买书最好等着有活动再买。</p><h3 id="深入理解-Java-虚拟机"><a href="#深入理解-Java-虚拟机" class="headerlink" title="深入理解 Java 虚拟机"></a>深入理解 Java 虚拟机</h3><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-01-02-144526.jpg" alt=""></p><p>面试喜欢问的类加载、垃圾回收、调优，里面都有，最后两章，并发也讲得很好。</p><ul><li><a href="https://item.jd.com/11252778.html" target="_blank" rel="noopener">京东链接</a></li></ul><h3 id="高性能-MySQL"><a href="#高性能-MySQL" class="headerlink" title="高性能 MySQL"></a>高性能 MySQL</h3><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-01-02-144433.jpg" alt=""></p><p>如果你需要面试，看看这本书，索引、锁、MVVC、复制等等统统给你整明白。</p><ul><li><a href="https://item.jd.com/11220393.html" target="_blank" rel="noopener">京东链接</a></li></ul><p>其他如：Redis 开发与运维、Redis 设计与实现、Head First 设计模式、图解 HTTP、算法图解、码农翻身等也值得购买</p><h2 id="服装"><a href="#服装" class="headerlink" title="服装"></a>服装</h2><h3 id="90-分书包"><a href="#90-分书包" class="headerlink" title="90 分书包"></a>90 分书包</h3><p>作为程序员，这个书包给我的感觉就是，不像程序员背的！书包质感不错。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-22-143432.jpg" alt=""></p><ul><li><a href="https://www.xiaomiyoupin.com/detail?gid=890&spmref=YouPinPC.$SearchFilter$1.search_list.2.33739537" target="_blank" rel="noopener">有品链接</a>，入手价：179</li></ul><h3 id="安踏骚粉篮球鞋"><a href="#安踏骚粉篮球鞋" class="headerlink" title="安踏骚粉篮球鞋"></a>安踏骚粉篮球鞋</h3><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-22-143836.png" alt="image-20200322223710409"></p><p>如果你也喜欢这个颜色，说明我们是同道中人 😝。这款官方已经没卖了，链接失效，喜欢的可以淘宝淘一下</p><h3 id="一款好看的男士秋裤"><a href="#一款好看的男士秋裤" class="headerlink" title="一款好看的男士秋裤"></a>一款好看的男士秋裤</h3><ul><li><a href="https://detail.tmall.com/item.htm?spm=a1z10.3-b.w4011-2653083061.49.717b43c1SFHQoX&id=601881979477&rn=16b9b6a334caabe20e7c7b7668e52d29&abbucket=11" target="_blank" rel="noopener">天猫链接</a></li></ul><h2 id="居家"><a href="#居家" class="headerlink" title="居家"></a>居家</h2><h3 id="免打孔挂钩"><a href="#免打孔挂钩" class="headerlink" title="免打孔挂钩"></a>免打孔挂钩</h3><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-22-143827.png" alt="image-20200322223805701"></p><p>这挂钩太能挂了！粘性相当好，从来没掉过。节省空间，很方便，不用每次放衣柜</p><ul><li><a href="https://detail.tmall.com/item.htm?id=38645058899&spm=a1z09.2.0.0.10982e8dWUoV2y&_u=2rh8cg836ee" target="_blank" rel="noopener">天猫链接</a></li></ul><h3 id="网易严选四件套"><a href="#网易严选四件套" class="headerlink" title="网易严选四件套"></a>网易严选四件套</h3><h4 id="全棉条纹四件套"><a href="#全棉条纹四件套" class="headerlink" title="全棉条纹四件套"></a>全棉条纹四件套</h4><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-01-03-020603.png" alt="image-20200103100603090" style="zoom:50%;"><ul><li><a href="https://you.163.com/item/detail?id=1110003&_stat_area=15&_stat_referer=search&_stat_query=床单&_stat_count=20&_stat_searchversion=76" target="_blank" rel="noopener">购买链接</a>，入手价：差不多 250</li></ul><h4 id="全棉格子四件套"><a href="#全棉格子四件套" class="headerlink" title="全棉格子四件套"></a>全棉格子四件套</h4><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-01-03-042308.png" alt="image-20200103100732682" style="zoom:50%;"><ul><li><a href="https://you.163.com/item/detail?id=3822058&_stat_area=similar_8&_stat_referer=search&_stat_query=床单&_stat_count=12&_stat_searchversion=0.7" target="_blank" rel="noopener">购买链接</a>，入手价：255</li></ul><p>这两款四件套，是真全棉，非常厚实。很耐看</p><h3 id="隐私半透明玻璃膜"><a href="#隐私半透明玻璃膜" class="headerlink" title="隐私半透明玻璃膜"></a>隐私半透明玻璃膜</h3><ul><li><a href="https://detail.tmall.com/item.htm?id=41141158167&spm=a1z09.2.0.0.10982e8dyyl2ZV&_u=2rh8cg8945f" target="_blank" rel="noopener">天猫链接</a></li></ul><h3 id="3M-双面胶"><a href="#3M-双面胶" class="headerlink" title="3M 双面胶"></a>3M 双面胶</h3><ul><li><a href="https://detail.tmall.com/item.htm?id=40266373990&spm=a1z09.2.0.0.10982e8dyyl2ZV&_u=2rh8cg8de97" target="_blank" rel="noopener">天猫链接</a></li></ul><h2 id="电子设备相关"><a href="#电子设备相关" class="headerlink" title="电子设备相关"></a>电子设备相关</h2><h3 id="紫米苹果-18w-快充"><a href="#紫米苹果-18w-快充" class="headerlink" title="紫米苹果 18w 快充"></a>紫米苹果 18w 快充</h3><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-01-02-134510.jpg" alt=""></p><p>你肯定知道这两个小物件在苹果官网的原价</p><ul><li><a href="https://detail.tmall.com/item.htm?id=593066459068&spm=a1z09.2.0.0.10982e8dWUoV2y&_u=2rh8cg829c0&skuId=4416301435729" target="_blank" rel="noopener">天猫链接</a></li></ul><h3 id="数据线整理卡扣"><a href="#数据线整理卡扣" class="headerlink" title="数据线整理卡扣"></a>数据线整理卡扣</h3><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-01-02-134808.jpg" alt=""></p><p>「按住」无处安放的数据线</p><ul><li><a href="https://detail.tmall.com/item.htm?id=543704096025&spm=a1z09.2.0.0.10982e8dyyl2ZV&_u=2rh8cg8f391" target="_blank" rel="noopener">天猫链接</a></li></ul><h3 id="闪魔手机膜"><a href="#闪魔手机膜" class="headerlink" title="闪魔手机膜"></a>闪魔手机膜</h3><h4 id="闪魔-XR-全屏膜"><a href="#闪魔-XR-全屏膜" class="headerlink" title="闪魔 XR 全屏膜"></a>闪魔 XR 全屏膜</h4><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-22-143947.png" alt="image-20200322223946575"></p><p>两个优点：顶部就一个开孔，全屏覆盖。送的贴膜器很好用，基本上不会失败，人人都是贴膜师</p><ul><li><a href="https://detail.tmall.com/item.htm?id=560856092783&spm=a1z09.2.0.0.10982e8dWUoV2y&_u=2rh8cg8507f" target="_blank" rel="noopener">天猫链接</a></li></ul><h4 id="闪魔-OPPO-FindX-软膜"><a href="#闪魔-OPPO-FindX-软膜" class="headerlink" title="闪魔 OPPO FindX 软膜"></a>闪魔 OPPO FindX 软膜</h4><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-01-02-133839.jpg" alt=""></p><p>几乎跟出厂原装膜一模一样。题外话：感觉闪魔的膜都挺不错</p><ul><li><a href="https://detail.tmall.com/item.htm?id=575678608921&spm=a1z09.2.0.0.10982e8dWUoV2y&_u=2rh8cg83f32" target="_blank" rel="noopener">天猫链接</a></li></ul><h3 id="macOS-Pro-键盘膜"><a href="#macOS-Pro-键盘膜" class="headerlink" title="macOS Pro 键盘膜"></a>macOS Pro 键盘膜</h3><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-01-02-134203.jpg" alt=""></p><p>个人十分受不了直接触摸光滑键盘的感觉，这个膜有效缓解这一症状。用久了还发现一个优点，没有膜的常用按键会掉漆！</p><ul><li><a href="https://detail.tmall.com/item.htm?id=565302355120&spm=a1z09.2.0.0.10982e8dWUoV2y&_u=2rh8cg80655" target="_blank" rel="noopener">天猫链接</a></li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>就购买服饰鞋包来说，我发现大多数人其实不是怕花钱，而是买不到自己喜欢的。不管刷小红书，还是看淘宝直播视频，我觉得有两个目的：一是看有哪些好看的，怎么搭好看；二是想知道在哪里能买到。而小红书负责带货，淘宝负责卖。</p><!--我们能欣赏出服饰鞋包好看不好看，但设计确实比较困难，就像拍电影和评论电影一样。大众化的产品太多，也很平庸，需要不断的挖掘（逛街、手机），好的产品相对价格又较高，--><p>如果某个品牌能持续推出好设计、又有点性价比的产品，应该不愁卖吧。</p><!--公众号关注人数不多，现在几乎所有都是因为我原来分享的「10 分钟教会你科 ke 学 xue 上 shang 网 wang」关注的，这篇文章因人投诉，被微信删了，如果还想了解的小伙伴，请看 [这里](https://github.com/DeppWang/Science-Online)--><p>最近一直面试，后续会将这段时间面试的相关技术知识分享出来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阅读提醒，这篇文章不是技术干货。&lt;/p&gt;
&lt;p&gt;因为前些天京东买了个免打孔单杠，用起来感觉很不错，足不出户（你知道北京室外冬天有多冷&lt;code&gt;^_^&lt;/code&gt;）就能来几个引体向上，生活（身体）多了些活力。想着正好 2020 年了，你说做个总结吧，2019 年又没什么成绩，东西倒买了不少，除了单杠好像还有几个值得推荐的东西，那一块推荐一下吧，遂成了这篇软文。&lt;/p&gt;
&lt;p&gt;我发现我买东西很怕挑选，感觉很费时间，希望能快速下单，往往最后直接买了销量最好的那个，不知道有没有小伙伴跟我一样。喜欢刷小红书的女生，大多数也是希望看看别人有什么推荐吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;温馨提醒&lt;/strong&gt;：在京东、淘宝购买电子产品或者价格较高的商品，可以通过 &lt;a href=&quot;http://asd-price.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://asd-price.com/&lt;/a&gt; 查看一下商品的历史价格。&lt;/p&gt;
    
    </summary>
    
      <category term="Live" scheme="https://depp.wang/categories/Live/"/>
    
    
      <category term="推荐物品" scheme="https://depp.wang/tags/%E6%8E%A8%E8%8D%90%E7%89%A9%E5%93%81/"/>
    
  </entry>
  
  <entry>
    <title>&lt;译&gt; Alfred 官网 的 Workflows 帮助</title>
    <link href="https://depp.wang/2019/11/10/translate-alfred-workflows-help/"/>
    <id>https://depp.wang/2019/11/10/translate-alfred-workflows-help/</id>
    <published>2019-11-10T14:25:08.000Z</published>
    <updated>2020-04-10T13:36:08.719Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>翻译 Alfred 官网 的 <a href="https://www.alfredapp.com/help/workflows/" target="_blank" rel="noopener">Workflows 帮助</a></p></blockquote><p>使用工作流（workflows）扩展 Alfred 并以自己的方式完成工作，通过工作流替代重复性操作或基于鼠标的操作，你将提高你的工作效率。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135613.jpg" alt="To-Do List Example Workflow"></p><a id="more"></a><h2 id="概览：什么是工作流？"><a href="#概览：什么是工作流？" class="headerlink" title="概览：什么是工作流？"></a>概览：什么是工作流？</h2><p><em>工作流是 Alfred 可用的 <a href="https://www.alfredapp.com/powerpack/" target="_blank" rel="noopener">Powerpack</a> 功能的一部分。</em></p><p>你可以在 Alfred 的偏好设置中找到「Workflows」选项，查看以下内容，发现工作流如何能帮助你将重复性操作成为过去时，让你以一种你从来没有想到的方式更有效率的操作你的 Mac。</p><blockquote><p>提示: 双击工作流组件，每个组件在它的配置面板的左下角都有一个问号图标，单击可跳转至组件相关页面，以查找更多详细信息。</p></blockquote><p>想马上跳转？从内置 “Examples” 选项添加一些工作流，来看看你的第一个工作流是怎样工作的！:)</p><h2 id="工作流简介"><a href="#工作流简介" class="headerlink" title="工作流简介"></a>工作流简介</h2><ul><li><a href="#工作流组件类型">工作流组件类型</a></li><li><a href="#创建你的第一个工作流">创建你的第一个工作流</a></li><li><a href="#下载和发现工作流">下载和发现工作流</a></li><li><a href="#创建你自己的工作流">创建你自己的工作流</a></li></ul><h2 id="工作流组件类型"><a href="#工作流组件类型" class="headerlink" title="工作流组件类型"></a>工作流组件类型</h2><p>要查找特定组件的帮助，请点击下面组件链接，再在页面搜索。或者在  Alfred 偏好设置中点击组件设置左下角问号图标。</p><ul><li><a href="https://www.alfredapp.com/help/workflows/triggers/" target="_blank" rel="noopener">Triggers</a>（触发条件）：可以通过一个快捷键、另一个 Alfred 功能或者外部来源来激活 Alfred。</li><li><a href="https://www.alfredapp.com/help/workflows/inputs/" target="_blank" rel="noopener">Inputs</a>（输入）：基于关键字的组件，用于单独执行或者结合紧随的 {query} 执行。</li><li><a href="https://www.alfredapp.com/help/workflows/actions/" target="_blank" rel="noopener">Actions</a>（动作）：一个执行你工作流中大多数工作的组件，打开或者显示文件、网页搜索、运行脚本和执行命令。</li><li><a href="https://www.alfredapp.com/help/workflows/utilities/" target="_blank" rel="noopener">Utilities</a>（实用工具）：实用工具使你控制如何将组件连接到一起，以及如何将上一个组件输出的参数传递给下一个组件。</li><li><a href="https://www.alfredapp.com/help/workflows/outputs/" target="_blank" rel="noopener">Outputs</a>:（输出）：从你的工作流前面组件中收集信息，用于弹出通知中心消息，以大字体显示输出，复制到剪贴板或者运行一个包含工作流结果的脚本。</li></ul><h2 id="创建你的第一个工作流"><a href="#创建你的第一个工作流" class="headerlink" title="创建你的第一个工作流"></a>创建你的第一个工作流</h2><p>当你第一次切换到 Alfred 偏好设置中的「Workflows」选项时，左侧边栏没有活动的工作流，你可以从新增一个示例工作流开始。</p><p>单击侧边栏底部的 <code>+</code> ，你可以看见菜单里面有五个选项，依次是 Workflow Defaults（工作流默认值）、Getting Started（入门）、Examples（示例）、Templates（模板） 和 Blank Workflow（空工作流）。</p><p><strong>入门</strong> 和 <strong>示例</strong> 工作流是很好的路径去发现这些组件是做什么以及如何将它们连接到一起，Hotkeys（快捷键）和 Keywords（关键字）是较简单的两个例子。可以看看组件的 notes（注释），来理解组件之间如何相互作用。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135614.jpg" alt="Getting Started 工作流"></p><p>已经内置的工作流程 Google 搜索建议和 Amazon 搜索建议对于查看在线结果很有用。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135616.jpg" alt="Google Suggest Workflow"></p><p>在每个新版本中，我们都添加了「入门」和「示例」工作流，所以可以经常查看内置工作流。</p><h2 id="下载和发现工作流"><a href="#下载和发现工作流" class="headerlink" title="下载和发现工作流"></a>下载和发现工作流</h2><p>现在你知道了怎样使用工作流，并了解了内置的 <strong>入门</strong> 和 <strong>示例</strong>，你还将发现 Alfred 同伴用户开发了许多出色的工作流。</p><p>我们已经 <a href="https://www.alfredapp.com/workflows/" target="_blank" rel="noopener">重点介绍了一些我们最喜欢的工作流</a>，你还可以通过下面途径找到数百种工作流：</p><ul><li>在 <a href="https://www.alfredapp.com/blog/" target="_blank" rel="noopener">Alfred 博客</a> 中</li><li>在 <a href="https://alfredforum.com/" target="_blank" rel="noopener">Alfred 社区 </a>中，你可以为自己工作流寻找帮助</li><li>在 <a href="http://packal.org/" target="_blank" rel="noopener">Packal</a> 中，一个用户创建的网站，用于处理 Shawn Rice 创建的工作流和主题</li></ul><blockquote><p>注意: 你发现许多工作流可能是通过 Alfred 2 创建的。它们也应该可以在 Alfred 3 中导入并正常使用。但通过 Alfred  3 创建的工作流不向后兼容 Alfred 2。</p></blockquote><p>如果你没有找到你想要的，你可以 Google 搜索一下，许多用户选择在 GitHub 和个人网站上托管自己的工作流。</p><h2 id="创建自己的工作流"><a href="#创建自己的工作流" class="headerlink" title="创建自己的工作流"></a>创建自己的工作流</h2><p>在 Alfred 偏向设置选项工作流中，你可以看见左侧边栏右下角有一个 <code>[+]</code> 按钮，这是你创建新工作流的起点。</p><p>完整的功能 <strong>示例</strong> 向你展示不同类型的工作流如何工作，从简单的像 “Should I watch this movie?” ，到基于列表或基于脚本用于展示在线结果的工作流（例如 Google 建议和 Amazon 建议）。</p><p><strong>模板</strong> 提供了工作流画布的起点，模板可以预先填充你的工作流画布，以便你可以填补空白。</p><p>如果你希望从 <strong>空白工作流</strong> 开始，选择最下面的 “Blank Workflow”，然后右键单击画布任何区域选择你要加入工作流中的组件。</p><p>你随时可以在 Alfred 偏好设置中通过点击组件设置左下角的问号图标来寻找帮助。最重要的是，玩得开心。</p><h2 id="充分利用工作流"><a href="#充分利用工作流" class="headerlink" title="充分利用工作流"></a>充分利用工作流</h2><p>一旦你掌握了工作流的基础用法，你会发现很多改进工作流的方法，从简单的整理到和与其他 Alfred 用户分享，到使用变量和脚本来创建高级工作流。</p><ul><li><a href="https://www.alfredapp.com/help/workflow/organising-workflows/" target="_blank" rel="noopener">通过类型和默认来整理脚本</a></li><li><a href="https://www.alfredapp.com/help/workflows/advanced/sharing-workflows" target="_blank" rel="noopener">导出和分享脚本</a></li><li><a href="https://www.alfredapp.com/help/troubleshooting/workflows/" target="_blank" rel="noopener">工作流的故障排除</a></li><li><a href="https://www.alfredapp.com/help/workflows/utilities/debug/" target="_blank" rel="noopener">使用工作流的调试程序</a></li></ul><h2 id="高级工作流主题"><a href="#高级工作流主题" class="headerlink" title="高级工作流主题"></a>高级工作流主题</h2><ul><li><a href="https://www.alfredapp.com/help/workflows/advanced/variables/" target="_blank" rel="noopener">在工作流中设置变量</a></li><li><a href="https://www.alfredapp.com/help/workflows/script-environment-variables/" target="_blank" rel="noopener">脚本环境变量</a></li><li><a href="https://www.alfredapp.com/help/workflows/advanced/alternative-actions/" target="_blank" rel="noopener">在工作流中使用替代动作</a></li><li><a href="https://www.alfredapp.com/help/workflows/inputs/script-filter/" target="_blank" rel="noopener">使用脚本过滤器对象</a></li></ul><p>在工作流方面需要帮助？在 <a href="https://www.alfredforum.com/" target="_blank" rel="noopener">Alfred 论坛</a> 和创作者沟通并寻找你问题的答案吧。:)</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;翻译 Alfred 官网 的 &lt;a href=&quot;https://www.alfredapp.com/help/workflows/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Workflows 帮助&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用工作流（workflows）扩展 Alfred 并以自己的方式完成工作，通过工作流替代重复性操作或基于鼠标的操作，你将提高你的工作效率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135613.jpg&quot; alt=&quot;To-Do List Example Workflow&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Software &amp; Website" scheme="https://depp.wang/categories/Software-Website/"/>
    
    
      <category term="Alfred" scheme="https://depp.wang/tags/Alfred/"/>
    
      <category term="Workflows" scheme="https://depp.wang/tags/Workflows/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 笔记</title>
    <link href="https://depp.wang/2019/10/30/mysql-note/"/>
    <id>https://depp.wang/2019/10/30/mysql-note/</id>
    <published>2019-10-30T14:25:08.000Z</published>
    <updated>2020-04-10T13:36:08.719Z</updated>
    
    <content type="html"><![CDATA[<p>大部分内容总结于 <a href="https://www.liaoxuefeng.com/wiki/1177760294764384" target="_blank" rel="noopener">《廖雪峰 SQL 笔记》</a></p><h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>选取主键的一个基本原则是：不使用任何业务相关的字段（id）作为主键。修改了主键，会造成一系列的影响</p><p>类型：</p><ol><li>自增整数类型（id）：<code>BIGINT NOT NULL AUTO_INCREMENT</code>。</li><li>全局唯一 GUID 类型</li></ol><p>注意：如果使用 INT 自增类型，那么当一张表的记录数超过 2147483647（约21亿）时，会达到上限而出错。使用 BIGINT自增类型则可以最多约 922 亿亿条记录。</p><a id="more"></a><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>主键默认含有索引。</p><p>即该列的值如果越互不相同，那么索引效率越高。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">INDEX</span> idx_score (score);</span><br></pre></td></tr></table></figure><p>多个索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">INDEX</span> idx_name_score (<span class="keyword">name</span>, score);</span><br></pre></td></tr></table></figure><p>唯一索引保证唯一约束，又是索引，如身份证号、邮箱等字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> uni_email (email)</span><br></pre></td></tr></table></figure><p>只建唯一约束，不建索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> uni_email <span class="keyword">UNIQUE</span> (email)</span><br></pre></td></tr></table></figure><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><p>条件查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> &lt;表名&gt; <span class="keyword">WHERE</span> &lt;条件表达式&gt; (<span class="keyword">AND</span> / <span class="keyword">OR</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">条件</th><th align="left">表达式举例1</th><th align="left">表达式举例2</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">使用 &lt;&gt; 判断不相等</td><td align="left">score &lt;&gt; 80</td><td align="left">name &lt;&gt; ‘abc’</td><td align="left">常用 &lt;&gt; 代替 Not</td></tr><tr><td align="left">使用 LIKE 判断相似</td><td align="left">name LIKE ‘ab%’</td><td align="left">name LIKE ‘%bc%’</td><td align="left">%表示任意字符，例如’ab%’将匹配’ab’，’abc’，’abcd’</td></tr></tbody></table><p>投影查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, score points, <span class="keyword">name</span> <span class="keyword">FROM</span> students; // points 为别名</span><br></pre></td></tr></table></figure><p>排序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span>, gender, score <span class="keyword">FROM</span> students <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>, gender; // 表示先按 score 列倒序，如果有相同分数的，再按 gender 列排序。</span><br></pre></td></tr></table></figure><ul><li>ORDER BY 默认正序，从小到大，DESC descend 倒序</li></ul><p>分页查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span>, gender, score</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">3</span> <span class="keyword">OFFSET</span> <span class="number">0</span>; // 第 1 页，每页 3 条</span><br><span class="line"></span><br><span class="line">LIMIT 3 OFFSET 3; // 第 2 页，每页 3 条</span><br></pre></td></tr></table></figure><ul><li><code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code> 显示从 N+1 行开始，后 M 条记录。</li></ul><p>聚合查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) boys <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> gender = <span class="string">'M'</span>;</span><br></pre></td></tr></table></figure><ul><li>COUNT(*)、COUNT(id)、可用 WHERE 条件</li><li>其他函数：SUM、AVG、MAX、MIN</li><li>如果是字符类型，MAX() 和 MIN() 会返回排序最后和排序最前的字符</li><li>结合 GROUP BY 分组：<code>SELECT class_id, COUNT(*) num FROM students GROUP BY class_id;</code></li><li>多个列分组：<code>SELECT class_id, gender, COUNT(*) num FROM students GROUP BY class_id, gender;</code></li></ul><p>多表查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> students, classes; // 同时查询 students 表和 classes 表的“乘积”</span><br></pre></td></tr></table></figure><p>连接查询</p><ul><li><p>先确定一个主表作为结果集，然后，把其他表的行有选择性地「连接」在主表结果集上。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line"><span class="keyword">FROM</span> students s</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> classes c</span><br><span class="line"><span class="keyword">ON</span> s.class_id = c.id;</span><br></pre></td></tr></table></figure></li><li><p>内连接：只查询符合两个表的结果，取交集</p></li><li><p>右外连接 RIGHT OUTER JOIN：查询符合右边表所有结果，空余用 NULL 填充</p></li><li><p>左外连接 LEFT OUTER JOIN：查询符合主表所有结果，空余用 NULL 填充</p></li><li><p>FULL OUTER JOIN，并集</p></li></ul><h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><p>INSERT </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> &lt;表名&gt; (字段<span class="number">1</span>, 字段<span class="number">2</span>, ...) <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>, ...);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (class_id, <span class="keyword">name</span>, gender, score) <span class="keyword">VALUES</span></span><br><span class="line">  (<span class="number">1</span>, <span class="string">'大宝'</span>, <span class="string">'M'</span>, <span class="number">87</span>),</span><br><span class="line">  (<span class="number">2</span>, <span class="string">'二宝'</span>, <span class="string">'M'</span>, <span class="number">81</span>);</span><br></pre></td></tr></table></figure><p>UPDATE</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> &lt;表名&gt; <span class="keyword">SET</span> 字段<span class="number">1</span>=值<span class="number">1</span>, 字段<span class="number">2</span>=值<span class="number">2</span>, ... <span class="keyword">WHERE</span> ...;</span><br></pre></td></tr></table></figure><ul><li>WHERE 跟 SELECT 的 WHERE 一样使用</li><li><code>UPDATE students SET score=60;</code> 修改表的所有数据，先用 SELECT 语句测试</li></ul><p>DELETE</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> &lt;表名&gt; <span class="keyword">WHERE</span> ...;</span><br></pre></td></tr></table></figure><ul><li><code>DELETE FROM students;</code> 删除表所有数据</li></ul><h2 id="库-表-列-SQL"><a href="#库-表-列-SQL" class="headerlink" title="库/表/列 SQL"></a>库/表/列 SQL</h2><p>也可以只安装 MySQL Client，然后连接到远程 MySQL Server。假设远程 MySQL Server 的 IP 地址是 10.0.1.99，那么就使用 -h 指定 IP 或域名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h 10.0.1.99 -u root -p</span><br></pre></td></tr></table></figure><p><strong>库</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">DATABASES</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure><p><strong>表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLES</span>; </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`students`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`class_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`gender`</span> <span class="built_in">varchar</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`score`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line">DESC students; // <span class="keyword">describe</span>，查看表结构</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> students; // 查看创建表的语句</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> students; // 删除表</span><br></pre></td></tr></table></figure><ul><li>bigint(20) 后面的 20 指的是字段的长度。最长不超过 20 位（922亿亿）</li><li>NOT NULL：插入数据时，必须有值</li><li>CHARSET( character set )</li><li>ENGINE=InnoDB DEFAULT：默认引擎 InnoDB</li></ul><p><strong>列</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> birth <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>; // 给 students 表新增一列 birth</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students <span class="keyword">CHANGE</span> <span class="keyword">COLUMN</span> birth birthday <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>; // 把列名改为 birthday，类型改为 VARCHAR(20)</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> studens <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> birthday; // 删除 birthday 列</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXIT // 退出</span><br></pre></td></tr></table></figure><h2 id="实用-SQL"><a href="#实用-SQL" class="headerlink" title="实用 SQL"></a>实用 SQL</h2><p>插入或替换</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REPLACE</span> <span class="keyword">INTO</span> students (<span class="keyword">id</span>, class_id, <span class="keyword">name</span>, gender, score) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="string">'小明'</span>, <span class="string">'F'</span>, <span class="number">99</span>);</span><br></pre></td></tr></table></figure><p>插入或更新</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (<span class="keyword">id</span>, class_id, <span class="keyword">name</span>, gender, score) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="string">'小明'</span>, <span class="string">'F'</span>, <span class="number">99</span>) <span class="keyword">ON</span> <span class="keyword">DUPLICATE</span> <span class="keyword">KEY</span> <span class="keyword">UPDATE</span> <span class="keyword">name</span>=<span class="string">'小明'</span>, gender=<span class="string">'F'</span>, score=<span class="number">99</span>;</span><br></pre></td></tr></table></figure><p>插入或忽略：存在就忽略</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">IGNORE</span> <span class="keyword">INTO</span> students (<span class="keyword">id</span>, class_id, <span class="keyword">name</span>, gender, score) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="string">'小明'</span>, <span class="string">'F'</span>, <span class="number">99</span>);</span><br></pre></td></tr></table></figure><p>快照：复制当前表的数据到一个新表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 对 class_id=1 的记录进行快照，并存储为新表 students_of_class1:</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> students_of_class1 <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> class_id=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>写入查询结果集</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">statistics</span> (class_id, average) <span class="keyword">SELECT</span> class_id, <span class="keyword">AVG</span>(score) <span class="keyword">FROM</span> students <span class="keyword">GROUP</span> <span class="keyword">BY</span> class_id;</span><br></pre></td></tr></table></figure><p>处理数据表被锁</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show open tables where in_use&gt;0; // 查看表是否被锁</span><br><span class="line">show processlist // 查看所有进程</span><br><span class="line">kill id // 杀进程</span><br></pre></td></tr></table></figure><p>用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="keyword">concat</span>(<span class="string">'User:'''</span>,<span class="keyword">USER</span>,<span class="string">'''@'''</span>,HOST,<span class="string">''';'</span>) <span class="keyword">AS</span> <span class="keyword">QUERY</span> <span class="keyword">FROM</span> mysql. <span class="keyword">USER</span>; // 查看数据库的所有用户</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">grants</span> <span class="keyword">for</span> <span class="string">'label'</span>@<span class="string">'%'</span> // 查看用户所有表的权限</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'label'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'label123'</span>;  // 创建用户</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'label'</span>@<span class="string">'localhost'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'label123'</span>; // 创建用户</span><br></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>这种把多条语句作为一个整体进行操作的功能，被称为数据库 「事务」。</p><p>对于单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为<em>隐式事务</em>。</p><p>使用<code>BEGIN</code>开启一个事务，使用<code>COMMIT</code>提交一个事务，这种事务被称为 <em>显式事务</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance = balance - <span class="number">100</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance = balance + <span class="number">100</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>; // 如果 <span class="keyword">COMMIT</span> 语句执行失败了，整个事务也会失败。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance = balance - <span class="number">100</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance = balance + <span class="number">100</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span>; // 回滚前面执行的 sql</span><br></pre></td></tr></table></figure><p>事务有四大特性：原子性：不可分割，要么成功，要么失败；一致性：事务完成后，所有数据的状态是一致的。隔离性：并发执行的事务，对数据的操作要具有隔离性；持久性：事务完成后，数据就持久化到数据库中</p><p>事务有隔离性有级别，共 4 种，隔离级别由低到高</p><table><thead><tr><th align="left">Isolation Level</th><th align="left">脏读（Dirty Read）</th><th align="left">不可重复读（Non Repeatable Read）</th><th align="left">幻读（Phantom Read）</th></tr></thead><tbody><tr><td align="left">Read Uncommitted</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">Yes</td></tr><tr><td align="left">Read Committed</td><td align="left">-</td><td align="left">Yes</td><td align="left">Yes</td></tr><tr><td align="left">Repeatable Read</td><td align="left">-</td><td align="left">-</td><td align="left">Yes</td></tr><tr><td align="left">Serializable</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from students;</span><br><span class="line">+<span class="comment">----+-------+</span></span><br><span class="line">| id | name  |</span><br><span class="line">+<span class="comment">----+-------+</span></span><br><span class="line">|  1 | Alice |</span><br><span class="line">+<span class="comment">----+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="Read-Uncommitted（可读到未提交）"><a href="#Read-Uncommitted（可读到未提交）" class="headerlink" title="Read Uncommitted（可读到未提交）"></a>Read Uncommitted（可读到未提交）</h3><p>一个事务可以读到另一个事务更新，但未提交的数据。如果另一个事务回滚，当前读取的值就是脏数据，称为脏读。</p><table><thead><tr><th align="left">时刻</th><th align="left">事务 A</th><th align="left">事务 B</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</td><td align="left">SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</td></tr><tr><td align="left">2</td><td align="left">BEGIN;</td><td align="left">BEGIN;</td></tr><tr><td align="left">3</td><td align="left">UPDATE students SET name = ‘Bob’ WHERE id = 1;</td><td align="left"></td></tr><tr><td align="left">4</td><td align="left"></td><td align="left">SELECT * FROM students WHERE id = 1; // ‘Bob’</td></tr><tr><td align="left">5</td><td align="left">ROLLBACK;</td><td align="left"></td></tr><tr><td align="left">6</td><td align="left"></td><td align="left">SELECT * FROM students WHERE id = 1; // ‘Alice’</td></tr><tr><td align="left">7</td><td align="left"></td><td align="left">COMMIT;</td></tr></tbody></table><h3 id="Read-Commited（可读到已提交）"><a href="#Read-Commited（可读到已提交）" class="headerlink" title="Read Commited（可读到已提交）"></a>Read Commited（可读到已提交）</h3><p>存在不可重复读的问题，事务重复读时，可能数据不一致。</p><table><thead><tr><th align="left">时刻</th><th align="left">事务A</th><th align="left">事务B</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</td><td align="left">SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</td></tr><tr><td align="left">2</td><td align="left">BEGIN;</td><td align="left">BEGIN;</td></tr><tr><td align="left">3</td><td align="left"></td><td align="left">SELECT * FROM students WHERE id = 1; // ‘Alice’</td></tr><tr><td align="left">4</td><td align="left">UPDATE students SET name = ‘Bob’ WHERE id = 1;</td><td align="left"></td></tr><tr><td align="left">5</td><td align="left">COMMIT;</td><td align="left"></td></tr><tr><td align="left">6</td><td align="left"></td><td align="left">SELECT * FROM students WHERE id = 1; // ‘Bob’</td></tr><tr><td align="left">7</td><td align="left"></td><td align="left">COMMIT;</td></tr></tbody></table><ul><li>第一种情况：两次读取都是 Alice</li></ul><h3 id="Repeatable-Commited（可重复读）"><a href="#Repeatable-Commited（可重复读）" class="headerlink" title="Repeatable Commited（可重复读）"></a>Repeatable Commited（可重复读）</h3><p>存在幻读的问题，幻读就是没有读取的记录，以为不存在，但可以更新成功，再次读取时，就出现了。</p><table><thead><tr><th align="left">时刻</th><th align="left">事务A</th><th align="left">事务B</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</td><td align="left">SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</td></tr><tr><td align="left">2</td><td align="left">BEGIN;</td><td align="left">BEGIN;</td></tr><tr><td align="left">3</td><td align="left"></td><td align="left">SELECT * FROM students WHERE id = 99; // Empty</td></tr><tr><td align="left">4</td><td align="left">INSERT INTO students (id, name) VALUES (99, ‘Bob’);</td><td align="left"></td></tr><tr><td align="left">5</td><td align="left">COMMIT;</td><td align="left"></td></tr><tr><td align="left">6</td><td align="left"></td><td align="left">SELECT * FROM students WHERE id = 99; // Empty</td></tr><tr><td align="left">7</td><td align="left"></td><td align="left">UPDATE students SET name = ‘Alice’ WHERE id = 99;</td></tr><tr><td align="left">8</td><td align="left"></td><td align="left">SELECT * FROM students WHERE id = 99; // Alice</td></tr><tr><td align="left">9</td><td align="left"></td><td align="left">COMMIT;</td></tr></tbody></table><p>其实幻读影响不大，没有脏读和不可重复读的问题，Mysql 默认隔离级别就是 Repeatable Commited。</p><ul><li>第一种情况：两次读取都是 Alice</li><li>第二种情况：两次读取都是 Alice</li></ul><h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p>串行操作，没有并发。</p><table><thead><tr><th align="left">时刻</th><th align="left">事务A</th><th align="left">事务B</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">SET TRANSACTION ISOLATION LEVEL Serializable;</td><td align="left">SET TRANSACTION ISOLATION LEVEL Serializable;</td></tr></tbody></table><p>上面三种情况均会报错。</p><hr><p>数据库语句顺序</p><ul><li>写的顺序：select … from… where…. group by… having… order by.. limit [offset,] (rows)</li><li>执行顺序：from… where…group by… having…. select … order by… limit</li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">select</span> host,<span class="keyword">user</span> <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135809.jpg" alt="image-20191126122815557"></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> host,<span class="keyword">user</span>,<span class="keyword">password</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135810.jpg" alt="image-20191126123141389"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大部分内容总结于 &lt;a href=&quot;https://www.liaoxuefeng.com/wiki/1177760294764384&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《廖雪峰 SQL 笔记》&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;主键&quot;&gt;&lt;a href=&quot;#主键&quot; class=&quot;headerlink&quot; title=&quot;主键&quot;&gt;&lt;/a&gt;主键&lt;/h2&gt;&lt;p&gt;选取主键的一个基本原则是：不使用任何业务相关的字段（id）作为主键。修改了主键，会造成一系列的影响&lt;/p&gt;
&lt;p&gt;类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自增整数类型（id）：&lt;code&gt;BIGINT NOT NULL AUTO_INCREMENT&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;全局唯一 GUID 类型&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意：如果使用 INT 自增类型，那么当一张表的记录数超过 2147483647（约21亿）时，会达到上限而出错。使用 BIGINT自增类型则可以最多约 922 亿亿条记录。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="https://depp.wang/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://depp.wang/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>什么是测试驱动开发？（TDD）</title>
    <link href="https://depp.wang/2019/10/08/what-is-the-test-driven-development/"/>
    <id>https://depp.wang/2019/10/08/what-is-the-test-driven-development/</id>
    <published>2019-10-08T00:30:01.000Z</published>
    <updated>2020-04-10T13:36:08.719Z</updated>
    
    <content type="html"><![CDATA[<p>测试驱动开发简称 TDD，英文全称 Test Driven Development</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135819.jpg" alt=""></p><ul><li>结对编程：一个写，一个看；另一个写，一个看</li></ul><p>编写一个函数，返回小于给定 max 值的所有素数组成的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getPrimes(<span class="keyword">int</span> max)</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="1、思考"><a href="#1、思考" class="headerlink" title="1、思考"></a>1、思考</h2><p>任务分解</p><ul><li>边界条件：getPrimes(2)、getPrimes(0)、getPrimes(-1)</li><li>正常输入：getPrimes(9)、getPrimes(17)、getPrimes(30)</li></ul><h2 id="2、运行失败"><a href="#2、运行失败" class="headerlink" title="2、运行失败"></a>2、运行失败</h2><p>写一个测试用例，运行失败（Tests failed）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeUtilTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetPrimesForeEmptyResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] expected = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        Assert.assertArrayEquals(expected, PrimeUtil.getPrimes(<span class="number">2</span>));</span><br><span class="line">        Assert.assertArrayEquals(expected, PrimeUtil.getPrimes(<span class="number">0</span>));</span><br><span class="line">        Assert.assertArrayEquals(expected, PrimeUtil.getPrimes(-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getPrimes(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、测试通过"><a href="#3、测试通过" class="headerlink" title="3、测试通过"></a>3、测试通过</h2><p>just enough 代码 1，测试通过（Tests pass）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getPrimes(<span class="keyword">int</span> max) &#123;</span><br><span class="line">        <span class="keyword">if</span> (max &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>just enough 代码 2，测试通过（Tests pass）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeUtilTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetPrimesForeEmptyResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] expected = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        Assert.assertArrayEquals(expected, PrimeUtil.getPrimes(<span class="number">2</span>));</span><br><span class="line">        Assert.assertArrayEquals(expected, PrimeUtil.getPrimes(<span class="number">0</span>));</span><br><span class="line">        Assert.assertArrayEquals(expected, PrimeUtil.getPrimes(-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetPrimes</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Assert.assertArrayEquals(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;, PrimeUtil.getPrimes(<span class="number">9</span>));</span><br><span class="line">        Assert.assertArrayEquals(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;, PrimeUtil.getPrimes(<span class="number">17</span>));</span><br><span class="line">        Assert.assertArrayEquals(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>&#125;, PrimeUtil.getPrimes(<span class="number">30</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getPrimes(<span class="keyword">int</span> max) &#123;</span><br><span class="line">        <span class="keyword">if</span> (max &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span>[] newArray = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">            <span class="keyword">int</span> size = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; max; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; i / <span class="number">2</span> + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// 结束内循环</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j == i / <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">                    newArray[size++] = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            newArray = Arrays.copyOf(newArray, size); <span class="comment">// 去除数组中多余的数据</span></span><br><span class="line">            <span class="keyword">return</span> newArray;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判断是否为质数：当一个数 i 除以所有<code>大于 2，小于 i / 2 + 1</code>都不等于 0，那他就是质数。</li><li>所有：遍历<code>大于 2，小于 max</code>的所有数，判断是否为质数。</li><li>放入到数组中：通过判断此时的<code>j 是否已经是最大值，即 j = i / 2 + 1</code>。<h2 id="4、重构"><a href="#4、重构" class="headerlink" title="4、重构"></a>4、重构</h2></li></ul><p>重构代码（Refactor）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getPrimes(<span class="keyword">int</span> max) &#123;</span><br><span class="line">        <span class="comment">// 提前准备</span></span><br><span class="line">        <span class="keyword">if</span> (max &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] primes = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 控制</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">2</span>; num &lt; max; num++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime(num)) &#123;</span><br><span class="line">                primes[count++] = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        primes = Arrays.copyOf(primes, count);</span><br><span class="line">        <span class="keyword">return</span> primes;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 策略</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; num / <span class="number">2</span> + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/DeppWang/litespring" target="_blank" rel="noopener">源码</a></li></ul><h2 id="常用断言"><a href="#常用断言" class="headerlink" title="常用断言"></a>常用断言</h2><ul><li>Assert.assertEquals(expected, actual);</li><li>Assert.assertTrue(condition);</li><li>Assert.assertFalse(condition);</li><li>Assert.assertNull(condition);</li><li>Assert.assertNotNull(object);</li><li>Assert.assertArrayEquals(expecteds, actuals);</li><li>Assert.fail();</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、先写测试用例；2、根据测试用例去实现代码；3、重构代码</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;测试驱动开发简称 TDD，英文全称 Test Driven Development&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135819.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;结对编程：一个写，一个看；另一个写，一个看&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;编写一个函数，返回小于给定 max 值的所有素数组成的数组。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] getPrimes(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; max)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Programming" scheme="https://depp.wang/categories/Programming/"/>
    
    
      <category term="TDD" scheme="https://depp.wang/tags/TDD/"/>
    
  </entry>
  
  <entry>
    <title>Git 笔记：常用命令与原理</title>
    <link href="https://depp.wang/2019/09/23/git-note/"/>
    <id>https://depp.wang/2019/09/23/git-note/</id>
    <published>2019-09-23T14:32:33.000Z</published>
    <updated>2020-04-10T13:36:08.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、安装-Git"><a href="#一、安装-Git" class="headerlink" title="一、安装 Git"></a>一、安装 Git</h2><ul><li>Windows：下载并安装 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">git</a>.</li><li>Mac：使用 <a href="http://mxcl.github.com/homebrew/" target="_blank" rel="noopener">Homebrew</a>, <a href="http://www.macports.org/" target="_blank" rel="noopener">MacPorts</a> 或者下载 <a href="http://sourceforge.net/projects/git-osx-installer/" target="_blank" rel="noopener">安装程序</a>。</li><li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></li><li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code></li></ul><a id="more"></a><h2 id="二、设置-Git"><a href="#二、设置-Git" class="headerlink" title="二、设置 Git"></a>二、设置 Git</h2><p>如果需要使用 SSH 协议连接</p><p>添加 <code>SSH-Key</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"yourmail@xxx.com"</span> <span class="comment"># 第一次添加，key generator(密匙生成器)、rsa 一种算法</span></span><br><span class="line">ssh-keygen -t rsa -f ~/.ssh/id_rsa_x -C <span class="string">"yourmail@xxx.com"</span> <span class="comment"># 非第一次添加</span></span><br><span class="line"><span class="built_in">cd</span> ~/.ssh </span><br><span class="line">open ~/.ssh <span class="comment"># mac 下打开</span></span><br></pre></td></tr></table></figure><p>SSH Key 是一对，分为私钥和公钥，是非对称加密，当本地仓库需要往远程仓库 push 时，私钥加密传输内容，而只有对应的公钥才能解密，所以远程仓库需要添加公钥。</p><p> <strong>一台电脑要连多个远程仓库，可以就用一对 SSH Key。</strong>如果在一台电脑上，要为不同远程仓库对应不同私钥时，需要新增 <code>config</code> 文件，为不同远程仓库指定使用不同的私钥。</p><figure class="highlight plain"><figcaption><span>config</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 第一个账号，默认使用的账号</span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">User git</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line"></span><br><span class="line"># 第二个账号</span><br><span class="line">Host second.github.com # second 为前缀名，可以任意设置</span><br><span class="line">HostName github.com</span><br><span class="line">User git</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_2</span><br><span class="line"></span><br><span class="line"># 第三个账号</span><br><span class="line">Host e.coding.net</span><br><span class="line">User git</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_3</span><br></pre></td></tr></table></figure><ul><li>原理分析：本地 SSH 客户端（Git）使用类似 <code>git@github.com:deppwang/deppwang.github.io.git</code> 地址来连接远程仓库（可通过 <code>git remote</code> 命令查看）。<code>@</code> 后面跟的是 <code>Host</code>，<code>@github.com</code> 代表使用 id_rsa 这个私钥</li></ul><p>测试 <code>SSH-Key</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清空本地的 SSH 缓存，添加新的 SSH 密钥 到 SSH agent 中</span></span><br><span class="line">ssh-add -D</span><br><span class="line">ssh-add id_rsa</span><br><span class="line">ssh-add id_rsa_x</span><br><span class="line"></span><br><span class="line">ssh-add -l <span class="comment"># 最后确认一下新密钥已经添加成功</span></span><br><span class="line"></span><br><span class="line">ssh -T git@github.com <span class="comment"># 测试是否连接成功</span></span><br></pre></td></tr></table></figure><p>用户配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局配置 用户名 / 邮箱</span></span><br><span class="line">git config --global user.name <span class="string">"Your Name"</span></span><br><span class="line">git config --global user.email <span class="string">"email@example.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消全局 用户名 / 邮箱 配置</span></span><br><span class="line">git config --global --<span class="built_in">unset</span> user.name</span><br><span class="line">git config --global --<span class="built_in">unset</span> user.email</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入项目文件夹，单独设置每个 repo 用户名 / 邮箱</span></span><br><span class="line">git config user.email <span class="string">"xxxx@xx.com"</span></span><br><span class="line">git config user.name <span class="string">"xxxx"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --list <span class="comment"># 查看当前仓库所有配置</span></span><br><span class="line"></span><br><span class="line">git config --global color.ui <span class="literal">true</span> <span class="comment"># 显示颜色</span></span><br></pre></td></tr></table></figure><p>LF 与 CRLF</p><ul><li>LF (Line Feed) 代表换行，对应字符 <code>\n</code>，Unix 系统使用；CR(Carriage Return) ，CRLF 对应字符 <code>\r</code>，Windows 系统使用<blockquote><p>标准化 指在提交代码到 Git 版本库中时，将文本文件中的换行符 CRLF 转为 LF 的过程<br>转换 指在检出 Git 版本库代码过程中，将文本文件中的换行符 LF 转换为 CRLF 的过程</p></blockquote></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf  [<span class="literal">true</span> | input | <span class="literal">false</span>]  <span class="comment"># 全局设置</span></span><br><span class="line">git config --<span class="built_in">local</span> core.autocrlf  [<span class="literal">true</span> | input | <span class="literal">false</span>] <span class="comment"># 针对本项目设置</span></span><br></pre></td></tr></table></figure><ul><li>true 自动完成标准化与转换</li><li>input 只做标准化操作，不做转换操作</li><li>false 提交与检出的代码都保持文件原有的换行符不变</li></ul><p>Git 安装后默认为 false，常用设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf  <span class="literal">true</span> <span class="comment"># Windows</span></span><br><span class="line">git config --global core.autocrlf  input <span class="comment"># Unix</span></span><br></pre></td></tr></table></figure><p>配置别名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.st status</span><br><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.unstage <span class="string">'reset HEAD'</span></span><br><span class="line">git config --global alias.last <span class="string">'log -1'</span></span><br><span class="line">git config --global alias.lg <span class="string">"log --color --graph --pretty=format:'% Cred% h% Creset -% C(yellow)% d% Creset % s % Cgreen(% cr) % C(bold blue)&lt;% an&gt;% Creset' --abbrev-commit"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># macOS 版 Git 默认设置的别名</span></span><br><span class="line">git config --global alias.aa <span class="string">'!git add . &amp;&amp; git add -u . &amp;&amp; git status'</span></span><br><span class="line">git config --global alias.d diff</span><br><span class="line">git config --global alias.cm <span class="string">'commit -m'</span></span><br></pre></td></tr></table></figure><h2 id="三、常用命令"><a href="#三、常用命令" class="headerlink" title="三、常用命令"></a>三、常用命令</h2><p>远程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:username/repo.git <span class="comment"># 关联远程库，可关联多个</span></span><br><span class="line">git remote <span class="comment"># 查看远程库</span></span><br><span class="line">git remote -v <span class="comment"># 查看更详细信息</span></span><br><span class="line">git remote rename origin orgin2 <span class="comment">#  origin 重命名为 origin2</span></span><br><span class="line"></span><br><span class="line">git co -b dev origin/dev <span class="comment"># 将远程 dev 分支切换为本地 dev 分支</span></span><br><span class="line"></span><br><span class="line">git push origin (-u) &lt;branch-name&gt; <span class="comment"># 推送到远程分支，'-u' 参数，将当前分支和远程的 master 分支关联起来。不能 push 空到远程去</span></span><br><span class="line">git push origin :branch-name /git branch -dr &lt;remote/branch&gt; <span class="comment"># 删除远程分支</span></span><br><span class="line">git push -f origin master <span class="comment"># 回滚远程分支，让其跟本地分支一致</span></span><br><span class="line"></span><br><span class="line">git pull <span class="comment"># pull 所有的分支到本地，如果不是直接 clone 的项目，直接使用此命令会报错</span></span><br><span class="line">git fetch <span class="comment"># 拉取所有分支到本地，不 merge</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:username/repo.git <span class="comment"># clone 后 不用再关联远程库</span></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:username/repo.git new-name  <span class="comment"># 将克隆的仓库重命名为 new-name</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立本地分支和远程分支的关联，git pull 失败时执行</span></span><br><span class="line">git br --<span class="built_in">set</span>-upstream-to=origin/branch-name branch-name</span><br><span class="line">git br --<span class="built_in">set</span>-upstream branch-name origin/branch-name</span><br></pre></td></tr></table></figure><p>常规</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">git add . /git add -A  /git add --all <span class="comment"># 添加所有的文件</span></span><br><span class="line">git add -u <span class="comment"># update，add 所有 modified 文件</span></span><br><span class="line"></span><br><span class="line">git st <span class="comment"># 查看状态</span></span><br><span class="line"></span><br><span class="line">git ci -m &lt;message&gt; <span class="comment">## Commit</span></span><br><span class="line"></span><br><span class="line">git ci --amend <span class="comment"># 修改最后一次 commit，已提交到远程的 commit 不要修改</span></span><br><span class="line"></span><br><span class="line">git merge dev <span class="comment"># 将 dev 分支合并到当前分支（默认 Fast-forward 模式，看不出来合并历史）</span></span><br><span class="line">git merge --no-ff -m <span class="string">"merge with no-ff"</span> dev <span class="comment"># 禁用 Fast-forward，可以看出合并历史</span></span><br><span class="line"></span><br><span class="line">git diff &lt;file&gt; <span class="comment"># 查看修改的内容 (工作区和暂存区的不同，工作区和原来的不同)</span></span><br><span class="line">git diff HEAD -- &lt;file&gt; <span class="comment"># 查看工作区与版本库最新版本（分支的最新 commit）的不同</span></span><br><span class="line">git diff --cached &lt;file&gt; <span class="comment"># 查看暂存区和分支的不同</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span> -p &lt;file&gt; <span class="comment"># 查看当前文件 commit 记录</span></span><br><span class="line">git blame &lt;file&gt; <span class="comment"># 查看当前文件被谁修改过</span></span><br><span class="line"></span><br><span class="line">Ctrl + C <span class="comment"># 命令错误时，退出编辑页面</span></span><br><span class="line">Ctrl + Z <span class="comment"># 退出</span></span><br></pre></td></tr></table></figure><p>分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git br dev <span class="comment"># 创建分支</span></span><br><span class="line">git br -m oldName newName <span class="comment"># 修改分支名字</span></span><br><span class="line">git br <span class="comment"># 查看当前分支</span></span><br><span class="line">git br -v <span class="comment"># 查看本地分支详情</span></span><br><span class="line">git br -a <span class="comment"># 查看所有分支</span></span><br><span class="line">git br -av <span class="comment"># 查看所有分支详情</span></span><br><span class="line">git br -d dev <span class="comment"># 删除 dev 分支，只是删除了 dev 指针。</span></span><br><span class="line">git br -D &lt;branch-name&gt; <span class="comment"># 强行删除没有合并的分支</span></span><br><span class="line">git br | grep -v <span class="string">"dev"</span> | xargs git branch -D <span class="comment"># 删除除 dev 外的所有分支</span></span><br><span class="line">git co -b dev <span class="comment"># 创建并切换分支</span></span><br></pre></td></tr></table></figure><p>撤销、删除与回退</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">git co -- &lt;file&gt; <span class="comment"># 把文件在工作区的修改全部撤销掉（回到最近 git commit 或 git add 时的状态）</span></span><br><span class="line">git co -- . <span class="comment"># 全部撤销</span></span><br><span class="line"></span><br><span class="line">git unstage &lt;file&gt; <span class="comment"># 撤销 add 操作，将修改的内容放回工作区</span></span><br><span class="line">git unstage . <span class="comment"># 全部撤销</span></span><br><span class="line"></span><br><span class="line">rm file <span class="comment"># 删除工作区的文件，需要 commit 生效。删错了可以使用 `git co -- file` 还原</span></span><br><span class="line">git rm --cache &lt;file&gt; <span class="comment"># 从暂存区删除文件</span></span><br><span class="line">git rm -rf --cache &lt;file&gt; <span class="comment"># 从暂存区中清除文件文件</span></span><br><span class="line">git rm &lt;file&gt; <span class="comment"># 从分支上删除文件</span></span><br><span class="line"></span><br><span class="line">git merge --abort <span class="comment"># 撤销 pull/merge 操作，常用于 pull 冲突时</span></span><br><span class="line"></span><br><span class="line">git reset --hard HEAD^ <span class="comment"># 回退到上一版本</span></span><br><span class="line">git reset --hard &lt;commit&gt; <span class="comment"># 回退到某一版本</span></span><br></pre></td></tr></table></figure><!--HEAD 指向 master，master 指向提交，HEAD 指向当前分支 --><!--"master 分支 " 是一条线，master 是一个指针 --><!-- 创建分支 dev，创建一个指针 dev，指向相同的提交点，再把 HEAD 指向 dev，表示当前分支再 dev 上 --><!-- 如果切换分支，commit 后，再切换回 master 分支，会提示当前 master 分支比远程的 master 分支要超前 1 个提交，不提示 "git push"。??，如果是 master 分支自己 commit，会提示 "git push"--><!-- 当将两个都提交的分支合并时，不能 “快速合并”，如果有冲突，会提示 “MERGING", 手动处理冲突，add、commit--><!-- 回退之后 commit，图形化视图怎样展示？--><!-- 使用 Fast-forward 模式，删除分支后，会丢失分支信息？  --><!----- 就看不出来曾经做过合并 --><!-- 从哪个分支修改 bug 就从哪个分支创建临时分支，提交，切换，再**删除**临时分支 --><p>储藏</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git stash save <span class="string">"message"</span> <span class="comment"># 把未提交的，当前现场「储藏」起来。</span></span><br><span class="line">git stash list <span class="comment"># 查看所有的 “储藏”</span></span><br><span class="line">git stash apply <span class="comment"># 恢复不删除</span></span><br><span class="line">git stash drop <span class="comment">## 删除</span></span><br><span class="line">git stash pop <span class="comment"># 恢复顺便删除</span></span><br><span class="line">git stash apply stash@&#123;x&#125; <span class="comment"># 恢复指定下标 stash</span></span><br></pre></td></tr></table></figure><p>标签</p><!--git pull origin <name> 出现 vim 的处理步骤 --><!--1. 按键盘字母 i 进入 insert 模式 --><!--2. 修改最上面那行黄色合并信息，可以不修改 --><!--3. 按键盘左上角 "Esc"--><!--4. 输入 ":wq", 注意是冒号 + wq, 按回车键即可 --><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git tag &lt;name&gt; <span class="comment"># 打标签</span></span><br><span class="line">git tag <span class="comment"># 查看所有标签</span></span><br><span class="line">git tag &lt;name&gt; &lt;commitId&gt; <span class="comment"># 将标签打在某个 commit 上</span></span><br><span class="line">git show &lt;name&gt; <span class="comment"># 查看标签信息</span></span><br><span class="line">git tag -a &lt;name&gt; -m <span class="string">"***"</span> &lt;commitId&gt; <span class="comment"># -a 指定标签名，- </span></span><br><span class="line">git tag -d &lt;name&gt; <span class="comment"># 删除标签</span></span><br><span class="line">git push origin --tags <span class="comment"># 推送所有未推送的标签</span></span><br><span class="line">git tag -d &lt;name&gt; /git push origin :refs/tags/&lt;name&gt; <span class="comment"># 删除远程标签</span></span><br></pre></td></tr></table></figure><p>.gitignore</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忽略除 .sh/.py 结尾的其他文件</span></span><br><span class="line">*</span><br><span class="line">!*.sh</span><br><span class="line">!*.py</span><br></pre></td></tr></table></figure><ul><li>不提交本地文件：从暂存区中清除，再在.gitignore 中忽略<!--1. 在项目根目录上查看是否有.gitignore 文件，没有就用 notepad++ 新增一个。--></li></ul><!--2. 在文件中添加你要忽略的文件相对于根目录的文件路径。--><!--3. 此时你要忽略的文件已经加入版本控制了，被 Git 跟踪（track），所以即使文件路径添加进.gitignore 后，文件也没有反应。使用以下命令清除暂存区的文件 --><p>Commit</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git ci -m <span class="string">"Article updated: `date +'% Y-% m-% d % H:% M:% S'`"</span> <span class="comment"># Article updated: 2019-05-29 21:11:06</span></span><br><span class="line">git ci -m <span class="string">"`date +'% Y-% m-% d'`"</span> <span class="comment"># 2019-05-29</span></span><br><span class="line">git ci -m <span class="string">"`date`"</span></span><br><span class="line">current=<span class="string">"`date +'% Y-% m-% d % H:% M:% S'`"</span></span><br><span class="line">msg=<span class="string">"Article updated: <span class="variable">$current</span>"</span></span><br><span class="line">git ci -m <span class="string">"<span class="variable">$msg</span>"</span> <span class="comment"># Article updated: 2019-05-29 21:11:06</span></span><br><span class="line">git ci -m <span class="string">":bug: Fixing a bug."</span>  <span class="comment"># 🐛 Fixing a bug.</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://gitmoji.carloscuesta.me" target="_blank" rel="noopener">Git commit emoji</a></li></ul><p>IDEA Git</p><ul><li>IDEA 版本控制是默认记录工作区和暂存区与分支上的不同，即：直接修改工作区的内容，不同；add 到暂存区后，还是不同</li><li>IDEA 可以直接 commit 文件而不用 add，可以理解为默认帮助 add</li><li>IDEA 的 revert 相当 <code>git co -- file</code></li><li>修改 commit 描述：<code>Undo commit</code></li></ul><h2 id="四、原理"><a href="#四、原理" class="headerlink" title="四、原理"></a>四、原理</h2><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135148.png" alt="image.png"></p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135204.png" alt="image.png"></p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135209.png" alt="image.png"></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">廖雪峰大佬 Git 教程</a></li><li><a href="https://gitee.com/liaoxuefeng/learn-java/raw/master/teach/git-cheatsheet.pdf" target="_blank" rel="noopener">git-cheatsheet</a></li><li><a href="https://www.jianshu.com/p/04e9a885c5c8" target="_blank" rel="noopener">Git 之同一台电脑连接多个远程仓库</a></li><li><a href="https://stackoverflow.com/questions/4654437/how-to-set-current-date-as-git-commit-message" target="_blank" rel="noopener">How-to-set-current-date-as-git-commit-message</a></li><li><a href="https://stackoverflow.com/questions/14741383/add-date-to-git-commit-message-automatically" target="_blank" rel="noopener">Add-date-to-git-commit-message-automatically</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、安装-Git&quot;&gt;&lt;a href=&quot;#一、安装-Git&quot; class=&quot;headerlink&quot; title=&quot;一、安装 Git&quot;&gt;&lt;/a&gt;一、安装 Git&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Windows：下载并安装 &lt;a href=&quot;https://git-scm.com/download/win&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;git&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Mac：使用 &lt;a href=&quot;http://mxcl.github.com/homebrew/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Homebrew&lt;/a&gt;, &lt;a href=&quot;http://www.macports.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MacPorts&lt;/a&gt; 或者下载 &lt;a href=&quot;http://sourceforge.net/projects/git-osx-installer/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;安装程序&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;Linux (Ubuntu, Debian)：&lt;code&gt;sudo apt-get install git-core&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Linux (Fedora, Red Hat, CentOS)：&lt;code&gt;sudo yum install git-core&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Software &amp; Website" scheme="https://depp.wang/categories/Software-Website/"/>
    
    
      <category term="Git" scheme="https://depp.wang/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Linux 笔记：核心思想、常用命令以及脚本语法</title>
    <link href="https://depp.wang/2019/09/18/linux-note/"/>
    <id>https://depp.wang/2019/09/18/linux-note/</id>
    <published>2019-09-18T13:26:55.000Z</published>
    <updated>2020-04-10T13:36:08.719Z</updated>
    
    <content type="html"><![CDATA[<p>总结于 <a href="http://linux.vbird.org/linux_basic/" target="_blank" rel="noopener">《鸟哥的 Linux 私房菜 - 基础学习篇》</a> ，图片也来自于此。</p><!--可在「阅读原文」中查看其他核心笔记：如 Git 等--><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><h3 id="目录树结构（directory-tree）"><a href="#目录树结构（directory-tree）" class="headerlink" title="目录树结构（directory tree）"></a>目录树结构（directory tree）</h3><p><strong>Linux 系统是基于目录树结构的，这是它的核心思想</strong>。目录，即文件夹。Linux 系统相当于一个文件夹，Linux 系统的所有数据要么对应一个文件夹，要么就是一个文件。比如，你新建一个用户，其实就是新建了一个文件夹。一个用户对应一个文件夹。目录树结构：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135116.png" alt="图片来自《鸟哥的 Linux 私房菜 - 基础学习篇》"></p><a id="more"></a><p>上图中 <strong>长方形是文件夹</strong>， <strong>波浪形是文件</strong>，根目录是 <code>/</code> 。这个 <code>/</code> 很巧妙，在 macOS 中，假设你下载文件 test.md 到 <code>/Users/username/Desktop/</code>，那么文件会下载到桌面，最前面这个 <code>/</code> 就是根目录。如果你写成 <code>Users/username/Desktop/</code>，那么文件就会下载到<code>currentDerectory/Users/username/Desktop/</code>下。</p><p>Linux 系统使用的是目录树架构，但其实数据是存放在 <a href="https://baike.baidu.com/item/磁盘分区" target="_blank" rel="noopener">磁盘分区</a> 当中的，那么问题来了：目录树和磁盘分区是神马关系？这个时候就牵扯到一个叫「挂载（mount）」的概念了。</p><h3 id="目录树和磁盘分区的关系"><a href="#目录树和磁盘分区的关系" class="headerlink" title="目录树和磁盘分区的关系"></a>目录树和磁盘分区的关系</h3><p>挂载其实就是建立目录树和磁盘分区之间的关系。目录只是一个标识，叫什么我们可以自定义，一个磁盘分区对应一个目录。</p><p>我们经常用 U 盘，假设一个 U 盘是一个磁盘分区，我们把一个假设叫 partition1 的 U 盘插到 Windows 电脑上，可能电脑就多了个 F 盘，那么目录就是 F ，相当于将目录 F 挂载到了 U 盘上，访问 F 就可以访问 partition1 里的内容。如果再插一个假设叫 partition2 的 U 盘，系统应该就会多了一个 H 盘，相当于目录 H 就挂载到了 partition2 上。假设 F 盘下将会有一个存放很多视频的 moive 文件夹，我们可以直接将 movie 文件夹挂载到 partition2 上，这样 movie 里的视频就存到 partition2 里面了，就不占用 F 盘的空间了。</p><p>在 Linux 系统中道理也是一样的，比如在搭建 Linux 环境的时候，可以将 /home 单独挂载到一个磁盘分区上。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135121.png" alt="图片来自《鸟哥的 Linux 私房菜 - 基础学习篇》"></p><ul><li>更多内容请看鸟哥 <a href="http://linux.vbird.org/linux_basic/0130designlinux.php#partition_install" target="_blank" rel="noopener">Linux 安装模式下，磁碟分割的选择</a></li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><!--![](https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135122.jpg)--><table><thead><tr><th>命令</th><th>含义</th><th>选项</th><th>示例</th></tr></thead><tbody><tr><td></td><td></td><td><code>--help</code></td><td><code>ls --help</code></td></tr><tr><td>man</td><td>manual</td><td></td><td><code>man man</code></td></tr><tr><td>grep</td><td>file pattern searcher</td><td><code>-i, --ignore-case</code><br><code>-c, --count</code></td><td><code>grep &quot;some string&quot; &lt;file&gt;</code><br><code>grep -i &quot;some string&quot; &lt;file&gt;</code><br><code>grep -c &quot;github&quot; index.md</code> // 7</td></tr><tr><td>ls</td><td>list</td><td><code>-a, --all</code><br><code>-h, --human-readable</code><br><code>-l, --long listing format</code></td><td><code>ls -ah</code>：显示目录下所有文件夹，包括隐藏文件夹 <br> <code>ls -l</code> == <code>ll</code></td></tr><tr><td>cd</td><td>change directory</td><td></td><td><code>cd</code> 相当于 <code>cd ~</code>，<code>~</code> 当前用户根目录<br><code>cd /</code> 根目录<br><code>cd ..</code> 上一层<br><code>cd ../..</code> 上两层<br><code>cd ../&lt;directory&gt;</code> 上一层里面某个目录<br><code>cd &lt;directory&gt;/&lt;directory&gt;</code> 当前目录下的某个目录下的某个目录</td></tr><tr><td>rm</td><td>remove</td><td><code>-d, --direcorty</code><br><code>-r, --recursive</code><br><code>-f, --force</code></td><td><code>rm &lt;file&gt;</code><br><code>rm -d &lt;directory&gt;</code><br><code>rm -rf &lt;directory&gt;</code><br><code>rm *.pdf</code></td></tr><tr><td>rmdir</td><td>remove directory</td><td></td><td><code>rmdir &lt;directroy&gt;</code></td></tr><tr><td>cat</td><td>concatenate</td><td></td><td><code>cat &lt;file&gt;</code></td></tr><tr><td>mkdir</td><td>make direcotry</td><td></td><td><code>mkdir &lt;directory&gt;</code></td></tr><tr><td>touch</td><td>create a file</td><td></td><td><code>touch &lt;file&gt;</code></td></tr><tr><td>mv</td><td>move</td><td></td><td><code>mv oldname name</code><br><code>mv &lt;file&gt;/&lt;directory&gt; &lt;directory&gt;</code></td></tr><tr><td>cp</td><td>copy</td><td><code>-R</code></td><td><code>cp test test.bak</code><br><code>cp -R &lt;direction&gt; &lt;direction&gt;</code></td></tr><tr><td>pwd</td><td>print working directory</td><td></td><td><code>pwd</code></td></tr><tr><td>echo</td><td>output</td><td></td><td><code>echo &quot;some text&quot;</code></td></tr><tr><td>find</td><td>find a file or derectory</td><td></td><td><code>find path -name filename</code><br> <code>find . -name index.js</code></td></tr><tr><td>zip</td><td></td><td><code>-r, --recurse</code></td><td><code>zip -r test.zip test/</code></td></tr><tr><td>unzip</td><td></td><td></td><td><code>unzip test.zip</code></td></tr><tr><td>tar</td><td>tape or archive</td><td><code>-f, --file=ARCHIVE</code><br><code>-c, --create</code><br><code>-t, --list</code><br><code>-v, --verbose</code><br><code>-x, --extract</code><br><code>-z, --gzip, --gunzip, --ungzip</code></td><td><code>tar -cf archive.tar foo bar</code>：将文件 foo 和 bar 创建为 archive.tar<br><code>tar -tvf archive.tar</code>： 详细列出 archive.tar 中所有文件<br><code>tar -xf archive.tar</code>：从 archive.tar 中提取所有文件<br><code>tar xvzf redis-stable.tar.gz</code>：从 <code>redis-stable.tar.gz</code> 中详细提取所有文件</td></tr><tr><td>sh</td><td>run a script</td><td></td><td><code>sh test.sh</code> 相当于 <code>./test.sh</code></td></tr><tr><td>start</td><td></td><td></td><td><code>start notepad++ &lt;file&gt;</code><br><code>start Typora &lt;file&gt;</code></td></tr><tr><td>vi</td><td>visual</td><td></td><td><code>vi &lt;file&gt;</code></td></tr><tr><td>vim</td><td>vi improved</td><td></td><td><code>vim &lt;file&gt;</code></td></tr></tbody></table><h3 id="vi-vim-的三种模式"><a href="#vi-vim-的三种模式" class="headerlink" title="vi/vim 的三种模式"></a>vi/vim 的三种模式</h3><p><code>vi &lt;file&gt;</code> 和 <code>vim &lt;file&gt;</code> 都是修改 <code>&lt;file&gt;</code> 的命令，后者为前者的增强版，输入此命令后，会有三种模式修改 <code>&lt;file&gt;</code> 文件。</p><ul><li>一般指令模式（command mode）：你看不见你输入的内容</li><li>编辑模式（insert mode）：直接修改文件内容</li><li>指令列命令模式（command-line mode）：最下面一行，<code>:</code> 或<code>/</code> 或 <code>?</code> 开头</li></ul><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135124.png" alt="图片来自《鸟哥的 Linux 私房菜 - 基础学习篇》"></p><ul><li>以下指令详细含义请看 <a href="http://linux.vbird.org/linux_basic/0310vi.php#vi" target="_blank" rel="noopener">vim 程式编辑器</a><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3></li></ul><ul><li>一般指令模式：</li></ul><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td>i</td><td>当前位置进入 insert 模式</td></tr><tr><td>I</td><td>第一个字符</td></tr><tr><td>a</td><td>下一个字符</td></tr><tr><td>A</td><td>末尾</td></tr><tr><td>o</td><td>下一列开头</td></tr><tr><td>O</td><td>上一列开头</td></tr><tr><td>r</td><td>Replace 模式，取代一次</td></tr><tr><td>R</td><td>一直取代</td></tr><tr><td>u</td><td>撤销</td></tr><tr><td>Ctrl + r</td><td>取消撤销，相当于 U？</td></tr><tr><td>0</td><td>行首</td></tr><tr><td>end / $</td><td>行尾</td></tr><tr><td>G</td><td>最后一列</td></tr><tr><td>gg</td><td>1 G，第一列</td></tr><tr><td>n<code>&lt;enter&gt;</code></td><td>向下移动 n 列</td></tr><tr><td>Ctrl + f</td><td>fall，向下一页</td></tr><tr><td>Ctrl + b</td><td>before，向上一页</td></tr><tr><td>x</td><td>删除</td></tr><tr><td>X</td><td>删除前一个</td></tr><tr><td>dd</td><td>删除当前列</td></tr><tr><td>d$</td><td>删除从当前位置到列尾</td></tr><tr><td>yy (yank)</td><td>复制当前列</td></tr><tr><td>p (paste)</td><td>粘贴当前列</td></tr></tbody></table><ul><li>编辑模式：</li></ul><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td>Esc</td><td>退出编辑模式，进入一般指令模式</td></tr></tbody></table><ul><li>指令列命令模式：</li></ul><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td>:w</td><td>保存</td></tr><tr><td>:w!</td><td>强制保证</td></tr><tr><td>:q</td><td>退出</td></tr><tr><td>:q!</td><td>强制退出</td></tr><tr><td>:wq</td><td>退出并保存，相当于 <code>ZZ</code></td></tr><tr><td>/word</td><td>查找关键字</td></tr><tr><td>:set nu</td><td>显示行号</td></tr><tr><td>:1,$s/word1/word2/gc</td><td>word1 替换为 word2</td></tr></tbody></table><p><code>/word</code> 查找时，可使用 n 跳转到下一个查找结果，N 跳转到上一个查找结果</p><!--## 常用快捷键 --><h2 id="脚本语法"><a href="#脚本语法" class="headerlink" title="脚本语法"></a>脚本语法</h2><ul><li>遍历。示例：一个打印出当前路径下所有文件夹的目录的脚本，名叫 <code>traverse.sh</code> ，内容如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(ls $(PWD))</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="variable">$i</span> ];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$i</span></span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="keyword">fi</span> <span class="comment"># if 反向，代表 if 结束</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>执行脚本： <code>sh traverse.sh</code></p><ul><li>更多内容请看 <a href="http://linux.vbird.org/linux_basic/0340bashshell-scripts.php" target="_blank" rel="noopener">学习 Shell Scripts</a></li></ul><!--# $(ls <dir>) == `(ls <dir>)` example: $(ls $(PWD)) == `(ls $(PWD))`--><!--# filepath=$(ls <dir>)--><!--# for i in ${filepath}--><!--# 相当于--><!--# for i in $(ls <dir>)--><h2 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 用户</span></span><br><span class="line">passwd &lt;username&gt; <span class="comment"># 修改用户的密码</span></span><br><span class="line">whoami <span class="comment"># 查看当前用户名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 日志</span></span><br><span class="line">less &lt;file&gt; <span class="comment"># 查看最新日志</span></span><br><span class="line">tail -f &lt;file&gt; <span class="comment"># 查看实时日志</span></span><br><span class="line">grep -5 &lt;key&gt; &lt;file&gt; <span class="comment"># 查看日志 &lt;file&gt; 关键字 key 上下五行</span></span><br><span class="line">grep -5 &lt;key&gt; &lt;file1&gt; &lt;file2&gt; <span class="comment"># 输出日志 &lt;file1&gt; 关键字 key 上下五行的内容到 &lt;file2&gt; 中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 进程</span></span><br><span class="line">ps -ef|grep WeChat <span class="comment"># 查看进程名叫 WeChat 的信息，最开头的数字为 id</span></span><br><span class="line"><span class="built_in">kill</span> -9 6002（最开头的数字） <span class="comment"># 杀死进程 id 为 6002 的进程</span></span><br><span class="line"></span><br><span class="line">sed -i<span class="string">'s/word1/werd2/g'</span> &lt;file&gt; <span class="comment"># 替换 &lt;file&gt; 的 word1 为 word2（sed -- stream editor）</span></span><br><span class="line">xclip -sel c &lt; &lt;file&gt; <span class="comment"># 不打开 &lt;file&gt; 的情况下复制其内容</span></span><br><span class="line">df -h <span class="comment"># 查看磁盘分区和目录信息（df -- display free disk space）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span><span class="comment"># 输出 $PATH 的内容</span></span><br></pre></td></tr></table></figure><!--fdisk -h # 查看磁盘挂载？--><!--fdisk -l # --><!--chmod a+w -R <path/file># chmod: change file modes，修改文件的权限--><!--scp <file> root@127.0.0.1:/opt/# 本地向 Linux 传输数据--><!--scp root@127.0.0.1:/opt/<file># Linux 向本地传输数据--><!--umount /app# 取消挂载--><!--mount /dev/vdb1 trialweg # 挂载--><!--| tail | |||--><!--| wget||||--><h2 id="Bash-VS-Zsh"><a href="#Bash-VS-Zsh" class="headerlink" title="Bash VS Zsh"></a>Bash VS Zsh</h2><blockquote><p>Bash，<a href="https://zh.wikipedia.org/wiki/Unix_shell" target="_blank" rel="noopener">Unix shell</a> 的一种，能运行于大多数 <a href="https://zh.wikipedia.org/wiki/类Unix系统" target="_blank" rel="noopener">类Unix系统</a> 的操作系统之上，包括 <a href="https://zh.wikipedia.org/wiki/Linux" target="_blank" rel="noopener">Linux</a> 与 <a href="https://zh.wikipedia.org/wiki/macOS" target="_blank" rel="noopener">macOS</a> 都将它作为默认shell。</p><p>是 <a href="https://zh.wikipedia.org/wiki/Bourne_shell" target="_blank" rel="noopener">Bourne shell</a> 的后继兼容版本与开放源代码版本，它的名称来自 <a href="https://zh.wikipedia.org/wiki/Bourne_shell" target="_blank" rel="noopener">Bourne shell</a>（sh）的一个双关语（<em>Bourne again</em> / born again）：<strong>B</strong>ourne-<strong>A</strong>gain <strong>SH</strong>ell。</p><p>Bash是一个命令处理器，通常运行于文本窗口中，并能执行用户直接输入的命令。</p><p>来自 <a href="https://zh.wikipedia.org/wiki/Bash" target="_blank" rel="noopener">Bash 维基百科</a></p></blockquote><blockquote><p><strong>Z shell</strong>（<strong>Zsh</strong>）是一款可用作 [交互式](<a href="https://zh.wikipedia.org/w/index.php?title" target="_blank" rel="noopener">https://zh.wikipedia.org/w/index.php?title</a> = 交互式 &amp; action=edit&amp;redlink=1) 登录的 [shell](<a href="https://zh.wikipedia.org/wiki/" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/</a> 殼層) 及 [脚本编写](<a href="https://zh.wikipedia.org/wiki/Shell" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Shell</a> 脚本) 的 [命令解释器](<a href="https://zh.wikipedia.org/wiki/" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/</a> 命令行界面)。Zsh 对 <a href="https://zh.wikipedia.org/wiki/Bourne_shell" target="_blank" rel="noopener">Bourne shell</a> 做出了大量改进，同时加入了 <a href="https://zh.wikipedia.org/wiki/Bash" target="_blank" rel="noopener">Bash</a>、<a href="https://zh.wikipedia.org/wiki/Korn_shell" target="_blank" rel="noopener">ksh</a> 及 <a href="https://zh.wikipedia.org/wiki/Tcsh" target="_blank" rel="noopener">tcsh</a> 的某些功能。</p><p>来自 <a href="https://zh.wikipedia.org/wiki/Z_shell" target="_blank" rel="noopener">Z shell 维基百科</a></p></blockquote><p>总结： Bash 是默认 shell，Zshl 是 Bash 的增强版。有的命令 Bash 和 Zsh 不通用，如 Bash 中的 start 命令在 Zsh 总</p><h2 id="Referen-ces"><a href="#Referen-ces" class="headerlink" title="Referen ces"></a>Referen ces</h2><ul><li><a href="https://www.geeksforgeeks.org/linux-commands/" target="_blank" rel="noopener">Linux Commands</a></li><li><a href="https://medium.com/better-programming/here-are-11-console-commands-every-developer-should-know-54e348ef22fa" target="_blank" rel="noopener">Here Are 11 Console Commands Every Developer Should Know</a></li><li><a href="http://man.he.net/" target="_blank" rel="noopener">LINUX MAN PAGES ONLINE</a></li><li><a href="https://stackoverflow.com/questions/36121672/set-table-column-width-via-markdown" target="_blank" rel="noopener">Set table column width via Markdown</a></li><li><a href="https://www.rapidtables.com/code/linux/linux-current-directory.html" target="_blank" rel="noopener">How to get current working directory</a></li><li><a href="https://linuxhint.com/bash_loop_list_strings/" target="_blank" rel="noopener">Bash Loop Through a List of Strings</a></li><li><a href="https://unix.stackexchange.com/questions/211817/copy-the-contents-of-a-file-into-the-clipboard-without-displaying-its-contents" target="_blank" rel="noopener">Copy the contents of a file into the clipboard without displaying its contents</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结于 &lt;a href=&quot;http://linux.vbird.org/linux_basic/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《鸟哥的 Linux 私房菜 - 基础学习篇》&lt;/a&gt; ，图片也来自于此。&lt;/p&gt;
&lt;!--可在「阅读原文」中查看其他核心笔记：如 Git 等--&gt;

&lt;h2 id=&quot;核心思想&quot;&gt;&lt;a href=&quot;#核心思想&quot; class=&quot;headerlink&quot; title=&quot;核心思想&quot;&gt;&lt;/a&gt;核心思想&lt;/h2&gt;&lt;h3 id=&quot;目录树结构（directory-tree）&quot;&gt;&lt;a href=&quot;#目录树结构（directory-tree）&quot; class=&quot;headerlink&quot; title=&quot;目录树结构（directory tree）&quot;&gt;&lt;/a&gt;目录树结构（directory tree）&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Linux 系统是基于目录树结构的，这是它的核心思想&lt;/strong&gt;。目录，即文件夹。Linux 系统相当于一个文件夹，Linux 系统的所有数据要么对应一个文件夹，要么就是一个文件。比如，你新建一个用户，其实就是新建了一个文件夹。一个用户对应一个文件夹。目录树结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135116.png&quot; alt=&quot;图片来自《鸟哥的 Linux 私房菜 - 基础学习篇》&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://depp.wang/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://depp.wang/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>&lt;译&gt; Redis 入门：安装、客户端命令和数据类型</title>
    <link href="https://depp.wang/2019/09/11/introduction-to-redis-install-cli-commands-and-data-types/"/>
    <id>https://depp.wang/2019/09/11/introduction-to-redis-install-cli-commands-and-data-types/</id>
    <published>2019-09-11T13:26:55.000Z</published>
    <updated>2020-04-10T13:36:08.719Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译于 <a href="https://auth0.com/blog/authors/dan-arias/" target="_blank" rel="noopener">Dan Arias</a> 的 <a href="https://auth0.com/blog/introduction-to-redis-install-cli-commands-and-data-types/" target="_blank" rel="noopener">Introduction to Redis: Installation, CLI Commands, and Data Types</a></p></blockquote><p>文章虽然篇幅较长，但非常浅显易懂，是一篇很好的 Redis 入门文章。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-01-04-035301.png" alt=""></p><p>在本 Redis 教程中，可以学习到如何安装、配置 Redis，以及使用其核心数据结构用命令从存储中写入、读取、更新、删除数据。</p><h2 id="什么是-Redis？"><a href="#什么是-Redis？" class="headerlink" title="什么是 Redis？"></a>什么是 Redis？</h2><p>Redis 是一款在内存中存储数据的 Key-Value 存储，可用来做数据库、缓存和消息代理等。它是 <a href="https://github.com/antirez/redis" target="_blank" rel="noopener">开源</a> 的，目前使用 <a href="https://github.com/antirez/redis/blob/unstable/COPYING" target="_blank" rel="noopener">BSD 开源协议</a>。</p><blockquote><p>有趣的事实：Redis 的本意是「REmote DIctionary Server.（远程字典服务器）」</p></blockquote><p><a href="https://aws.amazon.com/cn/redis/" target="_blank" rel="noopener">Redis 响应时间在微妙级</a>，每秒能处理百万次的请求，满足对性能有苛刻要求的实时应用，如游戏、广告代理、金融监控等等。</p><p>他支持基本的数据结构，如 string、list、set、sort set（有序集合：可范围查找） 和 hash。还支持更高级的数据结构，如 bitmaps（位图）、hyperloglogs（超级日志）、geospatial（地理空间索引：有半径查询）。</p><a id="more"></a><p><a href="https://twitter.com/alecks" target="_blank" rel="noopener">Alex Stanciu</a>，<a href="https://auth0.com/" target="_blank" rel="noopener">Auth0</a> 身份管理团队的产品负责人，解释我们用 Redis 的一个原因：</p><blockquote><p>「我们使用 Redis 作为 Slack Bot 会话引擎的缓存层和Session 存储，因为它将数据存放在内存（RAM）中，提供了超快的读写速度；响应时间通常在 10 毫秒以下。」</p></blockquote><p>在这个 Redis 教程中，我们将学习如何在自己系统中安装 Redis，学习如何使用其核心和最常用的数据结构在 Redis 存储数据。有了这个基础，以后的文章中，我们将学习如何使用 Redis 进行缓存，Session 存储、消息传递和实时分析。我们开始吧！</p><h2 id="安装-Redis"><a href="#安装-Redis" class="headerlink" title="安装 Redis"></a>安装 Redis</h2><p>第一件事情，我们需要先安装 Redis。如果你已经安装过了，你可以跳过这一节。</p><p><a href="https://redis.io/topics/quickstart#installing-redis" target="_blank" rel="noopener">Redis 文档</a> 建议使用编译源代码的方式来安装 Redis，因为 Redis 除了工作必要的 <code>GCC 编译器</code> 和<code>libc</code>，没有其他依赖项。我们也可以通过在 <a href="https://redis.io/" target="_blank" rel="noopener"><code>redis.io</code></a> 下载最新的压缩包，或者使用始终指向最新稳定版的 URL：<a href="http://download.redis.io/redis-stable.tar.gz" target="_blank" rel="noopener"><code>http://download.redis.io/redis-stable.tar.gz</code></a>。</p><blockquote><p>Windows 用户：Redis 项目没有正式支持 Windows 系统。但是，如果你想在 Windows10 上运行，你可以 <a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10" target="_blank" rel="noopener">安装适用于 Linux 的 Windows子系统</a> 来安装运行 Redis。当你已经安装、并运行适用于 Linux 的 Windows子系统了，请通过您的 Linux 命令行，跟着本教程下面针对 Linux（在指定时） 的步骤操作。</p></blockquote><!--译注：也可以直接安装--><p>要编译 Redis，请根据以下简单步骤操作：</p><ul><li>创建一个 redis 文件夹，并切换到 redis 文件夹</li></ul><p>macOS/Linux:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir redis &amp;&amp; cd redis</span><br></pre></td></tr></table></figure><ul><li>获取最新 redis tar 包（tarball）：</li></ul><p>macOS/Linux:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O http://download.redis.io/redis-stable.tar.gz</span><br></pre></td></tr></table></figure><ul><li>解压 tar 包：</li></ul><p>macOS/Linux:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xvzf redis-stable.tar.gz</span><br></pre></td></tr></table></figure><ul><li>切换到解压后的 <code>redis-stable</code> 文件夹：</li></ul><p>macOS/Linux:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd redis-stable</span><br></pre></td></tr></table></figure><ul><li>编译 Redis：</li></ul><p>macOS/Linux:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><blockquote><p>如果您的系统中没有安装 make 包（则不能使用 make 命令），请按照 CLI（客户端应用）提供的说明安装。在 macOS 中，你可能需要下载 XCode 才能访问包含 <code>make</code> 命令和 C 编译器的命令行工具。在 Ubuntu 上安装很简单，例如，你可能希望运行以下命令来更新包管理器和安装核心包。</p></blockquote><p>Ubuntu:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br><span class="line">sudo apt install build-essential</span><br><span class="line">sudo apt-get install tcl8.5</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>需要 <code>tcl</code> 8.5 或更高版本来运行下一步的 Redis 测试。</p><ul><li>测试构建版本是否正常工作：</li></ul><p>macOS/Linux:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make test</span><br></pre></td></tr></table></figure><p>编译完成后，<code>redis-stable</code>  下的 <code>src</code> 文件夹会出现 Redis 的各种可执行文件。Redis 文档解释了 <a href="https://redis.io/topics/quickstart" target="_blank" rel="noopener">每个可执行文件的功能</a>：</p><ul><li><code>redis-server</code>: 运行 Redis Server 端本身。</li><li><code>redis-sentinel</code>: 运行 <a href="https://redis.io/topics/sentinel" target="_blank" rel="noopener">Redis Sentinel</a>, 一个用于监控和故障转移的工具。</li><li><code>redis-cli</code>: 运行 <a href="https://en.wikipedia.org/wiki/Command-line_interface" target="_blank" rel="noopener">命令行界面</a> 客户端，用于跟 Redis 交互。</li><li><code>redis-benchmark</code>: 检查 Redis 性能。</li><li><code>redis-check-aof</code> 和 <code>redis-check-dump</code>: 用于存在损坏的数据文件的罕见情况。</li></ul><p>我们将频繁使用 <code>redis-server</code> 和 <code>redis-cli</code> 这两个可执行文件。为了方便起见，我们将它们复制到一个在系统范围内都能访问的位置，这可以通过以下命令来手动完成：</p><p>macOS/Linux:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo cp src/redis-server /usr/local/bin/</span><br><span class="line">sudo cp src/redis-cli /usr/local/bin/</span><br></pre></td></tr></table></figure><p>在将 <code>redis-stable</code> 作为当前的工作目录时，也可以通过运行以下命令来自动完成此操作：</p><p>macOS/Linux:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>我们需要重新启动 shell，这些更改才能生效。一旦我们这样做了，我们就可以开始运行 Redis 了。</p><h2 id="运行-Redis"><a href="#运行-Redis" class="headerlink" title="运行 Redis"></a>运行 Redis</h2><h3 id="启动-Redis"><a href="#启动-Redis" class="headerlink" title="启动 Redis"></a>启动 Redis</h3><p>启动 Redis 服务器的最简单方法是运行 <code>redis-server</code> 命令。在一个新的 shell 窗口中，输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure><p>如果一切正常，shell 将输出一个巨大的 ASCII Redis 标志，其中显示了 Redis 版本、运行模式、服务器运行的端口以及它的 PID（<a href="http://www.linfo.org/pid.html" target="_blank" rel="noopener">进程标识号</a>）。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-01-05-020751.png" alt=""></p><p>我们启动 Redis 时没有任何显式的配置文件；因此，我们将使用内部默认配置。这对于本文的范围来说是可以接受的：理解和使用基本的 Redis 数据结构。</p><p>作为第一步，我们总是需要让 Redis 服务器运行，因为 CLI 和其他服务依赖于它工作。</p><h3 id="如何检查-Redis-是否工作"><a href="#如何检查-Redis-是否工作" class="headerlink" title="如何检查 Redis 是否工作"></a>如何检查 Redis 是否工作</h3><p>正如在 Redis 文档中提到的，外部程序使用 <a href="https://redis.io/topics/quickstart#check-if-redis-is-working" target="_blank" rel="noopener">TCP 套接字和 Redis 特定的协议</a>与 Redis 通信。Redis 协议是由 Redis 客户端库实现的，这些客户端库是用许多编程语言编写的，比如 JavaScript。但是我们不需要直接使用客户端库与 Redis 交互。我们可以使用 <code>redis-cli</code> 直接向其发送命令。要测试 Redis 是否正常工作，让我们发送 <code>ping</code> 命令。打开一个新的 shell 窗口并执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli ping</span><br></pre></td></tr></table></figure><p>如果一切正常，shell 会返回  <code>PONG</code> 。</p><p>当我们发出 <code>redis-cli ping</code> 时，我们调用了后跟命令名为 <code>ping</code> 的 <code>redis-cli</code> 可执行文件。命令名及其参数被发送到运行在 localhost: 6379上的 Redis 实例，以便对其进行处理并返回结果。</p><p>可以更改实例的主机和端口。使用 <code>-- help</code> 选项检查所有可以与 <code>redis-cli</code> 一起使用的命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --help</span><br></pre></td></tr></table></figure><p>如果我们在没有任何参数的情况下运行 <code>redis-cli</code>，程序将以交互模式启动。类似于 Python 等编程语言的 <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop" target="_blank" rel="noopener">Read-Eval-Print Loop (REPL) </a>，我们可以在 shell 中键入不同的 Redis 命令，并从 Redis 实例获得返回结果。这些命令是什么，它们做什么是本文的核心学习目标！</p><p>让我们首先学习如何使用命令操作 Redis 中的数据！</p><h2 id="在-Redis-中写入、读取、更新和删除数据"><a href="#在-Redis-中写入、读取、更新和删除数据" class="headerlink" title="在 Redis 中写入、读取、更新和删除数据"></a>在 Redis 中写入、读取、更新和删除数据</h2><p>正如我们前面所了解的，Redis 是一个键值存储，它允许我们将一些称为 <strong>value</strong>（值）的数据与 <strong>key</strong>（键）关联起来。如果我们知道用于存储数据的*确切 *键，那么稍后可以用来检索存储的数据。</p><p>如果你还没有这样做，通过执行以下命令在交互模式下运行 Redis CLI:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br></pre></td></tr></table></figure><p>当我们在 shell 提示符中看到 Redis 实例主机和端口时，我们就知道交互式 CLI 正在工作：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure><p>到了这一步，我们准备输入命令。</p><h3 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h3><p>要在 Redis 存储一个值，我们可以使用具有以下样式的 <a href="https://redis.io/commands/set" target="_blank" rel="noopener"><code>SET</code> 命令</a>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key value</span><br></pre></td></tr></table></figure><p>在英语中，它读起来像 “set key to hold value”（设置键以保留值）。但值得注意的是，如果键已经对应了一个值， <code>SET</code> 将会覆盖原来的数据。</p><p>让我们来看一个例子，在交互式 shell 中输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET service "auth0"</span><br></pre></td></tr></table></figure><blockquote><p><strong>请注意，当您键入时，交互式 shell 会建议 Redis 命令的必需参数和可选参数。</strong></p></blockquote><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-01-04-113958.png" alt="Redis CLI showing syntax suggestions"></p><p>按回车键发送命令。一旦 Redis 存储 <code>“auth0”</code> 作为 <code>service</code> 的值，它就会返回 <code>OK</code>，让我们知道一切都很顺利。Thank you, Redis！</p><h3 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h3><p>我们可以使用 <a href="https://redis.io/commands/get" target="_blank" rel="noopener">GET 命令</a> 向 Redis 获取键的值:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET key</span><br></pre></td></tr></table></figure><p>让我们来获取 <code>service</code> 的值:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET service</span><br></pre></td></tr></table></figure><p>Redis 返回 <code>&quot;auth0&quot;</code>。</p><p>如果我们获取一个从未设置过的键的值会怎么样？</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> users</span><br></pre></td></tr></table></figure><p>Redis 返回 <code>(nil)</code> ，以让我们知道键不存在于内存中。</p><p>在连接到数据库的经典 API 中，我们希望执行 <a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete" target="_blank" rel="noopener">CRUD</a> 操作: 创建、读取、更新和删除。我们分别介绍了如何使用 SET 和 GET 命令在 Redis 中创建（写入）和读取数据。我们来看看剩下的。</p><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p>如前所述，我们可以通过覆盖键原来的数据来更新键的值。</p><p>让我们创建一个新的键值对：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET framework angular</span><br></pre></td></tr></table></figure><p>但是，我们改变了想法，现在我们想要设置的是 <code>&quot;react&quot;</code>。我们可以这样覆盖它:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET framework react</span><br></pre></td></tr></table></figure><p>Redis 设置对了吗？让我们来测试一下！</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> framework</span><br></pre></td></tr></table></figure><p>Redis 确实返回 <code>&quot;react&quot;</code>，我们有点犹豫不决，现在我们想设置 <code>framework</code> 键来对应 <code>&quot;vue&quot;</code> 值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET framework vue</span><br></pre></td></tr></table></figure><p>如果我们再次运行 <code>GET framework</code>，就会得到 <code>&quot;vue&quot;</code> 。更新 / 覆盖的其他示例也无一例外。</p><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>但是，我们现在不想设置任何 <code>framework</code>，我们需要删除这个键。我们该怎么做？ 我们使用 <a href="https://redis.io/commands/del" target="_blank" rel="noopener"><code>DEL</code> 命令</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEL key</span><br></pre></td></tr></table></figure><p>让我们运行它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEL framework</span><br></pre></td></tr></table></figure><p>Redis 返回 <code>(integer) 1</code> ，以让我们知道被删除的键的数量。</p><p>仅使用三个命令：<code>SET</code>、 <code>GET</code> 和 <code>DEL</code>，我们就能够遵守四个 CRUD 操作！</p><h3 id="用引号包装字符串"><a href="#用引号包装字符串" class="headerlink" title="用引号包装字符串"></a>用引号包装字符串</h3><p>注意一些奇怪的现象：我们不必在要存储的单个字符串值上加引号。<code>SET framework angular</code> 和 <code>SET framework &quot;angular&quot;</code> 都被 Redis 接受作为一个操作来存储字符串<code>&quot;angular&quot;</code>作为键 <code>framework</code> 的值。</p><p>Redis 自动将单个字符串参数包装在引号中。因为键和值都是字符串，所以键名也是如此。我们可以使用 <code>SET &quot;framework&quot; angular</code> ，它也会工作得很好。但是，如果我们计划使用多个字符串作为键或值，我们必须要将字符串包装在引号中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET "the frameworks" "angular vue react"</span><br></pre></td></tr></table></figure><p>返回 <code>OK</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET the frameworks "angular vue react"</span><br></pre></td></tr></table></figure><p>返回  <code>(error) ERR syntax error</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET "the frameworks" angular vue react</span><br></pre></td></tr></table></figure><p>还是返回  <code>(error) ERR syntax error</code></p><p>最后，要获取该值，我们必须使用确切的键字符串：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET "the frameworks"</span><br></pre></td></tr></table></figure><p>返回  <code>&quot;angular vue react&quot;</code>。</p><h3 id="非破坏性写入"><a href="#非破坏性写入" class="headerlink" title="非破坏性写入"></a>非破坏性写入</h3><p>Redis 富有同情心，让我们可以小心地写入数据。假设我们想要创建一个键 <code>services</code> 对应值  <code>&quot;heroku aws&quot;</code> ，但是我们输入的不是 <code>SET services &quot;heroku aws&quot;</code>，而是 <code>SET service &quot;heroku aws&quot;</code>。最后一个命令将毫不留情地覆盖 <code>service</code> 的当前值。所以，Redis 给我们提供了一个叫做 <a href="https://redis.io/commands/setnx" target="_blank" rel="noopener"><code>SETNX</code></a> 的 <code>SET</code> 的非破坏版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETNX key value</span><br></pre></td></tr></table></figure><p>当且仅当键不存在时，<code>SETNX</code> 才在内存中创建一个键（<code>SET</code> if <code>N</code>ot e<code>X</code>ists）。如果键已经存在，Redis 用 <code>0</code> 表示未能存储键值对，用 <code>1</code> 表示成功。让我们尝试一下前面的场景，但是使用 <code>SETNX</code> 代替 <code>SET</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETNX service "heroku aws"</span><br></pre></td></tr></table></figure><p>正如我们所期望的那样，返回  <code>(integer) 0</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETNX services "heroku aws"</span><br></pre></td></tr></table></figure><p>这一次，返回  <code>(integer) 1</code>。好极了！</p><p>我们可以使用 <code>SETNX</code> 来防止我们意外地覆盖数据。</p><h2 id="键过期"><a href="#键过期" class="headerlink" title="键过期"></a>键过期</h2><p>当使用 Redis 创建密钥时，我们可以指定该密钥在内存中保存的时间。使用 <a href="https://redis.io/commands/expire" target="_blank" rel="noopener"><code>EXPIRE</code></a> 命令，我们可以设置一个键的过期时间，并在过期后自动删除该键：</p><p>让我们创建一个 30 秒后要删除的 <code>notification</code> 键：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET notification "Anomaly detected"</span><br><span class="line">EXPIRE notification 30</span><br></pre></td></tr></table></figure><p>这将安排 Redis 在 30 秒后删除 <code>notification</code> 键。我们可以查看时钟，并在 30 秒后检查 <code>notification</code> 是否仍然可用 ，但我们不必这样做！ Redis 提供  <a href="https://redis.io/commands/ttl" target="_blank" rel="noopener"><code>TTL</code></a>  命令，告诉我们一个键在过期并被删除之前还剩多少秒：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TTL key</span><br></pre></td></tr></table></figure><p>可能已经超过 30 秒了，所以让我们再试一次上面的例子，但是这次一执行 <code>EXPIRE</code> 就调用 <code>TTL</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET notification "Anomaly detected"</span><br><span class="line">EXPIRE notification 30</span><br><span class="line">TTL notification</span><br></pre></td></tr></table></figure><p>Redis 给我返回  <code>(integer) 27</code> ，表示 <code>notification</code> 仍然可用 27 秒。让我再等一会儿，然后再运行 <code>TTL</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TTL</span><br></pre></td></tr></table></figure><p>这一次，Redis 返回 <code>(integer) -2</code>。从 Redis 2.8 开始，<code>TTL</code> 返回：</p><ul><li>超时时间以秒为单位。</li><li><code>-2</code> 代表 key 不存在（要么没有被创建，要么已经被删除）。</li><li><code>-1</code> 代表 key 存在，但没有过期设置。</li></ul><p>我确信 30 秒已经过去了，所以 <code>-2</code> 是预料中的。当键存在但是没有设置过期时间时，我们看一下错误消息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET dialog "Continue?"</span><br><span class="line">TTL dialog</span><br></pre></td></tr></table></figure><p>正如预期的那样，在没有设置过期时间时，Redis 返回 <code>(integer) -1</code>。</p><p>需要注意的是，我们可以通过再次使用 <code>SET</code> 键来重置超时：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SET notification "Anomaly detected"</span><br><span class="line">EXPIRE notification 30</span><br><span class="line">TTL notification</span><br><span class="line">// (integer) 27</span><br><span class="line">SET notification "No anomaly detected"</span><br><span class="line">TTL notification</span><br><span class="line">// (integer) -1</span><br></pre></td></tr></table></figure><p>我们在前面了解到，使用 <code>SET</code> 与再次创建键是一样的，对于 Redis 来说，这还涉及到重置当前分配给它的任何过期时间。</p><p>我们现在在 Redis 操作数据方面有了坚实的基础。有了这些知识，我们现在可以开始探索 Redis 提供的数据类型了。</p><h2 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h2><p>Redis 远不是一个普通的键值存储，而是一个实际的 <strong>数据结构服务器</strong>，它支持不同类型的值。传统上，键值存储允许我们将字符串键映射到字符串值，而不允许其他任何操作。在 Redis，字符串键可以映射到不仅仅是一个简单的字符串。</p><p>作为一个数据结构服务器，我们也可以将数据类型称为数据结构。我们可以使用这些更加复杂的数据结构来同时在一个键中存储多个值。让我们从更高的层次来看一下这些类型。我们将在随后的章节中详细探讨每一种类型。</p><ul><li><strong>Binary-safe Strings</strong> 二进制安全字符串</li></ul><p>Redis 值的最基本类型。“二进制安全” 意味着字符串可以包含能表示为字符串的任何类型的数据：例如 PNG 图像或序列化对象。</p><ul><li><strong>Lists</strong> 列表</li></ul><p>本质上，Redis Lists 是链表。它们是字符串元素的集合，这些元素根据 <strong>插入的顺序</strong> 进行排序。</p><ul><li><strong>Sets</strong> 集合</li></ul><p>它们表示唯一的和未排序的字符串元素的集合。</p><ul><li><strong>Sorted Sets</strong> 有序集合</li></ul><p>与 Sets 类似，它们表示一组唯一的字符串元素；但是，每个字符串元素都链接到一个浮点数值，称为元素  <strong>score（分数）</strong>。在查询 Sorted Set 时，元素总是根据它们的 score 进行排序，这使我们能够始终如一地查找到 Set 中的一系列数据。</p><ul><li><strong>Hashes</strong> 哈希</li></ul><p>这些哈希（映射）由链接到字符串值的字符串字段组成。</p><ul><li><strong>Bit arrays</strong> 位数组</li></ul><p>也称为位图。它们让我们像处理位数组一样处理字符串值。</p><ul><li><strong>HyperLogLogs</strong> 超级日志</li></ul><p>一种用于估计集合 <a href="https://en.wikipedia.org/wiki/Cardinality" target="_blank" rel="noopener">基数</a> 的概率数据结构，它是对 “集合中元素的数量” 的度量</p><p>我们已经在 ”在 Redis 中写入、读取、更新和删除数据“ 部分讨论了字符串。对于本教程的其余部分，我们将集中讨论除位图和超级日志以外的所有 Redis 类型。我们将在以后的文章中访问那些处理高级 Redis 用例的文章。</p><h2 id="Lists-列表"><a href="#Lists-列表" class="headerlink" title="Lists 列表"></a>Lists 列表</h2><p>List 是有序元素的序列。例如，<code>1 2 4 5 6 90 19 3</code> 是一个数字列表。在 Redis，重要的是要注意列表是以 <a href="https://en.wikipedia.org/wiki/Linked_list" target="_blank" rel="noopener">链表</a> 的形式实现的。这对性能有一些重要的影响。向 List 的头部和尾部添加元素的速度很快，但在 List 中搜索元素的速度较慢，因为我们没法对元素进行索引访问（就像我们在数组中所做的那样）。</p><p>List 是通过使用 Redis 命令创建的，在键名后跟 push 数据。我们可以使用两个命令：<code>RPUSH</code> 和 <code>LPUSH</code>。如果键不存在，这些命令将返回一个新的 List，并将传递的参数作为元素。如果键已经存在或者不是 List，则返回一个错误。</p><h3 id="RPUSH"><a href="#RPUSH" class="headerlink" title="RPUSH"></a>RPUSH</h3><p><a href="https://redis.io/commands/rpush" target="_blank" rel="noopener"><code>RPUSH</code></a> 在 List 的末尾（尾部）插入一个新元素：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPUSH key value [value ...]</span><br></pre></td></tr></table></figure><p>让我们创建一个表示 List 的 <code>engineers</code> 键：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RPUSH engineers "Alice"</span><br><span class="line">// 1</span><br><span class="line">RPUSH engineers "Bob"</span><br><span class="line">// 2</span><br><span class="line">RPUSH engineers "Carmen"</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure><p>每次插入元素时，Redis 都会在插入之后返回 List 的长度。我们希望 <code>users</code> 列表像这样：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Alice</span> <span class="keyword">Bob </span>Carmen</span><br></pre></td></tr></table></figure><p>我们如何验证? 我们可以使用 <code>LRANGE</code> 命令。</p><h3 id="LRANGE"><a href="#LRANGE" class="headerlink" title="LRANGE"></a>LRANGE</h3><p> <code>LRANGE</code> 基于指定的开始和停止索引返回 List 的一个子集。尽管这些索引是从零开始的，但它们不同于数组索引。给定一个完整的 List，它们只是指出 List 的分区位置：从这里（开始）到这里（停止）创建一个 slice：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE key start stop</span><br></pre></td></tr></table></figure><p>要查看完整的 List，我们可以使用一个简洁的技巧：从 <code>0</code> 到它前面的元素 <code>-1</code>。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE engineers <span class="number">0</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>Redis 返回：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1) "Alice"</span><br><span class="line">2) "Bob"</span><br><span class="line">3) "Carmen"</span><br></pre></td></tr></table></figure><p>Index <code>-1</code> 将始终表示 List 中的最后一个元素。</p><p>为了得到 <code>engineers</code> 的前两个元素，我们可以用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE engineers 0 1</span><br></pre></td></tr></table></figure><h3 id="LPUSH"><a href="#LPUSH" class="headerlink" title="LPUSH"></a>LPUSH</h3><p><a href="https://redis.io/commands/lpush" target="_blank" rel="noopener"><code>LPUSH</code></a> 的作用与 <code>RPUSH</code> 相同，只是它将元素插入到 List 的前面（在头部）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSH key value [value ...]</span><br></pre></td></tr></table></figure><p>让我们把 <code>Daniel</code> 放在 <code>engineers</code> 列表的前面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPUSH engineers "Daniel"</span><br><span class="line">// 4</span><br></pre></td></tr></table></figure><p>我们现在有四名工程师，让我们验证一下 list 是否正确：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE engineers 0 -1</span><br></pre></td></tr></table></figure><p>返回如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1) "Daniel"</span><br><span class="line">2) "Alice"</span><br><span class="line">3) "Bob"</span><br><span class="line">4) "Carmen"</span><br></pre></td></tr></table></figure><p>这和我们之前的 List 是一样的，第一个元素是 <code>“Daniel”</code> ，这正是我们所期望的。</p><h3 id="多元素插入"><a href="#多元素插入" class="headerlink" title="多元素插入"></a>多元素插入</h3><p>我们在 <code>RPUSH</code> 和 <code>LPUSH</code> 的命令提示中看到，我们可以在每个命令中插入多个元素。让我们看看它的实际效果。</p><p>基于我们现有的 <code>engineers</code> 列表，让我们运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RPUSH engineers <span class="string">"Eve"</span> <span class="string">"Francis"</span> <span class="string">"Gary"</span></span><br><span class="line">// 7</span><br></pre></td></tr></table></figure><p>因为我们将它们插入到 List 的末尾，所以我们期望这三个新元素按照它们作为参数列出的相同顺序显示。让我们来验证一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE engineers 0 -1</span><br></pre></td></tr></table></figure><p>Redis 返回：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1) <span class="string">"Daniel"</span></span><br><span class="line">2) <span class="string">"Alice"</span></span><br><span class="line">3) <span class="string">"Bob"</span></span><br><span class="line">4) <span class="string">"Carmen"</span></span><br><span class="line">5) <span class="string">"Eve"</span></span><br><span class="line">6) <span class="string">"Francis"</span></span><br><span class="line">7) <span class="string">"Gary"</span></span><br></pre></td></tr></table></figure><p>如果我们对 <code>LPUSH</code> 也这样做呢：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPUSH engineers <span class="string">"Hugo"</span> <span class="string">"Ivan"</span> <span class="string">"Jess"</span></span><br><span class="line">// 10</span><br></pre></td></tr></table></figure><p>让我们看看：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE <span class="number">0</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> 1) <span class="string">"Jess"</span></span><br><span class="line"> 2) <span class="string">"Ivan"</span></span><br><span class="line"> 3) <span class="string">"Hugo"</span></span><br><span class="line"> 4) <span class="string">"Daniel"</span></span><br><span class="line"> 5) <span class="string">"Alice"</span></span><br><span class="line"> 6) <span class="string">"Bob"</span></span><br><span class="line"> 7) <span class="string">"Carmen"</span></span><br><span class="line"> 8) <span class="string">"Eve"</span></span><br><span class="line"> 9) <span class="string">"Francis"</span></span><br><span class="line">10) <span class="string">"Gary"</span></span><br></pre></td></tr></table></figure><p>当列出 <code>LPUSH</code> 和 <code>RPUSH</code> 的多个参数时，Redis 逐个地插入元素，因此，<code>“Hugo”</code>、<code>“Ivan”</code> 和 <code>“Jess”</code> 以相反的顺序出现，它们作为参数列出。</p><h3 id="LLEN"><a href="#LLEN" class="headerlink" title="LLEN"></a>LLEN</h3><p>我们可以使用 <a href="https://redis.io/commands/llen" target="_blank" rel="noopener"><code>LLEN</code></a> 命令随时查看 List 的长度：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LLEN key</span><br></pre></td></tr></table></figure><p>让我们验证一下 <code>engineers</code> 的长度确实是 <code>10</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LLEN engineers</span><br></pre></td></tr></table></figure><p>Redis 返回 <code>(integer) 10</code>。完美。</p><h3 id="从-Redis-列表中删除元素"><a href="#从-Redis-列表中删除元素" class="headerlink" title="从 Redis 列表中删除元素"></a>从 Redis 列表中删除元素</h3><p>类似于我们可以 ”弹出“ 数组中的元素，我们可以从 Redis List 的头部或尾部弹出一个元素。</p><p><a href="https://redis.io/commands/lpop" target="_blank" rel="noopener"><code>LPOP</code></a> 删除并返回 List 的第一个元素：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPOP key</span><br></pre></td></tr></table></figure><p>我们可以使用它从 List 中删除 <code>“Jess”</code> ，即第一个元素：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPOP engineers</span><br></pre></td></tr></table></figure><p>Redis 确实返回 <code>“Jess”</code>，以表明它是被删除的元素。</p><p><a href="https://redis.io/commands/rpop" target="_blank" rel="noopener"><code>RPOP</code></a> 删除并返回 List 的最后一个元素：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">RPOP key</span></span><br></pre></td></tr></table></figure><p>是时候和 <code>“Gary”</code> 说再见了，这是 List 的最后一个元素：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">RPOP engineers</span></span><br></pre></td></tr></table></figure><p>Redis 返回 <code>“Gary”</code>。</p><p>能够获得从 List 中删除的元素是非常有用的，因为我们可能想对它做一些特殊的处理。</p><p>Redis Lists 是以链表的形式实现的，因为它的开发团队设想，对于一个数据库系统来说，<a href="https://redis.io/topics/data-types-intro#redis-lists" target="_blank" rel="noopener">能够以非常快的方式将元素添加到一个非常长的列表中是至关重要的</a>。</p><h2 id="Sets-集合"><a href="#Sets-集合" class="headerlink" title="Sets 集合"></a>Sets 集合</h2><p>在 Redis 中，Set 类似于 List，只是它不为元素保持任何特定的顺序，并且每个元素必须是唯一的。</p><h3 id="SADD"><a href="#SADD" class="headerlink" title="SADD"></a>SADD</h3><p>我们使用 <a href="https://redis.io/commands/sadd" target="_blank" rel="noopener"><code>SADD</code></a> 命令创建一个 Set，该命令将指定的成员添加到键中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SADD key member [member ...]</span><br></pre></td></tr></table></figure><p>已经是集合一部分的指定成员将被忽略。如果键不存在，则创建一个新的 Set，并添加唯一指定的成员。如果键已经存在或者不是 Set，则返回一个错误。</p><p>让我们创建一个 <code>languages</code> 集合。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SADD languages <span class="string">"english"</span></span><br><span class="line">// 1</span><br><span class="line">SADD languages <span class="string">"spanish"</span></span><br><span class="line">// 1</span><br><span class="line">SADD languages <span class="string">"french"</span></span><br><span class="line">// 1</span><br></pre></td></tr></table></figure><p>在这种情况下，对于每个成员添加，Redis 返回用 <code>SADD</code> 命令添加的成员数，而不是 Set 的大小。让我们来看看实际的情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SADD languages <span class="string">"chinese"</span> <span class="string">"japanese"</span> <span class="string">"german"</span></span><br><span class="line">// 3</span><br><span class="line">SADD languages <span class="string">"english"</span></span><br><span class="line">// 0</span><br></pre></td></tr></table></figure><p>第一个命令返回 <code>3</code>，因为我们在集合中添加了三个唯一的成员。第二个命令返回 <code>0</code>，因为 <code>“english”</code> 已经是 Set 的成员。</p><h3 id="SREM"><a href="#SREM" class="headerlink" title="SREM"></a>SREM</h3><p>我们可以使用 <a href="https://redis.io/commands/srem" target="_blank" rel="noopener"><code>SREM</code></a> (set remove) 命令从 Set 中删除成员：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SREM key member [member ...]</span><br></pre></td></tr></table></figure><p>我们可以同时删除一个或多个成员：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SREM languages <span class="string">"english"</span> <span class="string">"french"</span></span><br><span class="line">// 2</span><br><span class="line">SREM languages <span class="string">"german"</span></span><br><span class="line">// 0</span><br></pre></td></tr></table></figure><p><code>SREM</code> 返回被删除的成员数。</p><h3 id="SISMEMBER"><a href="#SISMEMBER" class="headerlink" title="SISMEMBER"></a>SISMEMBER</h3><p>要验证某个成员是否是 Set 的一部分，我们可以使用 <a href="https://redis.io/commands/sismember" target="_blank" rel="noopener"><code>SISMEMBER</code></a>(Set Is Member) 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SISMEMBER key member</span><br></pre></td></tr></table></figure><p>如果元素是 Set 的一部分，则该命令返回 <code>1</code>；否则，它返回 <code>0</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SISMEMBER languages <span class="string">"spanish"</span></span><br><span class="line">// 1</span><br><span class="line">SISMEMBER languages <span class="string">"german"</span></span><br><span class="line">// 0</span><br></pre></td></tr></table></figure><p>由于我们上一节中去掉了 <code>&quot;german&quot;</code> ，所以返回 <code>0</code>。</p><h3 id="SMEMBERS"><a href="#SMEMBERS" class="headerlink" title="SMEMBERS"></a>SMEMBERS</h3><p>要显示 Set 中存在的所有成员，我们可以使用 <a href="https://redis.io/commands/smembers" target="_blank" rel="noopener"><code>SMEMBERS</code></a> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMEMBERS key</span><br></pre></td></tr></table></figure><p>让我们看看我们目前在 <code>languages</code> 集合中有哪些语言值：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">SMEMBERS languages</span></span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1) <span class="string">"chinese"</span></span><br><span class="line">2) <span class="string">"japanese"</span></span><br><span class="line">3) <span class="string">"spanish"</span></span><br></pre></td></tr></table></figure><p>由于集合不排序，Redis 可以在每次调用时以任何顺序返回元素。他们不能保证成员排序。</p><h3 id="SUNION"><a href="#SUNION" class="headerlink" title="SUNION"></a>SUNION</h3><p>我们可以非常快速地使用 set 来实现一个非常强大的功能，那就是使用 <a href="https://redis.io/commands/sunion" target="_blank" rel="noopener"><code>SUNION</code></a> 命令将它们组合起来：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUNION <span class="built_in">key</span> [<span class="built_in">key</span> ...]</span><br></pre></td></tr></table></figure><p><code>SUNION</code> 的每个参数代表一个集合，我们可以合并到一个更大的集合中。重要的是要注意，任何重复的成员将只被被列出一次。</p><p>为了看到这一点，我们首先创建一个 <code>ancient-languages</code> 集：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SADD ancient-languages <span class="string">"greek"</span></span><br><span class="line">SADD ancient-languages <span class="string">"latin"</span></span><br><span class="line">SMEMBERS ancient-languages</span><br></pre></td></tr></table></figure><p>现在，让我们创建一个 <code>languages</code> 和 <code>ancient-languages</code> 的结合体，一次看到所有的语言：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">SUNION languages ancient-languages</span></span><br></pre></td></tr></table></figure><p>我们得到以下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1) <span class="string">"greek"</span></span><br><span class="line">2) <span class="string">"spanish"</span></span><br><span class="line">3) <span class="string">"japanese"</span></span><br><span class="line">4) <span class="string">"chinese"</span></span><br><span class="line">5) <span class="string">"latin"</span></span><br></pre></td></tr></table></figure><p>如果我们将一个不存在的键传递给 <code>SUNION</code>，它将认为该键是一个空集（一个没有任何内容的集合）。</p><h2 id="Hashes-哈希"><a href="#Hashes-哈希" class="headerlink" title="Hashes 哈希"></a>Hashes 哈希</h2><p>在 Redis，Hash 是一种数据结构，它将字符串键映射为 field-value 对（字段-值对）。因此，哈希表示对象非常有用。它们的 <strong>键</strong> 是 Hash 的名称，<strong>值</strong> 表示 <code>field-name field-value</code> 的序列。我们可以这样描述一个 <code>computer</code> 对象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">computer name <span class="string">"MacBook Pro"</span> year 2015 disk 512 ram 16</span><br></pre></td></tr></table></figure><p>对象的 ”属性“ 定义为对象（<code>computer</code>）名称后面的 ”属性名“ 和 ”属性值“ 序列。回想一下，Redis 完全是关于顺序字符串的，所以我们在创建这些字符串对象时必须非常小心，我们使用正确的字符串顺序来正确地定义对象。</p><p>为了操作哈希，我们使用与字符串类似的命令，毕竟它们是字符串。</p><h3 id="写入和读取哈希数据"><a href="#写入和读取哈希数据" class="headerlink" title="写入和读取哈希数据"></a>写入和读取哈希数据</h3><h3 id="HSET"><a href="#HSET" class="headerlink" title="HSET"></a>HSET</h3><p>命令 <a href="https://redis.io/commands/hset" target="_blank" rel="noopener"><code>HSET</code></a> 将 Hash 中的 <code>field</code> (字段) 设置为 <code>value</code>。如果键不存在，则创建一个存储哈希键值对的新键。如果字段已经存在于哈希表中，则会覆盖该字段。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSET key field value</span><br></pre></td></tr></table></figure><p>让我们创建 <code>computer</code> 对象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HSET computer name <span class="string">"MacBook Pro"</span></span><br><span class="line">// 1</span><br><span class="line">HSET computer year 2015</span><br><span class="line">// 1</span><br><span class="line">HSET computer disk 512</span><br><span class="line">// 1</span><br><span class="line">HSET computer ram 16</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure><p>对于每个 <code>HSET</code> 命令，Redis 返回一个整数，如下：</p><ul><li><code>1</code>，如果 <code>field</code> 是哈希表中的一个新字段，并设置了值。</li><li><code>0</code>，如果 <code>field</code> 已经存在于哈希表中，并且该值已被更新。</li></ul><p>让我们将字段 <code>year</code> 的值更新为 <code>2018</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HSET computer year 2018</span><br><span class="line">// 0</span><br></pre></td></tr></table></figure><h3 id="HGET"><a href="#HGET" class="headerlink" title="HGET"></a>HGET</h3><p><a href="https://redis.io/commands/hget" target="_blank" rel="noopener"><code>HGET</code></a> 返回 Hash 中与字段关联的值：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">HGET</span> key <span class="meta">field</span></span><br></pre></td></tr></table></figure><p>让我们验证一下，我们把字段 <code>year</code> 的值由 <code>2015</code> 变成了 <code>2018</code>：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HGET computer <span class="built_in">year</span></span><br></pre></td></tr></table></figure><p>Redis 返回 <code>2018</code>，结果没问题。</p><h3 id="HGETALL"><a href="#HGETALL" class="headerlink" title="HGETALL"></a>HGETALL</h3><p>从哈希表中获取所有字段及其值的一个快速方法是使用 <a href="https://redis.io/commands/hgetall" target="_blank" rel="noopener"><code>HGETALL</code></a>：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">HGETALL key</span></span><br></pre></td></tr></table></figure><p>让我们来测试一下：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">HGETALL computer</span></span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1) <span class="string">"name"</span></span><br><span class="line">2) <span class="string">"MacBook Pro"</span></span><br><span class="line">3) <span class="string">"year"</span></span><br><span class="line">4) <span class="string">"2018"</span></span><br><span class="line">5) <span class="string">"disk"</span></span><br><span class="line">6) <span class="string">"512"</span></span><br><span class="line">7) <span class="string">"ram"</span></span><br><span class="line">8) <span class="string">"16"</span></span><br></pre></td></tr></table></figure><p>当提供的键参数不存在时，<code>HGETALL</code> 返回一个空列表。</p><h3 id="HMSET"><a href="#HMSET" class="headerlink" title="HMSET"></a>HMSET</h3><p>我们也可以使用 <code>HMSET</code> 一次设置多个字段：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMSET key field value [field value ...]</span><br></pre></td></tr></table></figure><p>让我们用它来创建一个 <code>tablet</code> 哈希表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMSET tablet name <span class="string">"iPad"</span> year 2016 disk 64 ram 4</span><br></pre></td></tr></table></figure><p><code>HMSET</code> 返回 <code>OK</code>，告诉我们已经成功创建了 <code>tablet</code> 哈希表。</p><h3 id="HMGET"><a href="#HMGET" class="headerlink" title="HMGET"></a>HMGET</h3><p>如果我们只想获取两个字段呢？ 我们使用 <a href="https://redis.io/commands/hmget" target="_blank" rel="noopener"><code>HMGET</code></a> 来指定我们希望从哈希表中哪些字段获得值：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">HMGET</span> key <span class="meta">field</span> [<span class="meta">field</span> ...]</span><br></pre></td></tr></table></figure><p>让我们获得 <code>tablet</code> 的 <code>disk</code> 和 <code>ram</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMGET tablet disk ram</span><br></pre></td></tr></table></figure><p>返回 <code>disk</code> 和 <code>ram</code> 的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1) <span class="string">"64"</span></span><br><span class="line">2) <span class="string">"4"</span></span><br></pre></td></tr></table></figure><p>这差不多就是在 Redis 使用哈希表的要点。您可以查看 <a href="https://redis.io/commands#hash" target="_blank" rel="noopener">哈希命令的完整列表</a> 并尝试使用它们。</p><h2 id="Sorted-Sets-有序集合"><a href="#Sorted-Sets-有序集合" class="headerlink" title="Sorted Sets 有序集合"></a>Sorted Sets 有序集合</h2><p>在 Redis 1.2 中引入的一个 Sorted Set 实质上是一个 Set：它包含 <a href="https://redis.io/topics/data-types-intro#redis-sorted-sets" target="_blank" rel="noopener">唯一的、不重复的字符串成员</a>。然而，尽管 Set 的成员是无序的（Redis 可以在 Set 的 <a href="https://redis.io/topics/data-types-intro#redis-sets" target="_blank" rel="noopener">每次调用中以任何顺序返回元素</a>) ，但是 Sorted Set 的每个成员都链接到一个称为 <strong>score（分数）</strong> 的浮点值，Redis 使用这个值来确定 Sorted Set 成员的顺序。因为 Sorted Set 的每个元素都映射到一个值，所以它也有一个类似于 Hash 的体系结构。</p><blockquote><p>在 Redis，一个有序集合可以被看作是一个集合和一个散列的混合。</p></blockquote><p>如何确定有序集合成员的顺序？ 正如 <a href="https://redis.io/topics/data-types-intro#redis-sorted-sets" target="_blank" rel="noopener">Redis 文档</a> 中所述：</p><ul><li>如果 A 和 B 是两个分数不同的成员，那么如果 A &gt; B，那么 A.score &gt; B.score。</li><li>如果  A 和 B 的分数完全相同，那么如果 A 字符串在字母顺序上大于 B 字符串，那么 A &gt; B。<strong>A 和 B 字符串不能相等，因为有序集合只有唯一的元素。</strong></li></ul><p>我们用来与 Sorted Sets 交互的一些命令类似于我们用来与 Sets 交互的命令：我们将 Set 命令中的 <code>S</code> 替换为 <code>Z</code>，例如，<code>SADD</code> =&gt; <code>ZADD</code>。然而，我们的命令对于两者都是独一无二的。我们来看看。</p><h3 id="ZADD"><a href="#ZADD" class="headerlink" title="ZADD"></a>ZADD</h3><p>使用 <a href="https://redis.io/commands/zadd" target="_blank" rel="noopener"><code>ZADD</code></a> 将具有指定分数的所有指定成员添加到 Sorted Set：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZADD key <span class="string">[NX|XX]</span> <span class="string">[CH]</span> <span class="string">[INCR]</span> score member <span class="string">[score member ...]</span></span><br></pre></td></tr></table></figure><p>与集合一样，如果键不存在，则创建具有指定成员作为唯一成员的新 “有序集合”。如果键存在但不是有序集合，则返回一个错误。</p><p>从 Redis 3.0.2开始，<a href="https://redis.io/commands/zadd#zadd-options-redis-302-or-greater" target="_blank" rel="noopener"><code>ZADD</code> 提供了可选参数</a>，可以控制插入:</p><ul><li><code>XX</code>：只更新已存在的成员。不添加成员。</li><li><code>NX</code>：不要更新已经存在的成员。总是添加新成员。</li><li><code>CH</code>： 将返回值从添加的新成员数目修改为更改的成员总数（CH 是更改的缩写）。更改的成员是新添加的成员和已经存在的成员，该成员的分数已经更新。因此，在命令行中指定的与过去分数相同的成员不计算在内。</li><li><code>INCR</code>：当指定此选项时，ZADD 的作用类似于 <a href="https://redis.io/commands/zincrby" target="_blank" rel="noopener"><code>ZINCRBY</code></a>。在此模式中只能指定一个成员对。</li></ul><p>很高兴知道这些可选参数的存在以及它们的作用，但是在本教程中，我们将专注于添加成员而不使用其中任何一个，但是请随意探索它们！ 在以后的文章中，我们将在更复杂的用例中重新讨论它们！</p><p>让我们创建一个存储服务台支持票据 <code>tickets</code>的有序集合。支持票据是唯一的，但也需要排序，因此，这种数据结构是一个很好的选择：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ZADD tickets 100 HELP204</span><br><span class="line">// 1</span><br><span class="line">ZADD tickets 90 HELP004</span><br><span class="line">// 1</span><br><span class="line">ZADD tickets 180 HELP330</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure><p><code>ZADD</code> 返回新添加元素的数量计数。在上面的命令中，我们使用票据在队列中的位置作为分数，后跟票号（都是虚构的）。</p><h3 id="ZRANGE"><a href="#ZRANGE" class="headerlink" title="ZRANGE"></a>ZRANGE</h3><p>我们现在想看看我们的有序集合看起来如何。对于集合，我们使用 <code>SMEMBERS</code> 列出无序成员。使用 Sorted Sets 时，我们使用的命令更符合使用 Lists 时使用的命令，这个命令向我们显示一个元素范围。</p><p><a href="https://redis.io/commands/zrange" target="_blank" rel="noopener"><code>ZRANGE</code></a> 返回在 Sorted Set 中指定的成员范围：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGE key <span class="literal">start</span> <span class="literal">stop</span> [WITHSCORES]</span><br></pre></td></tr></table></figure><p>它的行为非常类似于 Lists 列表的 <code>LRANGE</code>。我们可以使用它来获取有序集合的一个子集。要获得完整的有序集合，我们可以再次使用 <code>0 -1</code> 范围：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGE tickets <span class="number">0</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>返回如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1) <span class="string">"HELP004"</span></span><br><span class="line">2) <span class="string">"HELP204"</span></span><br><span class="line">3) <span class="string">"HELP330"</span></span><br></pre></td></tr></table></figure><p>我们可以通过 <code>ZRANGE</code> 的 <code>WITHSCORES</code> 参数来包含每个成员的分数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGE tickets 0 -1 WITHSCORES</span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1) <span class="string">"HELP004"</span></span><br><span class="line">2) <span class="string">"90"</span></span><br><span class="line">3) <span class="string">"HELP204"</span></span><br><span class="line">4) <span class="string">"100"</span></span><br><span class="line">5) <span class="string">"HELP330"</span></span><br><span class="line">6) <span class="string">"180"</span></span><br></pre></td></tr></table></figure><p>注意成员和分数是如何按顺序排列的，而不是挨着排列的。正如我们所看到的，成员根据他们的分数按升序存储在 <code>tickets</code> 中。</p><h2 id="使用-Redis-作为-Session（会话）存储"><a href="#使用-Redis-作为-Session（会话）存储" class="headerlink" title="使用 Redis 作为 Session（会话）存储"></a>使用 Redis 作为 Session（会话）存储</h2><p>在 web 应用程序的身份验证和授权工作流中，Redis 最相关的用途是充当会话存储。</p><p>正如 <a href="https://aws.amazon.com/redis/" target="_blank" rel="noopener">Amazon Web Services</a> 所承认的那样，Redis 的内存架构为开发人员提供了高可用性和持久性，使其成为网络规模应用程序存储和管理会话数据的流行选择。它闪电般的性能为我们提供了超低延迟、最佳规模和弹性，这些是我们管理会话数据（如用户配置文件、用户设置、会话状态和凭证管理）所需的。</p><p><a href="https://redislabs.com/" target="_blank" rel="noopener">Redis 实验室 </a>的 <a href="https://twitter.com/roshankumar" target="_blank" rel="noopener">Roshan Kumar</a> 在他的 <a href="https://redislabs.com/blog/cache-vs-session-store/" target="_blank" rel="noopener">“Cache vs. Session Store”</a> 文章中解释说，面向会话的 web 应用程序在用户登录时启动会话。会话处于活动状态，直到用户注销或会话超时为止。在会话生命周期中，web 应用程序将所有与会话相关的数据存储在主存（RAM）或会话存储中，当应用程序宕机时，这些数据不会丢失。这个会话存储区可以使用 Redis 实现，尽管它是一个内存存储区，但它能够通过在磁盘中顺序写入事务日志来持久保存数据。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-01-04-152214.png" alt="A session-oriented application diagram"></p><p>图片来源：<a href="https://redislabs.com/blog/cache-vs-session-store/" target="_blank" rel="noopener">Redis Labs: Cache vs. Session Store</a></p><p>Roshan 进一步解释说，会话存储依赖于读写数据的内存数据库。会话存储数据不是临时的，当会话处于活动状态时，它成为唯一的真实数据源。出于这个原因，会话存储需要满足 ”真正数据库的数据持久性需求“。</p><blockquote><p>“根据 @redislabs 的说法，会话存储需要高可用性和持久性来支持事务数据和不间断的用户参与。使用 redis 就可以轻松做到这一点。”</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Redis 是一个强大、灵活和灵活的数据库，可以加快您的体系结构。它可以提供很多服务，包括缓存、数据复制、发布 / 订阅消息系统、会话存储等等。Redis 有大量的客户端，覆盖了所有流行的编程语言。我希望每当您有一个符合其价值主张的用例时，您都可以尝试一下。</p><hr><p>我觉得对于初学者来说，找到学习的入口非常重要。不然就会望而却步，感觉高不可攀。但一旦打开了这扇门，后面的学习相对来说好开展一些。这也是我翻译这篇文章的初衷。</p><p>为了更好的理解与使用 Redis，强烈建议大家看一看<a href="https://book.douban.com/subject/26971561/" target="_blank" rel="noopener">《Redis 开发与运维》</a> 和 <a href="https://book.douban.com/subject/25900156/" target="_blank" rel="noopener">《Redis 设计与实现》</a>这两本书。</p><p>ps：阅读英语文档时，可以借助 <a href="https://fanyi.caiyunapp.com/#/web" target="_blank" rel="noopener">彩云小译</a> 双语对照网页翻译插件。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文翻译于 &lt;a href=&quot;https://auth0.com/blog/authors/dan-arias/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dan Arias&lt;/a&gt; 的 &lt;a href=&quot;https://auth0.com/blog/introduction-to-redis-install-cli-commands-and-data-types/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Introduction to Redis: Installation, CLI Commands, and Data Types&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;文章虽然篇幅较长，但非常浅显易懂，是一篇很好的 Redis 入门文章。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-01-04-035301.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在本 Redis 教程中，可以学习到如何安装、配置 Redis，以及使用其核心数据结构用命令从存储中写入、读取、更新、删除数据。&lt;/p&gt;
&lt;h2 id=&quot;什么是-Redis？&quot;&gt;&lt;a href=&quot;#什么是-Redis？&quot; class=&quot;headerlink&quot; title=&quot;什么是 Redis？&quot;&gt;&lt;/a&gt;什么是 Redis？&lt;/h2&gt;&lt;p&gt;Redis 是一款在内存中存储数据的 Key-Value 存储，可用来做数据库、缓存和消息代理等。它是 &lt;a href=&quot;https://github.com/antirez/redis&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;开源&lt;/a&gt; 的，目前使用 &lt;a href=&quot;https://github.com/antirez/redis/blob/unstable/COPYING&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BSD 开源协议&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有趣的事实：Redis 的本意是「REmote DIctionary Server.（远程字典服务器）」&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://aws.amazon.com/cn/redis/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Redis 响应时间在微妙级&lt;/a&gt;，每秒能处理百万次的请求，满足对性能有苛刻要求的实时应用，如游戏、广告代理、金融监控等等。&lt;/p&gt;
&lt;p&gt;他支持基本的数据结构，如 string、list、set、sort set（有序集合：可范围查找） 和 hash。还支持更高级的数据结构，如 bitmaps（位图）、hyperloglogs（超级日志）、geospatial（地理空间索引：有半径查询）。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="https://depp.wang/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://depp.wang/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>理解狄克斯特拉算法：早上坐地铁最短用时多久就能到公司？</title>
    <link href="https://depp.wang/2019/09/09/how-long-is-the-shortest-time/"/>
    <id>https://depp.wang/2019/09/09/how-long-is-the-shortest-time/</id>
    <published>2019-09-09T13:26:55.000Z</published>
    <updated>2020-04-10T13:36:08.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p>灵感来自于<a href="https://depp.wang/Java-Books/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3.epub">《算法图解》</a>第 7 章 「狄克斯特拉算法」，图片和代码也是来自该书。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>假设你住起点，公司在终点。坐地铁上班路线有三条，<code>起点 -&gt; A -&gt; 终点</code>；<code>起点 -&gt; B -&gt; A -&gt; 终点</code>；<code>起点 -&gt; B -&gt; 终点</code>。请用狄克斯特拉算法，计算出早上坐地铁上班，最短用时多久就能到公司（不算换乘时间）？<code>2</code> 代表 <code>20 分钟</code>。路线图如下：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135451.jpg" alt=""></p><a id="more"></a><p>提示：可用三个散列表来表示各节点之间的关系：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135452.jpg" alt=""></p><ul><li>GRAPH 表：记录所有节点到相邻节点（邻居）的时间</li><li>COSTS 表：记录起点到其他节点的时间（开销）</li><li>PARENTS 表：记录除起点以外的所有节点和其父节点（终点的父节点不确定）</li></ul><h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>标签：<code>狄克斯特拉算法</code>、<code>哈希表</code></li><li>狄克斯特拉算法：用于计算单源最短路径的算法</li><li>从 COSTS 表中找出离起点用时最短（开销最低）的相邻节点（B）</li><li>遍历 B 节点的邻居，如果起点经 B 到邻居的开销更低，更新 COSTS 表中此邻居的开销</li><li>同时更新 PARENTS 表此邻居的父节点</li><li>遍历完所有邻居后，将节点标记为已处理过</li><li>继续从 COSTS 表中找出未被处理过的、离起点开销最低的节点，循环，直到所有节点都被处理过</li><li>最终 COSTS 表中终点对应的值，就是结果</li><li>时间复杂度：O (n^2^)  (n 节点) * (n 邻居)</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python3</span></span><br><span class="line">graph = &#123;&#125;</span><br><span class="line">graph[<span class="string">"start"</span>] = &#123;&#125;</span><br><span class="line">graph[<span class="string">"start"</span>][<span class="string">"a"</span>] = <span class="number">6</span></span><br><span class="line">graph[<span class="string">"start"</span>][<span class="string">"b"</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">graph[<span class="string">"a"</span>] = &#123;&#125;</span><br><span class="line">graph[<span class="string">"a"</span>][<span class="string">"fin"</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">graph[<span class="string">"b"</span>] = &#123;&#125;</span><br><span class="line">graph[<span class="string">"b"</span>][<span class="string">"a"</span>] = <span class="number">3</span></span><br><span class="line">graph[<span class="string">"b"</span>][<span class="string">"fin"</span>] = <span class="number">5</span>  <span class="comment"># ←------ fin -&gt; finally</span></span><br><span class="line"></span><br><span class="line">graph[<span class="string">"fin"</span>] = &#123;&#125;  <span class="comment"># ←------终点没有任何邻居</span></span><br><span class="line"></span><br><span class="line">infinity = float(<span class="string">"inf"</span>)  <span class="comment"># ←------表示无穷大</span></span><br><span class="line">costs = &#123;&#125;</span><br><span class="line">costs[<span class="string">"a"</span>] = <span class="number">6</span></span><br><span class="line">costs[<span class="string">"b"</span>] = <span class="number">2</span></span><br><span class="line">costs[<span class="string">"fin"</span>] = infinity</span><br><span class="line"></span><br><span class="line">parents = &#123;&#125;</span><br><span class="line">parents[<span class="string">"a"</span>] = <span class="string">"start"</span></span><br><span class="line">parents[<span class="string">"b"</span>] = <span class="string">"start"</span></span><br><span class="line">parents[<span class="string">"fin"</span>] = <span class="keyword">None</span>  <span class="comment"># ←------终点父节点不确定</span></span><br><span class="line"></span><br><span class="line">processed = []  <span class="comment"># ←------存放处理过的节点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_lowest_cost_node</span><span class="params">(costs)</span>:</span></span><br><span class="line">    lowest_cost = float(<span class="string">"inf"</span>)</span><br><span class="line">    lowest_cost_node = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> costs:  <span class="comment"># ←------遍历所有的节点</span></span><br><span class="line">        cost = costs[node]</span><br><span class="line">        <span class="keyword">if</span> cost &lt; lowest_cost <span class="keyword">and</span> node <span class="keyword">not</span> <span class="keyword">in</span> processed:  <span class="comment"># ←------如果当前节点的开销更低且未处理过，</span></span><br><span class="line">            lowest_cost = cost  <span class="comment"># ←------就将其视为开销最低的节点</span></span><br><span class="line">            lowest_cost_node = node</span><br><span class="line">    <span class="keyword">return</span> lowest_cost_node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">node = find_lowest_cost_node(costs)  <span class="comment"># ←------找出离起点用时最短（开销最低）的相邻节点（B）</span></span><br><span class="line"><span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:  <span class="comment"># ←------这个 while 循环在所有节点都被处理过后结束</span></span><br><span class="line">    cost = costs[node]</span><br><span class="line">    neighbors = graph[node]</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> neighbors.keys():  <span class="comment"># ←------遍历当前节点的所有邻居</span></span><br><span class="line">        new_cost = cost + neighbors[n]</span><br><span class="line">        <span class="keyword">if</span> costs[n] &gt; new_cost:  <span class="comment"># ←------如果经当前节点前往该邻居开销更低</span></span><br><span class="line">            costs[n] = new_cost  <span class="comment"># ←------就更新该邻居的开销</span></span><br><span class="line">            parents[n] = node  <span class="comment"># ←------同时将该邻居的父节点设置为当前节点</span></span><br><span class="line">    processed.append(node)  <span class="comment"># ←------将当前节点标记为处理过</span></span><br><span class="line">    node = find_lowest_cost_node(costs)  <span class="comment"># ←------找出接下来要处理的节点，并循环</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"早上用时最短到公司的时间：%s0 分钟"</span> % costs[<span class="string">'fin'</span>])</span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/egonSchiele/grokking_algorithms/blob/master/07_dijkstras_algorithm/java/01_dijkstras_algorithm/src/DijkstrasAlgorithm.java" target="_blank" rel="noopener">Java</a></li><li><a href="https://github.com/egonSchiele/grokking_algorithms/blob/master/07_dijkstras_algorithm/javascript/01_dijkstras_algorithm.js" target="_blank" rel="noopener">JavaScript</a></li></ul><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135455.jpg" alt=""></p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135457.jpg" alt=""><br><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135459.jpg" alt=""><br><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135502.jpg" alt=""><br><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135507.png" alt=""><br><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135509.jpg" alt=""><br><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135525.jpg" alt=""><br><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135537.jpg" alt=""><br><img src="https://i.loli.net/2019/09/09/kFR8KNyZMw4PbDG.jpg" style="zoom:108.2%;"><br><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135540.png" alt=""><br><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135543.jpg" alt=""><br><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135545.jpg" alt=""><br><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135547.jpg" alt=""><br><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135549.jpg" alt=""><br><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-140551.jpg" style="zoom:115.5%;"><br><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-140558.jpg" style="zoom:103%;"><br><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135553.png" alt=""><br><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135555.jpg" alt=""></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>如果要问：「早上地铁坐那条路线耗时最短？」应该怎样修改代码？</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目来源&quot;&gt;&lt;a href=&quot;#题目来源&quot; class=&quot;headerlink&quot; title=&quot;题目来源&quot;&gt;&lt;/a&gt;题目来源&lt;/h2&gt;&lt;p&gt;灵感来自于&lt;a href=&quot;https://depp.wang/Java-Books/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3.epub&quot;&gt;《算法图解》&lt;/a&gt;第 7 章 「狄克斯特拉算法」，图片和代码也是来自该书。&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;假设你住起点，公司在终点。坐地铁上班路线有三条，&lt;code&gt;起点 -&amp;gt; A -&amp;gt; 终点&lt;/code&gt;；&lt;code&gt;起点 -&amp;gt; B -&amp;gt; A -&amp;gt; 终点&lt;/code&gt;；&lt;code&gt;起点 -&amp;gt; B -&amp;gt; 终点&lt;/code&gt;。请用狄克斯特拉算法，计算出早上坐地铁上班，最短用时多久就能到公司（不算换乘时间）？&lt;code&gt;2&lt;/code&gt; 代表 &lt;code&gt;20 分钟&lt;/code&gt;。路线图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135451.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="https://depp.wang/categories/Algorithms/"/>
    
    
      <category term="狄克斯特拉算法" scheme="https://depp.wang/tags/%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>什么是耳硬化症？</title>
    <link href="https://depp.wang/2019/09/08/what-is-otosclerosis/"/>
    <id>https://depp.wang/2019/09/08/what-is-otosclerosis/</id>
    <published>2019-09-08T13:26:55.000Z</published>
    <updated>2020-04-10T13:36:08.719Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135611.png" alt="image"></p><blockquote><p>本文翻译于 <a href="https://www.webmd.com/sabrina-felson" target="_blank" rel="noopener">Sabrina Felson, MD</a> 的 <a href="https://www.webmd.com/cold-and-flu/ear-infection/otosclerosis-facts#1" target="_blank" rel="noopener">What Is Otosclerosis?</a></p></blockquote><p>耳硬化症是一种可能会导致听力丧失的罕见疾病。它是你 <a href="https://baike.baidu.com/item/%E4%B8%AD%E8%80%B3" target="_blank" rel="noopener">中耳</a> 里面一小块儿叫做镫骨的骨头发生硬化导致的。大多数时候，当镫骨周围的骨组织以不正常的方式生长时，也会导致这种疾病。</p><!--你的镫骨需要振动才能让你听得很清楚。当它这一功能慢慢消失的时候，声音就不能完整从中耳传到内耳，这就会让你的慢慢听力下降。--><p>你的镫骨（译注：具体来说是镫骨足板）需要振动才能让你听得很清楚。当它无法做到这一点时，声音就不能从你的中耳传到你的内耳。这就会让你的听力下降。</p><a id="more"></a><h2 id="谁会得耳硬化症？"><a href="#谁会得耳硬化症？" class="headerlink" title="谁会得耳硬化症？"></a>谁会得耳硬化症？</h2><p>超过 300 万美国人受耳硬化症影响（中国数据没搜到）。专家也没有找到确切病因，但他们发现：</p><ul><li>它从你年轻的时候就开始。你在 10 到 45 岁 都有可能患耳硬化症，但你往往可能会在 20 多岁时得上，并可能在你 30 多岁时加重。</li><li>它有家族性。在所有患耳硬化症的人中，有一半的人跟 Ta 的基因有关。但即使你有这个基因，你也不一定会患上耳硬化症。</li><li>男性和女性都有可能患耳硬化症。但女性的可能性更高。没有确切的证据证明为什么会这样，但如果你是一个女性耳硬化患者，并且正在怀孕中，你听力可能会比没有怀孕的女性和男性下降得更快。</li><li>白种人更容易得上它。大约有 10% 的人会患耳硬化症。黑种人和黄种人不常见。</li><li>某些医疗问题可能会提高你得病的几率。举例来说，如果你以前得过 <a href="https://baike.baidu.com/item/%E9%BA%BB%E7%96%B9" target="_blank" rel="noopener">麻疹</a>；如果你内耳周围的骨组织发生过骨折；如果你有过 <a href="https://baike.baidu.com/item/%E8%87%AA%E8%BA%AB%E5%85%8D%E7%96%AB%E7%96%BE%E7%97%85" target="_blank" rel="noopener">自身免疫疾病</a>（免疫系统错误的攻击身体的某个部位）。</li></ul><h2 id="症状"><a href="#症状" class="headerlink" title="症状"></a>症状</h2><p>耳硬化症最主要的症状是听力下降。最开始，你可能会注意到你开始听不到轻微的声音和别人的悄悄话。这种情况随着时间的推移，会变得更加糟糕。</p><p>大多数患者会出现双耳听力下降。只有 10% ~ 15% 的人只出现单耳听力下降。其他症状包括：</p><ul><li>头晕或身体不协调</li><li><a href="https://baike.baidu.com/item/%E8%80%B3%E9%B8%A3/217759" target="_blank" rel="noopener">耳鸣</a>（会听到铃声或咆哮声或嘶嘶声）</li></ul><p>当你通过手术治疗耳硬化症后，耳鸣可能会困扰你。</p><h2 id="诊断"><a href="#诊断" class="headerlink" title="诊断"></a>诊断</h2><p>如果你注意到你有听力问题，可以挂医院耳鼻喉科（或耳鼻喉头颈外科）医生的号（医生最好专攻耳科）。医生会仔细检查你的耳朵，测试你的听力，询问你的家族病史。在某些情况，他会让你做一个 CT（计算机断层摄影术） 检查。CT 是以不同的角度拍一系列 X 光，再把它们合在一起，生成一个更详细的片子。译注：CT 看骨质，核磁看软组织</p><h2 id="治疗"><a href="#治疗" class="headerlink" title="治疗"></a>治疗</h2><p>如果你听力下降不严重，医生可能会建议你采取保守治疗（观察和等待）的方式，隔一段时间测试一下听力。Ta 可能会推荐你戴一个助听器。</p><p>大多数医生可能会用 <a href="https://www.webmd.com/drugs/2/drug-503/sodium+fluoride+oral/details" target="_blank" rel="noopener">氟化物（钠）</a>（一种 <a href="https://baike.baidu.com/item/%E8%86%B3%E9%A3%9F%E7%BA%A4%E7%BB%B4" target="_blank" rel="noopener">膳食纤维</a>）治疗耳硬化症。但这尚未证明有效。</p><p>如果你听力下降严重或者变得很糟，你的医生可能会推荐你做一个叫 <a href="https://baike.baidu.com/item/%E9%95%AB%E9%AA%A8%E5%88%87%E9%99%A4%E6%9C%AF/476267" target="_blank" rel="noopener">镫骨切除术</a> 的手术。在这个手术中，医生会移除你中耳里硬化的镫骨，改用一个人工镫骨替换它。它能让声音传到内耳，以至于提高你的听力。</p><p>镫骨切除术能帮助很多人。但它也有风险，极少数手术后，听力可能比以前更差。</p><p>如果你是双耳硬化症。你可以先给一个耳朵做手术（医生一次只能做一个），根据恢复情况再给另一个耳朵做（至少 6 个月后）。</p><h2 id="译注"><a href="#译注" class="headerlink" title="译注"></a>译注</h2><ul><li>为符合语境，对原文中某些表达做了修改。</li><li>文中提到的镫骨切除术现在一般没人做了，现在一般做的是 <a href="https://en.wikipedia.org/wiki/Stapedectomy#Stapedotomy" target="_blank" rel="noopener">镫骨足板造孔术（Wiki）</a></li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="镫骨足板造孔术"><a href="#镫骨足板造孔术" class="headerlink" title="镫骨足板造孔术"></a>镫骨足板造孔术</h3><ul><li><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3562988/" target="_blank" rel="noopener">镫骨足板造孔术与镫骨切除术比较的论文</a>：结论是镫骨足板造孔术比镫骨切除术更好</li><li><a href="https://www.youtube.com/watch?v=idNu5ATeP6g" target="_blank" rel="noopener">镫骨足板造孔术手术视频（YouTube）：</a>略微有点血腥，里面也有动画</li></ul><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p>一定是耳硬化吗？</p><ul><li>如果你是 20 岁以前听力下降，医生会先判断你是不是先天性中耳畸形，即使你符合耳硬化的一切特征，你也有可能是类耳硬化症的先天性中耳畸形。</li><li>关于先天性中耳畸形，具体可看 <a href="http://www.dxy.cn/bbs/topic/9124422" target="_blank" rel="noopener">【病例讨论】耳硬化症还是先天性中耳畸形</a></li></ul><!--先天性中耳畸形可分为 4 类：①A1：先天性听骨链畸形(主要累及锤砧骨)；②A2：先天性听骨链畸形(砧骨长突和镫骨受累)；③B型：先天性镫骨固定；④C型：先天性前庭窗和(或)蜗窗发育不全或闭锁。先天性中耳畸形一般具有这 6 个特点：① 出生后即有明显传导性聋而无其他后天性病变，单侧患者的耳聋常于成年后才被发现；② 耳聋为非进行性；③ 患者一般无耳鸣；④ 无中耳炎、无外伤史，无耳硬化症家族史；⑤ 气导听力曲线呈水平型，损失一般在 55~65dB，各频之间差异不大，骨导曲线正常或略低于正常；⑥ X 线或 CT 中见骨质增生骨迷路增厚或其他畸形。耳硬化是：①  最常见于20岁以后，而且多为两侧性，单侧仅占10~15%；② 听力下降症状多为慢性进行性；③ 常伴有耳鸣；④ 声导抗鼓室图为 As 型--><!--听骨链即锤骨、砧骨和镫骨的统称，也叫听小骨。听小骨可指听骨链，也可指其中一块。--><p>耳硬化手术哪里做比较好？</p><ul><li><a href="http://www.fdeent.org/Home/" target="_blank" rel="noopener">上海五官科医院（复旦大学附属眼耳鼻喉科医院）</a>：<a href="http://www.fdeent.org/Home/doctor/intro/uid//2243" target="_blank" rel="noopener">陈兵</a>、<a href="http://www.fdeent.org/Home/doctor/intro/uid//223" target="_blank" rel="noopener">迟放鲁</a></li><li><a href="http://www.301hospital.com.cn/" target="_blank" rel="noopener">北京 301 医院（中国人民解放军总医院）</a>：<a href="http://www.301hospital.mil.cn/web/showexp/myhcv/66/688.html" target="_blank" rel="noopener">韩东一</a>、<a href="http://www.301hospital.mil.cn/web/showexp/myhcv/66/341.html" target="_blank" rel="noopener">戴朴</a></li><li><a href="http://www.syshospital.com/" target="_blank" rel="noopener">广州中山二院（中山大学孙逸仙纪念医院）</a>：<a href="http://www.syshospital.com/u/02169" target="_blank" rel="noopener">张志钢</a></li><li><a href="http://www.hospital-cqmu.com/index.php" target="_blank" rel="noopener">重庆医科大学附属第一医院</a>：<a href="http://www.hospital-cqmu.com/index.php?file=keshi&smid=235&wid=64571" target="_blank" rel="noopener">康厚墉</a>（局麻）</li><li>以上是我了解到的，做耳硬化手术很好的医生</li><li>301 医院现在做手术一般都要排队 3-4 个月（军人不用排队），需提前估算好时间。如果挂不到号，可以直接去找医生。</li></ul><p>术后听力能提高多少？</p><ul><li>85% 几率提升到正常水平，15% 几率可能没变化或者更差。在耳朵手术里面算成功率最高的（我医生戴朴主任说的）。</li></ul><p>手术效果能维持多久？</p><ul><li>正常来说可维持 10 年以上，乃至一辈子，但也因人而异，可能后期下降。</li></ul><p>手术能做微创吗？</p><ul><li>可以，微创就是耳道内手术，从外面看不出来疤痕。不微创就是耳背手术，可能引起耳朵外张（招风耳），现在一般都是微创。</li></ul><p>微创会开刀吗？</p><ul><li>都会开刀，如果你耳道宽，直接就能看到鼓膜，有手术操作的的视野和空间，那么就耳道内开刀（鼓膜旁）；如果你耳道窄，那就需要行耳内开刀（切开耳道）。</li></ul><p>手术是全麻还是局麻？</p><ul><li>最好局麻，但现在大多数都是全麻。全麻跟局麻的区别在于局麻有意识，局麻可在手术过程中就知道手术效果。个人认为因为局麻需要主刀医生自行操作，要求比较高，所有大多数医院都是全麻，简单一点。</li></ul><p>手术要花多少钱？要住几天院？</p><ul><li>住院手术所有费用未报销前一般不超过 2 万。手术后一般住院 3 天就行（北京 301 医院）。</li></ul><p>术后要恢复多久？</p><ul><li>最好静养 1 个月（上班请假、上学不去<code>^_^</code>），但也因人而异。</li></ul><p>术后可剧烈运动吗？</p><ul><li>反正我是就像没做手术一样，照样打篮球什么的。</li></ul><p>更多问题可加 <a href="http://qm.qq.com/cgi-bin/qm/qr?k=30leDJNrc1fhW51zyInIj3-CXOHRunqi&authKey=2oUHn3%2BwnYCxJjlAQ6Ps7fM4KIXR0mplq8R6kbHOGEdxv%2F1Cut6nzf04GVMIyTRp&group_code=436656735" target="_blank" rel="noopener">耳硬化症 QQ 交流群</a>：436656735</p><h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><ul><li>建议看看<a href="https://pan.baidu.com/s/1MGA6umutxUnkaJ-rGbHIXg" target="_blank" rel="noopener">《实用耳鼻咽喉头颈外科学（第2版）》</a>（提取码: 3xi5）第七篇，可以学到耳朵方面的很多知识，解答你很多疑惑，我也总结了一下，做了点笔记， <a href="http://note.youdao.com/noteshare?id=89e9a7c16d7da48b3fcad3449b89e931" target="_blank" rel="noopener">《实用耳鼻咽喉头颈外科学（第2版）》中耳笔记</a></li><li><a href="http://note.youdao.com/noteshare?id=cf602f1324d96e3f23712fe05635c6fe" target="_blank" rel="noopener">北京 301 医院耳朵手术治疗过程</a></li><li>少用入耳式、头戴式耳机听歌，多用外放</li><li>心态要好、脸皮要厚</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135611.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文翻译于 &lt;a href=&quot;https://www.webmd.com/sabrina-felson&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Sabrina Felson, MD&lt;/a&gt; 的 &lt;a href=&quot;https://www.webmd.com/cold-and-flu/ear-infection/otosclerosis-facts#1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;What Is Otosclerosis?&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;耳硬化症是一种可能会导致听力丧失的罕见疾病。它是你 &lt;a href=&quot;https://baike.baidu.com/item/%E4%B8%AD%E8%80%B3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;中耳&lt;/a&gt; 里面一小块儿叫做镫骨的骨头发生硬化导致的。大多数时候，当镫骨周围的骨组织以不正常的方式生长时，也会导致这种疾病。&lt;/p&gt;
&lt;!--你的镫骨需要振动才能让你听得很清楚。当它这一功能慢慢消失的时候，声音就不能完整从中耳传到内耳，这就会让你的慢慢听力下降。--&gt;
&lt;p&gt;你的镫骨（译注：具体来说是镫骨足板）需要振动才能让你听得很清楚。当它无法做到这一点时，声音就不能从你的中耳传到你的内耳。这就会让你的听力下降。&lt;/p&gt;
    
    </summary>
    
      <category term="Live" scheme="https://depp.wang/categories/Live/"/>
    
    
      <category term="Health" scheme="https://depp.wang/tags/Health/"/>
    
      <category term="Otosclerosis" scheme="https://depp.wang/tags/Otosclerosis/"/>
    
  </entry>
  
  <entry>
    <title>如何打官司？</title>
    <link href="https://depp.wang/2019/09/08/how-to-lawsuit/"/>
    <id>https://depp.wang/2019/09/08/how-to-lawsuit/</id>
    <published>2019-09-08T13:26:55.000Z</published>
    <updated>2020-04-10T13:36:08.719Z</updated>
    
    <content type="html"><![CDATA[<p>前些天经历了一场工伤维权，打了一场官司，总结了一些经验，现分享出来。</p><a id="more"></a><h2 id="什么样的案件需要打官司？"><a href="#什么样的案件需要打官司？" class="headerlink" title="什么样的案件需要打官司？"></a>什么样的案件需要打官司？</h2><p>简单的说，私下协商不成的民事案件。比如：工伤、欠债不还、离婚等。</p><blockquote><p>例如：我是因为我家人在建筑工地受工伤了，包工头和公司只赔医药费。不得不打官司维权。</p></blockquote><h2 id="到哪里起诉立案？"><a href="#到哪里起诉立案？" class="headerlink" title="到哪里起诉立案？"></a>到哪里起诉立案？</h2><p>1、案件发生地；2、如果被告为自然人，也可被告户籍所在地；3、如果被告为公司，也可被告公司注册地。如果是普通案件，都是当地基层人民法院起诉立案。</p><blockquote><p>例如：我家人在海南省海口市秀英区长流镇受伤，正常来说，就是去海口市秀英区人民法院起诉立案，但秀英区人民法院下设了一个西秀法庭，管辖西秀镇、长流镇等镇相关案件。所以我需要到秀英区人民法院西秀法庭起诉立案。</p></blockquote><h2 id="需要准备哪些材料？"><a href="#需要准备哪些材料？" class="headerlink" title="需要准备哪些材料？"></a>需要准备哪些材料？</h2><p>1、被告的相关信息。如果被告为自然人，需要提供其身份号（没有也没关系，法院会查到），联系地址（用于法院送达传票），联系电话（用于联系对方）；如果被告为公司，需要提供其统一社会信用代码、注册地、相应负责人电话（多个最好）。</p><p>2、起诉书（民事起诉状）。有的地方直接去法院填写就行，比如北京。有的地方需要提前准备好，比如海南。起诉书包含：原告信息、被告信息（可以是多个被告）、诉讼请求、事实和理由等。如果需要提前准备，最好先在网上或去法院了解一下，需要注意格式，比如海南法院要求字体是 3 号字体，等等。<a href="http://www.court.gov.cn/susongyangshi-xiangqing-181.html" target="_blank" rel="noopener">起诉书示例</a></p><p>3、相关证据。需要提前准备好对自己有利的相关证据，证据需要一个证据目录（标明每项证据的页数）</p><p><strong>起诉书和证据一式三份</strong>、<strong>起诉书和证据一式三份</strong>、起诉书和证据一式三份**</p><h2 id="走哪些流程？"><a href="#走哪些流程？" class="headerlink" title="走哪些流程？"></a>走哪些流程？</h2><p>1、立案。去法院起诉立案，有的地方已经可以网上立案了，比如上海。正常来说，如果材料符合条件，必须当场立案。如果发现不符合条件，7 天之内回执不予立案说明。</p><blockquote><p>我在海口市秀英区立案就很麻烦，各种理由不予当场立案，比如法官休假了，新调任的法院还没上任；案件堆积太多，只能几个月以后才能立案等等。遇到这种情况，直接打当地 12345 投诉，或者通过法院官网找当地法院领导投诉。</p></blockquote><p>起诉费（受理费）是根据诉讼请求的金额，按相关比例分段累计收费（财产案件）；非财产普通案件按件收费。具体可见：<a href="https://baike.baidu.com/item/诉讼费#2_1" target="_blank" rel="noopener">受理费标准</a>。起诉费需要你立案时先垫付。</p><blockquote><p>例如，我起诉对方赔偿 53587 元，那么就是 (50 + 43586 * 2.5%)  -&gt; 1150。</p></blockquote><p>如果最后法官判定你完全胜诉，那么这起诉费就是被告承担；如果部分胜诉，按最终判罚金额与诉讼请求金额比例，与被告共同承担。如果你们调解了，法院退回一半给你。</p><blockquote><p>有的地方退费效率很差，比如海南。过去 40 多天了，到现在还没给我退下来（2019.9.8）。</p></blockquote><p>立案后，法院会在 7 天内，将传票送达给被告。原告和被告都有 15 天的「举证期」，这 15 天内，双方都可再提交证据，你也可在前 7 天更改诉讼请求。</p><p>2、调解。法院一般案件多，也不想开庭审判，所以会先出面，让你们双方一起调解。此时，就是一个打折和被砍价的过程，不分各种费用来源，就是一口价。如果双方满意，就算调解成功。会出一份具有法律效应的调解书，要求被告在规定时间内赔偿。如果对方不赔，就又要去法院申请 <a href="https://baike.baidu.com/item/强制执行/15130" target="_blank" rel="noopener">强制执行</a>。</p><p>3、开庭。如果调解没成功，就会开庭审判，最后出具判决书。如果某方不服从判决，可上诉，案件就会 <a href="https://baike.baidu.com/item/二审" target="_blank" rel="noopener">二审</a>。这一步没经历。</p><h2 id="有哪些获取法律知识的途径？"><a href="#有哪些获取法律知识的途径？" class="headerlink" title="有哪些获取法律知识的途径？"></a>有哪些获取法律知识的途径？</h2><p>你可以通过 <a href="https://item.jd.com/12469415.html" target="_blank" rel="noopener">《人民法院诉讼程序2300问》</a> 这本书了解相关诉讼的法律信息。</p><p>也可以在 <a href="http://www.12348.gov.cn/#/homepage" target="_blank" rel="noopener">12348 中国法律服务网</a> 免费咨询相关律师，<a href="http://www.12348.gov.cn/#/homepage/lawservice" target="_blank" rel="noopener">点这里</a></p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135143.jpg" alt=""></p><h2 id="是否应该自费请律师？"><a href="#是否应该自费请律师？" class="headerlink" title="是否应该自费请律师？"></a>是否应该自费请律师？</h2><p>如果原告是农村户口（其他条件见：<a href="https://baike.baidu.com/item/法律援助#5" target="_blank" rel="noopener">援助范围</a>），你可去案件发生地公共法律服务中心（也可能叫法律援助中心），申请免费 <a href="https://baike.baidu.com/item/法律援助" target="_blank" rel="noopener">法律援助</a>，援助中心会安排一位免费的律师，你可以让他代理，帮你写起诉书、收集证据等。但因为免费嘛，所以负责不负责，完全看律师自己的职业素养。不要抱太大的希望。</p><blockquote><p>我也申请了法律援助，给我分配了一个不称职（律师资格证上就是写的不称职！）的律师。结果可想而知，各种敷衍，各种吵架。</p></blockquote><p>对于是否应该自费请律师。要看案件的是否有胜诉的把握，如果你的案件 100% 能胜诉，比如二房东不退你押金，你又有押金条。这种情况，完全不用请律师，直接起诉完事。</p><p>但如果你自己法律知识比较薄弱：不会写起诉书；或案件比较复杂：收集证据比较困难；金额较大等等。这种情况建议请一个律师。律师毕竟是专业的，可以少走很多弯路，减少浪费你的时间和精力。</p><p>律师代理案件一般分为：全风险代理、半风险代理和无风险代理。</p><ul><li>全风险代理：胜诉按比例收费，败诉不收费，部分胜诉按协议收费。</li><li>半风险代理：代理前先收费一部分，胜诉后再收费一部分。</li><li>无风险代理：无管胜诉败诉，代理前先收费。</li></ul><p>现在一般都是无风险代理，律师也怕担风险。也是按阶段累计收费，比如：10 万元以下部份 7% 但不少于 ￥5000 元（一审）。具体可见：<a href="https://baike.baidu.com/item/律师收费标准/4606780#3" target="_blank" rel="noopener">律师收费标准</a>。</p><p>请律师也也有学问，一定要看律师的人品和职业素养！我在海南海口准备请 <a href="http://www.deheheng.com/Archives/IndexArchives/index/a_id/197.html" target="_blank" rel="noopener">北京德和衡（海口）律师事务所</a> 的 李小姝律师 代理案件，但最后因为调解了，没有合作成。推荐李小姝律师和其助手。两个人很好、靠谱！</p><h2 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h2><p>总觉得打官司很遥远，不到最后一步就不要打官司</p><ul><li>其实很多时候需要 <strong>以打促和</strong>。</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>希望大家都不需要走到维权、打官司这一步。还是很麻烦，很费时间和精力。但如果走了，就要坚持维护自己的权益，毕竟在和平年代，不能让人欺负了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前些天经历了一场工伤维权，打了一场官司，总结了一些经验，现分享出来。&lt;/p&gt;
    
    </summary>
    
      <category term="Live" scheme="https://depp.wang/categories/Live/"/>
    
    
      <category term="Law" scheme="https://depp.wang/tags/Law/"/>
    
  </entry>
  
  <entry>
    <title>理解广度优先搜索算法：你朋友里有芒果销售商吗？</title>
    <link href="https://depp.wang/2019/09/07/do-you-have-a-friend-who-is-a-mango-dealer/"/>
    <id>https://depp.wang/2019/09/07/do-you-have-a-friend-who-is-a-mango-dealer/</id>
    <published>2019-09-07T13:26:55.000Z</published>
    <updated>2020-04-10T13:36:08.715Z</updated>
    
    <content type="html"><![CDATA[<p>难度：<span style="color: orange"> 中等</span>  &nbsp;&nbsp; 相关标签：<code>广度优先搜索算法</code></p><h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p>看了<a href="https://depp.wang/Java-Books/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3.epub">《算法图解》</a>第六章后，感觉作者广度优先搜索讲解得很到位，例子和算法都很好，在 <a href="https://leetcode-cn.com/" target="_blank" rel="noopener">LeetCode</a> 没找到类似的题目，就想着将他的例子作为一个题目吧！</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>假设你经营着一个芒果农场，需要寻找芒果销售商，以便将芒果卖给他。可在你的朋友中查找，假设 <code>m</code> 结尾的朋友就是芒果经营商，请编写一个算法，查看你朋友（人际关系网）里是否有芒果销售商？你的朋友是一度关系，朋友的朋友是二度关系，以此类推。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135742.png" alt=""></p><p>关系表示方式如下（Python dict）：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph = &#123;&#125;</span><br><span class="line">graph[<span class="string">"you"</span>] = [<span class="string">"alice"</span>, <span class="string">"bob"</span>, <span class="string">"claire"</span>]</span><br><span class="line">graph[<span class="string">"bob"</span>] = [<span class="string">"anuj"</span>, <span class="string">"peggy"</span>]</span><br><span class="line">graph[<span class="string">"alice"</span>] = [<span class="string">"peggy"</span>]</span><br><span class="line">graph[<span class="string">"claire"</span>] = [<span class="string">"thom"</span>, <span class="string">"jonny"</span>]</span><br><span class="line">graph[<span class="string">"anuj"</span>] = []</span><br><span class="line">graph[<span class="string">"peggy"</span>] = []</span><br><span class="line">graph[<span class="string">"thom"</span>] = []</span><br><span class="line">graph[<span class="string">"jonny"</span>] = []</span><br></pre></td></tr></table></figure><h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>标签：<code>广度优先搜索</code>、<code>先进先出队列</code></li><li>使用广度优先搜索。广度优先搜索解决两类问题：1. A 节点是否能到达 B 节点？2. A 节点到 B 节点最短路径（最少换乘数）是多少？</li><li>这道题就是属于第一类问题</li><li>使用先进先出队列，将你的朋友加入队列，依次检查你的朋友是否是芒果经销商，如果不是，将朋友的朋友链接到队尾，重复操作，直到找到芒果经销商或者所有人都被加入队列</li><li>因为存在某个人可能同时是多个人的朋友，避免被重复加入队列，使用一个数组记录检查过的人</li><li>时间复杂度：O (V + E) = O (V) + O (E)。 V: vertice 顶点（人数），E: edge 边数（箭头的数量）</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><strong>Python:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(name)</span>:</span></span><br><span class="line">    search_queue = deque()  <span class="comment"># ←------------创建一个队列</span></span><br><span class="line">    search_queue += graph[name]  <span class="comment"># ←------将你的邻居都加入到这个搜索队列中</span></span><br><span class="line">    searched = []  <span class="comment"># ←------------------------------这个数组用于记录检查过的人</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> search_queue:  <span class="comment"># ←------只要队列不为空</span></span><br><span class="line">        person = search_queue.popleft()  <span class="comment"># ←------就取出其中的第一个人</span></span><br><span class="line">        <span class="keyword">if</span> person <span class="keyword">not</span> <span class="keyword">in</span> searched:  <span class="comment"># ←----------仅当这个人没检查过时才检查</span></span><br><span class="line">            <span class="keyword">if</span> person_is_seller(person):  <span class="comment"># ←------检查这个人是否是芒果销售商</span></span><br><span class="line">                print(person + <span class="string">" is a mango seller!"</span>)  <span class="comment"># ←------是芒果销售商</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                search_queue += graph[person]  <span class="comment"># ←------不是芒果销售商。将这个人的朋友都加入搜索队列</span></span><br><span class="line">                searched.append(person)  <span class="comment"># ←------将这个人标记为检查过</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span>  <span class="comment"># ←------如果到达了这里，就说明队列中没人是芒果销售商</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person_is_seller</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> name[<span class="number">-1</span>] == <span class="string">'m'</span>  <span class="comment"># 以 m 结尾就是芒果商</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">search(<span class="string">'you'</span>)</span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/egonSchiele/grokking_algorithms/blob/master/06_breadth-first_search/java/01_breadth_first_search/src/BreadthFirstSearch.java" target="_blank" rel="noopener">Java</a></li><li><a href="https://github.com/egonSchiele/grokking_algorithms/blob/master/06_breadth-first_search/javascript/01_breadth-first_search.js" target="_blank" rel="noopener">JavaScript</a></li></ul><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135753.png" alt=""></p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135803.png" alt=""></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>《算法图解》是一本很好的算法入门书，建议想系统学习算法的小伙伴可以先看一下这本书。</p><blockquote><p>广度优先搜索与深度优先搜索区别：</p><ul><li>广度优先搜索：队列实现</li><li>深度优先搜索：堆栈实现</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;难度：&lt;span style=&quot;color: orange&quot;&gt; 中等&lt;/span&gt;  &amp;nbsp;&amp;nbsp; 相关标签：&lt;code&gt;广度优先搜索算法&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目来源&quot;&gt;&lt;a href=&quot;#题目来源&quot; class=&quot;headerlink&quot; title=&quot;题目来源&quot;&gt;&lt;/a&gt;题目来源&lt;/h2&gt;&lt;p&gt;看了&lt;a href=&quot;https://depp.wang/Java-Books/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3.epub&quot;&gt;《算法图解》&lt;/a&gt;第六章后，感觉作者广度优先搜索讲解得很到位，例子和算法都很好，在 &lt;a href=&quot;https://leetcode-cn.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt; 没找到类似的题目，就想着将他的例子作为一个题目吧！&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="https://depp.wang/categories/Algorithms/"/>
    
    
      <category term="广度优先搜索算法" scheme="https://depp.wang/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>碳水化合物的真相</title>
    <link href="https://depp.wang/2019/09/07/the-truth-about-carbs/"/>
    <id>https://depp.wang/2019/09/07/the-truth-about-carbs/</id>
    <published>2019-09-07T13:26:55.000Z</published>
    <updated>2020-04-10T13:36:08.719Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135041.png" alt="image"></p><p>以下内容基于 B 站 <a href="跳房子Q">跳房子Q</a> 的在 <a href="https://www.bilibili.com/video/av24736300/" target="_blank" rel="noopener">BBC 纪录片 - 碳水化合物的真相</a> 的评论上修改而成</p><h2 id="什么是碳水化合物？"><a href="#什么是碳水化合物？" class="headerlink" title="什么是碳水化合物？"></a>什么是碳水化合物？</h2><p>米？面包？面食？馒头？土豆？ 饼干？蛋糕？草莓？南瓜？</p><p>以上全部都是碳水化合物，所以除了我们所认为的富含高淀粉的食物以外，很多蔬菜水果也是碳水化合物。</p><blockquote><p>碳水化合物是由碳、（氢、氧）水组成的大分子。和蛋白质、脂肪一样，是身体的一个重要营养素。</p></blockquote><a id="more"></a><p>碳水可以分为黄碳水（淀粉类）、白碳水（糖类）和绿碳水（纤维类）三种。其中主要是绿碳水属于好碳水，它释放能量特别慢（更长的饱腹感），对肠道、内脏和身体有益。而黄碳水和白碳水则是需要小心对待的坏碳水。</p><table><thead><tr><th>黄碳水（淀粉类）</th><th>白碳水（糖类）</th><th>绿碳水（纤维类）</th></tr></thead><tbody><tr><td>土豆</td><td>碳酸饮料</td><td>水果</td></tr><tr><td>米饭</td><td>糖果</td><td>蔬菜</td></tr><tr><td>面食</td><td>加工食物</td><td>等等</td></tr><tr><td>面包</td><td>等等</td><td></td></tr><tr><td>等等</td><td></td><td></td></tr></tbody></table><p>碳水化合物一旦进入体内，会迅速转变为葡萄糖参与人体代谢，而过剩葡萄糖将转化为脂肪。</p><p>米饭、面食、面包、土豆富含淀粉，其含糖量比我们预估的高很多。当你以为你吃的很健康的时候，其实摄糖量早已超标。相反，草莓的含糖量却很低。</p><p>不同食物对应的方糖量：<br>食物 | 大碗米饭 | 一个烤土豆|10 颗大草莓<br>—|—|—|—<br>方糖颗数  | 20 | 19| 4 |</p><blockquote><p>1 颗方糖等于 8~10 克白糖</p></blockquote><h2 id="碳水化合物的危害是？造成这些危害的真正原因是？"><a href="#碳水化合物的危害是？造成这些危害的真正原因是？" class="headerlink" title="碳水化合物的危害是？造成这些危害的真正原因是？"></a>碳水化合物的危害是？造成这些危害的真正原因是？</h2><p>很多数据都证明，肥胖、糖尿病跟大量摄入碳水严重正相关，而背后的罪魁祸首是糖。因为碳水化合物转变的过剩葡萄糖将转化为脂肪。因此，吃高碳水的食物相当于直接吃白糖。</p><h2 id="为什么有人怎么吃也不变胖（可以消化更多的碳水）？"><a href="#为什么有人怎么吃也不变胖（可以消化更多的碳水）？" class="headerlink" title="为什么有人怎么吃也不变胖（可以消化更多的碳水）？"></a>为什么有人怎么吃也不变胖（可以消化更多的碳水）？</h2><p>这跟身体里面含有的酶和细菌有关。视频中有一实验，几个测试人员同时咀嚼无盐无糖的饼干，其中有人 17 秒后感觉口感变甜，也有人 30 几秒后口感变化，也有人从头到尾口感毫无变化。 也就是说，不同的身体里面含有的可以消化碳水的酶，是完全不一样的。很快能尝出甜味的人，代谢碳水的能力高，不容易变胖；而不能尝出甜味的人，代谢碳水的能力低，吃多就很容易被身体吸收贮藏，导致肥胖和糖尿病。</p><p>你也可以自己做个饼干小实验。如果你从头到尾都没有甜味变化，那么你食用碳水的时候，你就要注意一点了。</p><h2 id="So，解决方案是？"><a href="#So，解决方案是？" class="headerlink" title="So，解决方案是？"></a>So，解决方案是？</h2><p>对于正常和肥胖的人来说：</p><ul><li>少吃富含淀粉的白碳水：如白米饭、馒头、面包、面食等。尽量用绿碳水代替，比如：用南瓜取代土豆，用全麦或者黑面包取代白面包，糙米取代大米，水果取代蛋糕，等等。</li></ul><blockquote><p>全麦或者黑面包是抗性淀粉分子含量高的食物，抗性淀粉分子不容易被消化，可以算绿碳水</p></blockquote><ul><li>少喝饮料、少吃糖果和加工食品</li></ul><p>对于糖尿病人来说：</p><ul><li>最好完全用绿色碳水取代三餐中习惯白色和黄色碳水。这是英国医生 Dr.Unwin 推出的一套完全脱离药物依赖的糖尿病食疗法，并且已卓见成效。</li></ul><p>物理方法也可提高食物中抗性淀粉分子的含量：</p><ul><li>将食物先放入冰箱一段时间，再拿出来吃，比如面包</li><li>将米饭、面、土豆等食物煮熟后冷却，再加热食用（有点反人类，热菜热饭不立即吃！）</li></ul><p><strong>一句话总结：多吃水果蔬菜；多吃剩菜剩饭</strong></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.bilibili.com/video/av24736300/" target="_blank" rel="noopener">视频：碳水化合物的真相</a></li></ul><!--成年人每天大概需要 1500 大卡的热量  --><!--1 千卡 ＝ 1 大卡 ＝ 1000 卡路里 ≈ 4 千焦-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135041.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;以下内容基于 B 站 &lt;a href=&quot;跳房子Q&quot;&gt;跳房子Q&lt;/a&gt; 的在 &lt;a href=&quot;https://www.bilibili.com/video/av24736300/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BBC 纪录片 - 碳水化合物的真相&lt;/a&gt; 的评论上修改而成&lt;/p&gt;
&lt;h2 id=&quot;什么是碳水化合物？&quot;&gt;&lt;a href=&quot;#什么是碳水化合物？&quot; class=&quot;headerlink&quot; title=&quot;什么是碳水化合物？&quot;&gt;&lt;/a&gt;什么是碳水化合物？&lt;/h2&gt;&lt;p&gt;米？面包？面食？馒头？土豆？ 饼干？蛋糕？草莓？南瓜？&lt;/p&gt;
&lt;p&gt;以上全部都是碳水化合物，所以除了我们所认为的富含高淀粉的食物以外，很多蔬菜水果也是碳水化合物。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;碳水化合物是由碳、（氢、氧）水组成的大分子。和蛋白质、脂肪一样，是身体的一个重要营养素。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Live" scheme="https://depp.wang/categories/Live/"/>
    
    
      <category term="Health" scheme="https://depp.wang/tags/Health/"/>
    
      <category term="CARBS" scheme="https://depp.wang/tags/CARBS/"/>
    
  </entry>
  
  <entry>
    <title>两个同步有道云笔记到本地的 Python 脚本</title>
    <link href="https://depp.wang/2019/09/07/two-python-script-can-pull-youdaonote-to-localdir/"/>
    <id>https://depp.wang/2019/09/07/two-python-script-can-pull-youdaonote-to-localdir/</id>
    <published>2019-09-07T13:26:55.000Z</published>
    <updated>2020-04-10T13:36:08.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p><strong>1. 安装 Python3 环境，安装教程可参考 <a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1016959856222624" target="_blank" rel="noopener">廖大 Python 安装教程</a></strong></p><p><strong>2. clone 项目</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github<span class="selector-class">.com</span>:DeppWang/youdaonote-pull.git</span><br><span class="line">cd youdaonote-pull</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>3. 模拟登陆的方式同步笔记到本地</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 pullAll.py &lt;username&gt; &lt;password&gt; [[localDir] [ydnoteDir]] <span class="comment"># MacOS</span></span><br><span class="line">python pullAll.py &lt;username&gt; &lt;password&gt; [[localDir] [ydnoteDir]] <span class="comment"># Windows</span></span><br></pre></td></tr></table></figure><ul><li>username：必填，有道云笔记用户名</li><li>password：必填，有道云笔记密码</li><li>localDir：选填，本地文件夹名，不填则默认为当前文件夹</li><li>ydnoteDir：选填，指定有道云笔记文件夹名，不填则默认同步所有笔记</li></ul><p>上一次输入的相关参数会保存到 <code>pullAll-config</code> 中，如果参数不变，再次同步时，可以直接输入以下命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 pullAll.py <span class="comment"># MacOS</span></span><br><span class="line">python pullAll.py <span class="comment"># Windows</span></span><br></pre></td></tr></table></figure><p>注意：此种方式采用模拟登陆方式，频繁操作会被封 ip，此时可等待几分钟后重试，若一直被封。也可使用下面这种方式：</p><p><strong>4. 分享文件夹，同步文件夹下的笔记到本地</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 pull.py &lt;shareKey&gt; &lt;dirId&gt; [localDir] <span class="comment"># MacOS</span></span><br><span class="line">python pull.py &lt;shareKey&gt; &lt;dirId&gt; [localDir] <span class="comment"># Windows</span></span><br></pre></td></tr></table></figure><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135043.png" alt="image"></p><ul><li>shareKey：必填，当前文件夹的 shareKey（分享链接的 id 也是 shareKey）</li><li>dirId：必填，分享文件夹的 id</li><li>localDir：选填，本地文件夹名，不填则默认为当前文件夹</li></ul><p>同理，上一次输入的相关参数会保存到 <code>config</code> 中，如果参数不变，再次同步时，可以直接输入以下命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 pull.py <span class="comment"># MacOS</span></span><br><span class="line">python pull.py <span class="comment"># Windows</span></span><br></pre></td></tr></table></figure><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><strong>1. 模拟登陆方式同步笔记到本地</strong></p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135048.png" alt=""></p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135050.png" alt=""></p><p><strong>2. 同步分享文件夹下的笔记到本地</strong></p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135052.png" alt=""></p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-19-135054.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;使用方式&quot;&gt;&lt;a href=&quot;#使用方式&quot; class=&quot;headerlink&quot; title=&quot;使用方式&quot;&gt;&lt;/a&gt;使用方式&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1. 安装 Python3 环境，安装教程可参考 &lt;a href=&quot;https://www.liaoxuefeng.com/wiki/1016959663602400/1016959856222624&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;廖大 Python 安装教程&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. clone 项目&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git clone git@github&lt;span class=&quot;selector-class&quot;&gt;.com&lt;/span&gt;:DeppWang/youdaonote-pull.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd youdaonote-pull&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="OpenSource" scheme="https://depp.wang/categories/OpenSource/"/>
    
    
      <category term="YoudaoNote" scheme="https://depp.wang/tags/YoudaoNote/"/>
    
      <category term="Python" scheme="https://depp.wang/tags/Python/"/>
    
  </entry>
  
</feed>
