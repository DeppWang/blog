<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Depp Wang&#39;s Blog</title>
    <link>https://depp.wang/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>每个人都需要有自己的哈姆雷特</description>
    <pubDate>Sat, 31 Oct 2020 07:45:57 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>日志使用总结</title>
      <link>https://depp.wang/2020/10/30/logback-use-summary/</link>
      <guid>https://depp.wang/2020/10/30/logback-use-summary/</guid>
      <pubDate>Fri, 30 Oct 2020 20:48:37 GMT</pubDate>
      <description>
      
        &lt;p&gt;最近打在打印日志这块栽了个跟头，发现日志这块掌握得还不太好，所以大概梳理一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其实 SLF4J 类似于 Commons Logging，也是一个日志接口，而 Logback 类似于 Log4j，是一个日志的实现。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>最近打在打印日志这块栽了个跟头，发现日志这块掌握得还不太好，所以大概梳理一下。</p><blockquote><p>其实 SLF4J 类似于 Commons Logging，也是一个日志接口，而 Logback 类似于 Log4j，是一个日志的实现。</p></blockquote><a id="more"></a><h2 id="4-个日志级别"><a href="#4-个日志级别" class="headerlink" title="4 个日志级别"></a>4 个日志级别</h2><p>4 个日志级别，从低到高：DEBUG、INFO、WARN、ERROR。低级别能输出高级别的日志，级别越低输出内容越多。</p><ul><li>DEBUG：调试数据，生产环境关闭 Debug</li><li>INFO：系统运行信息、外部接口部分，可通过日志看到功能流程</li><li>WARN：不影响程序正常运行，但不应该出现的情况</li><li>ERROR：影响程序正常运行的情况，此时需使用邮件等方式告警，如果抛出异常，不打印</li></ul><p>使用 Logger 或使用注解 @Slf4j</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.debug(<span class="string">"debug: [&#123;&#125;]"</span>, <span class="string">"haha"</span>);</span><br><span class="line">        logger.info(<span class="string">"info: [&#123;&#125;]"</span>, <span class="string">"haha"</span>);</span><br><span class="line">        logger.warn(<span class="string">"warn: [&#123;&#125;]"</span>, <span class="string">"haha"</span>);</span><br><span class="line">        logger.error(<span class="string">"error: [&#123;&#125;]"</span>, <span class="string">"haha"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">"debug: [&#123;&#125;]"</span>, <span class="string">"haha"</span>);</span><br><span class="line">        log.info(<span class="string">"info: [&#123;&#125;]"</span>, <span class="string">"haha"</span>);</span><br><span class="line">        log.warn(<span class="string">"warn: [&#123;&#125;]"</span>, <span class="string">"haha"</span>);</span><br><span class="line">        log.error(<span class="string">"error: [&#123;&#125;]"</span>, <span class="string">"haha"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印日志时，使用占位符和 []，当没有 logback.xml 时，默认隔离级别：INFO。</p><h2 id="Logback-配置"><a href="#Logback-配置" class="headerlink" title="Logback 配置"></a>Logback 配置</h2><p>logback.xml 基础配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--控制台输出设置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"STDOUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- encoders are assigned the type</span></span><br><span class="line"><span class="comment">             ch.qos.logback.classic.encoder.PatternLayoutEncoder by default --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>输出格式：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">15<span class="selector-pseudo">:58</span><span class="selector-pseudo">:50.559</span> <span class="selector-attr">[http-nio-8080-exec-1]</span> <span class="selector-tag">INFO</span>  <span class="selector-tag">w</span><span class="selector-class">.depp</span><span class="selector-class">.exceptionlog</span><span class="selector-class">.TestController</span> <span class="selector-tag">-</span> <span class="selector-tag">info</span>: <span class="selector-tag">haha</span></span><br></pre></td></tr></table></figure><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-10-30-083249.png" alt="basic Syntax"></p><p>使用 logger 指定某个 package 使用某个级别：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"STDOUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- encoders are assigned the type</span></span><br><span class="line"><span class="comment">         ch.qos.logback.classic.encoder.PatternLayoutEncoder by default --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"chapters.configuration"</span> <span class="attr">level</span>=<span class="string">"INFO"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- Strictly speaking, the level attribute is not necessary since --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- the level of the root level is set to DEBUG by default.       --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>&gt;</span>          </span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">root</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 logger 指定某个文件使用某个级别：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"STDOUT"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">        %d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n</span><br><span class="line">     <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"chapters.configuration"</span> <span class="attr">level</span>=<span class="string">"INFO"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"chapters.configuration.Foo"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="为不同的环境配置不同的日志级别"><a href="#为不同的环境配置不同的日志级别" class="headerlink" title="为不同的环境配置不同的日志级别"></a>为不同的环境配置不同的日志级别</h2><p>使用 <code>springProfile</code> 标签</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">debug</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">"org/springframework/boot/logging/logback/base.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"STDOUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- encoders are assigned the type</span></span><br><span class="line"><span class="comment">             ch.qos.logback.classic.encoder.PatternLayoutEncoder by default --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"test,dev"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"wang.depp"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"pre,pro"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"wang.depp"</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>本地 application.yml 配置环境参数</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span></span><br><span class="line"><span class="attr">    active:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure><p>打包部署时指定环境</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">$ java -jar \target\my-app<span class="selector-class">.jar</span> -Dspring<span class="selector-class">.profiles</span><span class="selector-class">.active</span>=dev</span><br></pre></td></tr></table></figure><h2 id="输出到日志文件"><a href="#输出到日志文件" class="headerlink" title="输出到日志文件"></a>输出到日志文件</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">debug</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">"org/springframework/boot/logging/logback/base.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"STDOUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- encoders are assigned the type</span></span><br><span class="line"><span class="comment">             ch.qos.logback.classic.encoder.PatternLayoutEncoder by default --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"baselog"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">File</span>&gt;</span>log/app.log<span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--根据日期存放日志，每个文件限制 64MB --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>log/app.log.%d.%i<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--or whenever the file size reaches 64 MB--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>64 MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志文件的日志格式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                %d %p (%file:%line\)- %m%n</span><br><span class="line">            <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 此处设置字符集 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"test,dev"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"wang.depp"</span> <span class="attr">level</span>=<span class="string">"debug"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"baselog"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"pre,pro"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"wang.depp"</span> <span class="attr">level</span>=<span class="string">"error"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"baselog"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="搭建-ELK-平台图形化查看日志"><a href="#搭建-ELK-平台图形化查看日志" class="headerlink" title="搭建 ELK 平台图形化查看日志"></a>搭建 ELK 平台图形化查看日志</h2><p>ELK：Elasticsearch、Logstash、Kibana</p><p>大致原理：</p><p><img src="https://developer.ibm.com/developer/default/articles/build-elk-and-use-it-for-springboot-and-nginx/images/image001.png" alt="图 1. ELK 的大致工作流程"></p><p>详细搭建过程：<a href="https://developer.ibm.com/zh/articles/build-elk-and-use-it-for-springboot-and-nginx/" target="_blank" rel="noopener">搭建 ELK 实时日志平台并在 Spring Boot 和 Nginx 项目中使用</a></p><h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1264739155914176" target="_blank" rel="noopener">廖雪峰 - 使用 SLF4J 和 Logback</a></li><li><a href="http://logback.qos.ch/manual/configuration.html" target="_blank" rel="noopener">Chapter 3: Logback configuration</a></li><li><a href="https://howtodoinjava.com/spring-boot2/logging/profile-specific-logging/" target="_blank" rel="noopener">Spring boot profile specific logging example</a></li><li><a href="https://mp.weixin.qq.com/s/hJvkRlt9xQbWhYy1G7ZDsw" target="_blank" rel="noopener">打印日志的正确姿势</a></li></ul><!--[我定的日志规范被 CTO 在全公司推广了](https://www.cnblogs.com/yinjihuan/p/12091701.html)-->]]></content:encoded>
      
      <comments>https://depp.wang/2020/10/30/logback-use-summary/#disqus_thread</comments>
    </item>
    
    <item>
      <title>接口限流的几种算法</title>
      <link>https://depp.wang/2020/10/27/several-algorithms-for-api-rate-limiting/</link>
      <guid>https://depp.wang/2020/10/27/several-algorithms-for-api-rate-limiting/</guid>
      <pubDate>Tue, 27 Oct 2020 20:48:37 GMT</pubDate>
      <description>
      
        &lt;p&gt;今天面试遇到一个关于接口限流的问题：&lt;strong&gt;设计一个方案，保证每秒只有 10 个请求可以访问接口&lt;/strong&gt;。不得不说，此问题可以很好的考察面试高级工程师岗位的候选人的过往经验。不过很遗憾，我原来并没有做过这方面的工作。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>今天面试遇到一个关于接口限流的问题：<strong>设计一个方案，保证每秒只有 10 个请求可以访问接口</strong>。不得不说，此问题可以很好的考察面试高级工程师岗位的候选人的过往经验。不过很遗憾，我原来并没有做过这方面的工作。</p><a id="more"></a><p>在自己的知识储备中，首先想到的是：假如保证每秒只有 1 个请求访问接口，如何实现。在这个前提下，首先想到的是直接加锁，加锁后，每次只有一个请求可以访问接口，但是每个请求的处理时间不确定，可能小于 1s（也可能大于 1 s），此种方法不符合问题要求，pass。</p><p>接着想到使用 Redis 设置 1 个过期时间为 1s 的互斥 key，key 的命名可根据业务场景设定，每个请求均尝试设置这个 key，设置成功就可以访问接口，否则拒绝。而针对每秒限制 10 个请求，就索性设置 10 个过期时间为 1s 的互斥 key，每个请求使用 for 循环依次尝试设置这 10 个 key，前 10 个请求就将 10 key 设置，当第 1 个 key 没有过期时，第 11 个请求将设置失败，访问拒绝。此种虽然可以变相实现需求，但有一个巨大的问题，假设 QPS 为 1 万，每秒限制 100 个请求，Redis 客户端和服务器通信的网络 IO，将变成 100 万次，不敢想。</p><p>面试完成之后（当然挂了），发现思考方向还是太窄了，有很多简单方式就能实现限流。</p><h2 id="1、计数器（固定时间窗口算法）"><a href="#1、计数器（固定时间窗口算法）" class="headerlink" title="1、计数器（固定时间窗口算法）"></a>1、计数器（固定时间窗口算法）</h2><p>使用一个计数器代表请求数，设置每秒请求限制数为 10（图片为 100） ，当请求间隔大于 1s（图片为 1 minutes） 时，请求通过，重置计数器，当前时间设为间隔开始时间；当间隔时间小于 1 s 时，计数器加 1，如果计数器大于限制数时，此时请求拒绝，小于时，请求通过。因为间隔时间固定，所以这种方式也叫固定时间窗口算法。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-10-27-124254.jpg" alt="2016-09-01_20:31:28.jpg"></p><p>伪代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeStamp = getNowTime();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> reqCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> limit = <span class="number">10</span>; <span class="comment">// 时间窗口内最大请求数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> interval = <span class="number">1000</span>; <span class="comment">// 时间窗口 1000 ms, 1s</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">grant</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> now = getNowTime();</span><br><span class="line">        <span class="keyword">if</span> (now &lt; timeStamp + interval) &#123;</span><br><span class="line">            <span class="comment">// 在时间窗口内</span></span><br><span class="line">            reqCount++;</span><br><span class="line">            <span class="comment">// 判断当前时间窗口内是否超过最大请求控制数</span></span><br><span class="line">            <span class="keyword">return</span> reqCount &lt;= limit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            timeStamp = now;</span><br><span class="line">            <span class="comment">// 超时后重置</span></span><br><span class="line">            reqCount = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程安全代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeStamp = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger reqCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> limit = <span class="number">10</span>; <span class="comment">// 时间窗口内最大请求数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> interval = <span class="number">1000</span>; <span class="comment">// 时间窗口 1000 ms, 1s</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">grant</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (now &lt; timeStamp + interval) &#123;</span><br><span class="line">            <span class="comment">// 在时间窗口内</span></span><br><span class="line">            reqCount.incrementAndGet();</span><br><span class="line">            <span class="comment">// 判断当前时间窗口内是否超过最大请求控制数</span></span><br><span class="line">            <span class="keyword">return</span> reqCount.get() &lt;= limit;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timeStamp = now;</span><br><span class="line">            <span class="comment">// 超时后重置</span></span><br><span class="line">            reqCount.set(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/signin"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">doSignin</span><span class="params">(@RequestParam(<span class="string">"email"</span>)</span> String email, @<span class="title">RequestParam</span><span class="params">(<span class="string">"password"</span>)</span> String password,</span></span><br><span class="line"><span class="function">HttpSession session) </span>&#123;</span><br><span class="line">        CounterDemo counter = <span class="keyword">new</span> CounterDemo();</span><br><span class="line">        <span class="keyword">if</span> (!counter.grant()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"signin.html"</span>, Map.of(<span class="string">"email"</span>, email, <span class="string">"error"</span>, <span class="string">"Signin failed"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">User user = userService.signin(email, password);</span><br><span class="line">session.setAttribute(KEY_USER, user);</span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"signin.html"</span>, Map.of(<span class="string">"email"</span>, email, <span class="string">"error"</span>, <span class="string">"Signin failed"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"redirect:/profile"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一个接口一个 counter，如果要限制所有接口的每秒请求数，可以在 Filter 中设置。</p><h2 id="2、滑动时间窗口算法（Sliding-Window）"><a href="#2、滑动时间窗口算法（Sliding-Window）" class="headerlink" title="2、滑动时间窗口算法（Sliding Window）"></a>2、滑动时间窗口算法（Sliding Window）</h2><p>如果每秒限制请求访问数量为系统临界值时，假设每秒 100 次，如果 1s 内前 800ms 内没有访问，后 200ms 内访问了 100 次，后 1s 的前 200ms 又访问了 100 次，此时这 1s 就访问 200 次，此时可能会造成系统崩溃。但如果限制每秒访问次数是 10 次，那么上面计数器这种方式就足够了，毕竟每秒最多 20 次访问不会出现什么问题。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-10-27-073522.png" alt="img"></p><p>此时需要使用滑动窗口来保证间隔处不会出现超限制请求的情况。具体需要记录时间窗口每个请求的时间，即在时间窗口内每个接口请求到达的时间点。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-10-27-123937.png" alt="img"></p><p>滑动窗口记录的时间点 list = (t_1, t_2, …t_k)，起点是 list 中最小的时间点 t_1。模拟：当 t_m 时刻新的请求到来时，如果 t_m 在 t_1 + 1 内，判断 list.size() 是否小于 100，是，t_m 加入 list，通过。如果不在，丢弃第一个时间点 t_1，通过。</p><p>伪代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SlidingWindowDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> limit = <span class="number">100</span>; <span class="comment">// 时间窗口内最大请求数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> interval = <span class="number">1000</span>; <span class="comment">// 时间窗口 1000 ms, 1s</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Long&gt; reqTimes = <span class="keyword">new</span> ArrayList&lt;&gt;()&#123;&#123;</span><br><span class="line">        add(getNowTime());</span><br><span class="line">    &#125;&#125;; <span class="comment">// 记录请求的时间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">grant</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> t_m = getNowTime();</span><br><span class="line">        <span class="comment">// 判断 t_m 是否在时间窗口内</span></span><br><span class="line">        <span class="keyword">if</span> (t_m &lt; reqTimes.get(<span class="number">0</span>) + interval) &#123;</span><br><span class="line">            <span class="comment">// 判断当前时间窗口内是否超过最大请求控制数</span></span><br><span class="line">            <span class="keyword">if</span> (reqTimes.size() &lt; limit) &#123;</span><br><span class="line">            reqTimes.add(t_m);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不在时间窗口内，丢弃第一个时间点</span></span><br><span class="line">            requestTimes.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在滑动窗口中，在时间窗口间隔处，如果时间窗口的后 200 毫秒有了 100 次访问，下一个时间窗口前 800 毫秒的请求将被拒绝。</p><p>每个时间窗口（1s）list 最多 100 个。</p><h2 id="3、漏桶算法（Leaky-Bucket"><a href="#3、漏桶算法（Leaky-Bucket" class="headerlink" title="3、漏桶算法（Leaky Bucket)"></a>3、漏桶算法（<a href="https://en.wikipedia.org/wiki/Leaky_bucket" target="_blank" rel="noopener">Leaky Bucket</a>)</h2><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-10-29-145111.jpg" alt="img"></p><p>滑动时间窗口无法应对细时间粒度（某个时间）的突发性请求，示例：当 t_1 = 1ms，来了 50 个请求，窗口有 50 个时间点了，中间没有请求，t_3 = 900 ms，又来了 100 个请求，只能加入 50 个。</p><p>漏桶算法在此方面有更好的表现，它以指定速度漏出请求（水），如果可以往桶里加请求，代表请求可以访问。漏出量无需使用额外线程控制，根据时间间隔和速率减少。</p><p>假设限制每秒请求数限制为 100，那么设置桶的容量为 100，1 秒漏完，流速为 100 request/s（0.1 request/ms），默认容量为 0。</p><p>伪代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeakyBucketDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeStamp = getNowTime();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity = <span class="number">100</span>; <span class="comment">// 桶的容量 100</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> rate = <span class="number">0.1f</span>; <span class="comment">// 水漏出的速度 0.1（浮点型 * 整数结果去除精度）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> water = <span class="number">0</span>; <span class="comment">// 当前水量(当前累积请求数) 0</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">grant</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> now = getNowTime();</span><br><span class="line">        water = max(<span class="number">0</span>, water - (now - timeStamp) * rate); <span class="comment">// 先执行漏水，计算剩余水量</span></span><br><span class="line">        timeStamp = now;</span><br><span class="line">        <span class="keyword">if</span> ((water + <span class="number">1</span>) &lt; capacity) &#123;</span><br><span class="line">            <span class="comment">// 尝试加水,并且水还未满</span></span><br><span class="line">            water += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 水满，拒绝加水</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析临界情况：漏桶算法没有时间窗口的概念，如果 water 还是 0，当 10ms 有 100 个请求过来后，此时 water 容量为 100，10ms 能漏掉的请求 10*0.1 = 1，water = 99。所以请求 101 次时，请求将被拒绝。</p><p>分析细时间粒度的突发性请求情况：50 个请求在 899ms 的时间内已经漏完了，所以第 900ms 的 100 个请求可以容纳。</p><h2 id="4、令牌桶算法（Token-bucket）"><a href="#4、令牌桶算法（Token-bucket）" class="headerlink" title="4、令牌桶算法（Token bucket）"></a>4、令牌桶算法（<a href="https://en.wikipedia.org/wiki/Token_bucket" target="_blank" rel="noopener">Token bucket</a>）</h2><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-10-27-105409.jpg" alt="image"></p><p>上面漏桶算法是往里面塞，这个令牌桶算法是从里面取。以一个固定的速率往桶中加 token（令牌），每次请求均从桶中取一个令牌，没有令牌将不能访问。添加令牌也无需使用额外线程控制，根据时间间隔和速率来添加。</p><p>假设限制每秒请求数限制为 100，那么每 1 秒最多取走 100 个 token，桶的容量 100，令牌放入的速度 100 token/s，0.1 token/ms。</p><p>伪代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenBucketDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeStamp = getNowTime();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity = <span class="number">100</span>; <span class="comment">// 桶的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> rate = <span class="number">0.1f</span>; <span class="comment">// 令牌放入速度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tokens = <span class="number">100</span>; <span class="comment">// 当前令牌数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">grant</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> now = getNowTime();</span><br><span class="line">        <span class="comment">// 先添加令牌</span></span><br><span class="line">        tokens = min(capacity, tokens + (now - timeStamp) * rate); </span><br><span class="line">        timeStamp = now;</span><br><span class="line">        <span class="keyword">if</span> (tokens &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 若不到 1 个令牌,则拒绝</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 还有令牌，领取令牌</span></span><br><span class="line">            tokens -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果限制请求很低，可以直接使用计数器（固定时间窗口算法）。</p><p>滑动时间窗口算法需要更多的内存。</p><p>令牌桶和漏桶算法当出现峰值后，添加 token 和漏水有速度控制，下一次不能马上达到峰值，所以相比固定时间窗口算法更加平滑。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-10-27-155606.jpg" alt=""></p><p>令牌桶算法，当桶满了，可以一下拿走 100 个令牌。漏桶算法，漏完了，一次可以加 100 个请求。所以相比滑动时间窗口算法可应对突发性请求。</p><p>一般来说，也不会直接用代码去实现相应的算法，而是在 ngix 中<a href="http://nginx.org/en/docs/http/ngx_http_limit_req_module.html" target="_blank" rel="noopener">配置</a>，ngix 限流默认使用的漏桶算法。</p><!--所以令牌桶和漏桶算法比较适合阻塞式限流。--><!--在使用系统最大性能的情况下，尽量是请求均匀分布--><!--ngix 配置、hystrix--><!--漏桶算法取的速度可控制？--><!--QPS，服务线程有多少？--><!--cpu 数，线程数，请求数，请求时间--><!--8 核线程，100 个线程--><!--带宽，每秒处理的事务数 (TPS)，每秒请求数 (hits per second)、并发请求数。--><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://juejin.im/entry/6844903443484639240" target="_blank" rel="noopener">接口限流算法总结</a></li><li><a href="https://www.infoq.cn/article/microservice-interface-rate-limit" target="_blank" rel="noopener">微服务接口限流的设计与思考（附 GitHub 框架源码）</a></li></ul><!--[接口限流看这一篇就够了！！！](https://www.cnblogs.com/Chenjiabing/p/12534346.html)--><!--[Everything You Need To Know About API Rate Limiting](https://nordicapis.com/everything-you-need-to-know-about-api-rate-limiting/)-->]]></content:encoded>
      
      <comments>https://depp.wang/2020/10/27/several-algorithms-for-api-rate-limiting/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java 实现一个自定义分布式 Session</title>
      <link>https://depp.wang/2020/10/26/java-implements-a-custom-distributed-session/</link>
      <guid>https://depp.wang/2020/10/26/java-implements-a-custom-distributed-session/</guid>
      <pubDate>Mon, 26 Oct 2020 11:55:55 GMT</pubDate>
      <description>
      
        &lt;p&gt;HTTP 是无状态协议，所以服务端如果需要记住登录用户，就需要维护一个 SessionId(Cookie) - Session 的键值对。Session 存放用户信息对象。用户信息对象作为 Session 的一个 Attribute。当浏览器请求中包含 Cookie 时，服务器就能识别出具体是哪个用户了。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>HTTP 是无状态协议，所以服务端如果需要记住登录用户，就需要维护一个 SessionId(Cookie) - Session 的键值对。Session 存放用户信息对象。用户信息对象作为 Session 的一个 Attribute。当浏览器请求中包含 Cookie 时，服务器就能识别出具体是哪个用户了。</p><a id="more"></a><p>默认 SessionId 与 Session 的键值对由服务器来维护，Session 的过期时间默认为 30 分钟（可通过 Debug 查看 maxInactiveInterval 的值）。</p><h2 id="使用-HttpSession"><a href="#使用-HttpSession" class="headerlink" title="使用 HttpSession"></a>使用 HttpSession</h2><p>下面是一个简单的使用 Session 来保存用户登录状态的例子，相关代码我放到了 <a href="https://github.com/DeppWang/springboot-session" target="_blank" rel="noopener">GitHub</a> 上</p><p><strong>设置 Attribute</strong>（登录时）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/signin"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">doSignin</span><span class="params">(@RequestParam(<span class="string">"email"</span>)</span> String email, @<span class="title">RequestParam</span><span class="params">(<span class="string">"password"</span>)</span> String password, HttpSession session) </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">User user = userService.signin(email, password);</span><br><span class="line">session.setAttribute(KEY_USER, user);</span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"signin.html"</span>, Map.of(<span class="string">"email"</span>, email, <span class="string">"error"</span>, <span class="string">"Signin failed"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"redirect:/profile"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取 Attribute</strong>（判断是否已经登录）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/profile"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">profile</span><span class="params">(HttpSession session)</span> </span>&#123;</span><br><span class="line">User user = (User) session.getAttribute(KEY_USER);</span><br><span class="line"><span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"redirect:/signin"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"profile.html"</span>, Map.of(<span class="string">"user"</span>, user));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>删除 Attribute</strong>（退出时）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/signout"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">signout</span><span class="params">(HttpSession session)</span> </span>&#123;</span><br><span class="line">session.removeAttribute(KEY_USER);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"redirect:/signin"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>HttpSession session</code> 可以用 <code>HTTPServletRequest request</code> 代替，此时使用 <code>request.getSession().getAttribute()</code>。<code>HttpSession session</code> 和 <code>HTTPServletRequest request</code> 可以认为是方法默认就包含的参数。</p><p>Session 的生命周期是半小时，如果半小时后访问时，服务器将重新建立连接，将发送新的 SessionId 到浏览器，再次访问时， 新 Session 中将没有 User，此时登录将失效。</p><p>浏览器 Cookie 样式：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Cookie: <span class="attribute">JSESSIONID</span>=C8698B74AFAD403C6E28D77B75373500</span><br></pre></td></tr></table></figure><p>此部分代码对应 <a href="https://github.com/DeppWang/springboot-demos/tree/master/springboot-session/src/main/java/wang/depp/session/web/v1" target="_blank" rel="noopener">v1</a></p><h2 id="使用-Redis"><a href="#使用-Redis" class="headerlink" title="使用 Redis"></a>使用 Redis</h2><p>当存在跨域问题时，即多个服务都需要用到 Session 判断登录状态时，就需要将 Session 在每个服务中复制一份，或做成分布式 Session。一般使用 Redis 实现。</p><p>下面使用 Redis 来维护这个 SessionId - Session 的键值对，或者说维护一个 SessionId - Attributes 的键值对。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> EXPIRE_TIME = <span class="number">1800</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HttpServletRequest <span class="title">getRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServletRequestAttributes attrs = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        <span class="keyword">return</span> attrs.getRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String name, Object value)</span> </span>&#123;</span><br><span class="line">        String sessionId = getRequest().getSession().getId();</span><br><span class="line">        Map&lt;String, Object&gt; attributes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        attributes.put(name, value);</span><br><span class="line">        RedisUtils.setKey(sessionId, JsonUtils.getJson(attributes), EXPIRE_TIME, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">getAttribute</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        String sessionId = getRequest().getSession().getId();</span><br><span class="line">        String attributesJson = RedisUtils.getKey(sessionId);</span><br><span class="line">        Map&lt;String, Object&gt; attributes = JsonUtils.fromJson(attributesJson, Map.class);</span><br><span class="line">        <span class="keyword">return</span> attributes.get(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> User <span class="title">getKeyUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Object user = getAttribute(name);</span><br><span class="line">        <span class="keyword">return</span> JsonUtils.fromJson(user.toString(), User.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeAttribute</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        String sessionId = getRequest().getSession().getId();</span><br><span class="line">        String attributesJson = RedisUtils.getKey(sessionId);</span><br><span class="line">        Map&lt;String, Object&gt; attributes = JsonUtils.fromJson(attributesJson, HashMap.class);</span><br><span class="line">        attributes.remove(name);</span><br><span class="line">        RedisUtils.setKey(sessionId, JsonUtils.getJson(attributes), EXPIRE_TIME, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义 RedisUtils，使用静态方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate autowiredStringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stringRedisTemplate = <span class="keyword">this</span>.autowiredStringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(String key, String value, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(addKeyPrefix(key), value, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stringRedisTemplate.opsForValue().get(addKeyPrefix(key));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">deleteKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stringRedisTemplate.opsForValue().getOperations().delete(addKeyPrefix(key));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">incrementKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stringRedisTemplate.opsForValue().increment(addKeyPrefix(key));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">addKeyPrefix</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"session:%s"</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserController </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">extends</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/signin"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">doSignin</span><span class="params">(@RequestParam(<span class="string">"email"</span>)</span> String email, @<span class="title">RequestParam</span><span class="params">(<span class="string">"password"</span>)</span> String password) </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">User user = userService.signin(email, password);</span><br><span class="line">setAttribute(KEY_USER, user);</span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"signin.html"</span>, Map.of(<span class="string">"email"</span>, email, <span class="string">"error"</span>, <span class="string">"Signin failed"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"redirect:/profile"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/profile"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">profile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">User user = getKeyUser(KEY_USER);</span><br><span class="line"><span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"redirect:/signin"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"profile.html"</span>, Map.of(<span class="string">"user"</span>, user));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/signout"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">signout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">removeAttribute(KEY_USER);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"redirect:/signin"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此部分代码对应 <a href="https://github.com/DeppWang/springboot-demos/tree/master/springboot-session/src/main/java/wang/depp/session/web/v2" target="_blank" rel="noopener">v2</a></p><h2 id="自定义-Session"><a href="#自定义-Session" class="headerlink" title="自定义 Session"></a>自定义 Session</h2><!--为什么要自定义 Session？ 转发后的请求就包含了 Session，不用传输参数？--><p>上面这种方式实现了一个简单的分布式 Session，我们可以自定义 Session 来对其进行一定优化，使其具有以下特点：</p><ul><li>封装 Attribute 的设置与获取的实现细节</li><li>可以自定义 Cookie</li><li>Attributes 做一个二级缓存，自定义 Session 中存放一份，Redis 再存放一份。</li></ul><p>需要利用下面这几个原生类：</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">HttpSession</span></span><br><span class="line"><span class="attribute">HttpServletRequestWrapper</span></span><br><span class="line"><span class="attribute">HttpServletResponseWrapper</span></span><br></pre></td></tr></table></figure><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>1、设置自定义 Session、Request 和 Response</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrapperSession</span> <span class="keyword">implements</span> <span class="title">HttpSession</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;StoreType, SessionStore&gt; sessionStores;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrapperSessionServletRequest</span> <span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> WrapperSession wrapperSession;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrapperSessionServletResponse</span> <span class="keyword">extends</span> <span class="title">HttpServletResponseWrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> WrapperSession session;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、使用 session-config.xml 配置 cookie 和 cache，一个 entry 对应一个 SessionConfigEntry。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sessionConfig</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">entries</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">name</span>=<span class="string">"sessionId"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span>js<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">httponly</span>&gt;</span>true<span class="tag">&lt;/<span class="name">httponly</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">readonly</span>&gt;</span>true<span class="tag">&lt;/<span class="name">readonly</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">encrypt</span>&gt;</span>false<span class="tag">&lt;/<span class="name">encrypt</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">storeType</span>&gt;</span>cookie<span class="tag">&lt;/<span class="name">storeType</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">       <span class="tag">&lt;<span class="name">entry</span> <span class="attr">name</span>=<span class="string">"__user__"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">storeType</span>&gt;</span>cache<span class="tag">&lt;/<span class="name">storeType</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>wang.depp.session.entity.User<span class="tag">&lt;/<span class="name">type</span>&gt;</span> <span class="comment">&lt;!--类型用于 String 转换 对象--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">entries</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">sessionConfig</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionConfigEntry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> StoreType storeType;</span><br><span class="line">    <span class="keyword">private</span> String domain;</span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、使用 CookieStore 存放 Cookie。使用 CacheStore 存放 attributes，获取 attribute 时默认直接从 CacheStore 中取（CacheStore 从 Redis 缓存中读取）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheStore</span> <span class="keyword">implements</span> <span class="title">SessionStore</span>, <span class="title">SessionCacheContainerAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WrapperSessionServletRequest wrapperRequest;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; attributes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CookieStore</span> <span class="keyword">implements</span> <span class="title">SessionStore</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; undecodedCookies = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Attribute&gt; attributes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链路调用"><a href="#链路调用" class="headerlink" title="链路调用"></a>链路调用</h3><p>1、项目启动时根据 session-config.xml 中初始化 SessionConfigEntry</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrapperSessionFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">         WrapperSessionServletRequest krqRequest = <span class="keyword">new</span> WrapperSessionServletRequest((HttpServletRequest) request);</span><br><span class="line">         WrapperSessionServletResponse krqResponse = <span class="keyword">new</span> WrapperSessionServletResponse((HttpServletResponse) response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initSessionStore();</span><br><span class="line">        <span class="keyword">this</span>.sessionId = getSessionId(); <span class="comment">// 从 CookieStore 的 attributes 中获取 sessionId</span></span><br><span class="line">        generateTrackId();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initSessionStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (SessionStore sessionStore : sessionStores.values()) &#123;</span><br><span class="line">            sessionStore.init(); <span class="comment">// 分别调用子类的 init() 方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>2、请求时，拦截，查找 SessionId 在 Redis 是否有对应的 Attributes，设置时先设置到 SessionStore</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheStore</span> <span class="keyword">implements</span> <span class="title">SessionStore</span>, <span class="title">SessionCacheContainerAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WrapperSessionServletRequest wrapperRequest;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; attributes;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(SessionConfigEntry sessionConfigEntry, Object value)</span> </span>&#123;</span><br><span class="line">        value = RedisUtils.getKey(wrapperRequest.getSession().getId());; <span class="comment">// 设置前，先从 Redis 写入 attributes</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == value) &#123; <span class="comment">// 如果不存在，删除</span></span><br><span class="line">            attributes.remove(sessionConfigEntry.getName());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            attributes.put(sessionConfigEntry.getName(), value);  <span class="comment">// 如果存在，将更新</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、返回前端前，将 Attributes 更新到 Redis</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrapperSessionServletResponse</span> <span class="keyword">extends</span> <span class="title">HttpServletResponseWrapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PrintWriter <span class="title">getWriter</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        getSession().commit(); <span class="comment">// 延长 session 的时间</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getWriter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        writeToCache();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeToCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (attributes.entrySet().size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">            String value = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                value = mapper.writeValueAsString(attributes);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            RedisUtils.setKey(wrapperRequest.getSession().getId(), value, wrapperRequest.getSession().getMaxInactiveInterval());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>4、获取时，直接从 SessionStore 中获取，默认将从 Redis 中读取一次，读取后将不再读取，因为以后都就将写入 Attributes</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getAttribute</span><span class="params">(SessionConfigEntry sessionConfigEntry)</span> </span>&#123;</span><br><span class="line">    loadCache(); <span class="comment">// 先从 Redis 写入 attributes，当 readFromCache() 方法调用后，此时将不再从 Redis 中获取。如果当前对象一直存活，直接写入到 attribute，将不用从 Redis 中读取</span></span><br><span class="line">    <span class="keyword">return</span> attributes.get(sessionConfigEntry.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>UserController</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">extends</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/signin"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">doSignin</span><span class="params">(@RequestParam(<span class="string">"email"</span>)</span> String email, @<span class="title">RequestParam</span><span class="params">(<span class="string">"password"</span>)</span> String password) </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">User user = userService.signin(email, password);</span><br><span class="line">setAttribute(KEY_USER, user);</span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"signin.html"</span>, Map.of(<span class="string">"email"</span>, email, <span class="string">"error"</span>, <span class="string">"Signin failed"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"redirect:/profile"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/profile"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">profile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">User user = (User) getAttribute(KEY_USER);</span><br><span class="line"><span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"redirect:/signin"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"profile.html"</span>, Map.of(<span class="string">"user"</span>, user));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/signout"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">signout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">removeAttribute(KEY_USER);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"redirect:/signin"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BaseController</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前 HttpServletRequest</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HttpServletRequest <span class="title">getRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServletRequestAttributes attrs = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        <span class="keyword">return</span> attrs.getRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String name, Object value)</span> </span>&#123;</span><br><span class="line">        getRequest().getSession().setAttribute(name, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getAttribute</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getRequest().getSession().getAttribute(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeAttribute</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        getRequest().getSession().removeAttribute(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此部分代码对应 <a href="https://github.com/DeppWang/springboot-demos/tree/master/springboot-session/src/main/java/wang/depp/session/web/v3" target="_blank" rel="noopener">v3</a>。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>自定义分布式 Session 一般实现在网关中，网关接口对外暴露，请求先调用网关，网关请求只能内网访问的业务系统接口。网关和业务系统规定相应的调用规则（如：添加指定 Header），网关来负责验证登录状态。</p><p>Redis 可以实现集群保证可用性。当不使用分布式 Session 时，可以使用 <a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">JSON Web Token</a></p>]]></content:encoded>
      
      <comments>https://depp.wang/2020/10/26/java-implements-a-custom-distributed-session/#disqus_thread</comments>
    </item>
    
    <item>
      <title>HashMap 常问的 9 个问题</title>
      <link>https://depp.wang/2020/08/20/hashmap-9-question/</link>
      <guid>https://depp.wang/2020/08/20/hashmap-9-question/</guid>
      <pubDate>Thu, 20 Aug 2020 17:58:35 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-08-22-111236.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;!--[img](https://javabynataraj.files.wordpress.com/2014/06/types_of_hashmapiteration_javabynataraj.png)--&gt;

&lt;h2 id=&quot;1、HashMap-的数据结构是什么？&quot;&gt;&lt;a href=&quot;#1、HashMap-的数据结构是什么？&quot; class=&quot;headerlink&quot; title=&quot;1、HashMap 的数据结构是什么？&quot;&gt;&lt;/a&gt;1、HashMap 的数据结构是什么？&lt;/h2&gt;&lt;p&gt;HashMap 我们知道 HashMap 的数据结构是数组+链表，所以这个问题可以理解为数组+链表有什么优点？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果只是数组，就存在数组的缺点，如：需要更长的连续内存空间；扩容更加频繁；并且删除操作需要移动其他元素位置，等等&lt;/li&gt;
&lt;li&gt;如果只是链表，就存在链表的缺点，如：查找复杂度 O(n) 太高，等等&lt;/li&gt;
&lt;li&gt;而数组+链表是一个折中的方案&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-08-22-111236.png" alt="img"></p><!--[img](https://javabynataraj.files.wordpress.com/2014/06/types_of_hashmapiteration_javabynataraj.png)--><h2 id="1、HashMap-的数据结构是什么？"><a href="#1、HashMap-的数据结构是什么？" class="headerlink" title="1、HashMap 的数据结构是什么？"></a>1、HashMap 的数据结构是什么？</h2><p>HashMap 我们知道 HashMap 的数据结构是数组+链表，所以这个问题可以理解为数组+链表有什么优点？</p><ul><li>如果只是数组，就存在数组的缺点，如：需要更长的连续内存空间；扩容更加频繁；并且删除操作需要移动其他元素位置，等等</li><li>如果只是链表，就存在链表的缺点，如：查找复杂度 O(n) 太高，等等</li><li>而数组+链表是一个折中的方案</li></ul><a id="more"></a><h2 id="2、为什么数组的默认长度是-16？"><a href="#2、为什么数组的默认长度是-16？" class="headerlink" title="2、为什么数组的默认长度是 16？"></a>2、为什么数组的默认长度是 16？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The default ∞initial capacity - MUST be a power of two. 默认初始容量必须是 2 的幂次方。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br></pre></td></tr></table></figure><p>这跟计算数组下标有关，计算数组下标的代码为 <code>index = hash &amp; (n-1)</code>，当 n 为 2 的幂，如 16，n-1 = 15，转换为二进制为 <code>1111</code>，通过按位与 <code>&amp;</code> ，数组下标就由 hash 二进制的低 4 位决定。比起传统的取模（余）操作，效率更高。</p><h2 id="3、为什么-HashMap-没有直接用-Key-的-hashCode，而是生成一个新的-hash？"><a href="#3、为什么-HashMap-没有直接用-Key-的-hashCode，而是生成一个新的-hash？" class="headerlink" title="3、为什么 HashMap 没有直接用 Key 的 hashCode，而是生成一个新的 hash？"></a>3、为什么 HashMap 没有直接用 Key 的 hashCode，而是生成一个新的 hash？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>同样跟数组下标有关，HashMap 没有用取模（余）运算，而是直接使用低 4 位作为数组下标，如果使用 hashCode 低 4 位，碰撞几率很大，将 hashCode 的低位和高位异或生成 hash，取 hash 的低 4 位作为数组下标，可以增加低位的随机性，减少碰撞。<code>&gt;&gt;&gt;</code> 为<a href="https://depp.wang/2020/01/11/java-operator/#gt-gt-gt-无符号右移运算符">无符号右移</a>，<code>h &gt;&gt;&gt; 16</code>：舍弃右边 16 位，将高位向右移动 16 位，左边用 0 补齐。</p><p>当 key == null 时，hash 为 0，所以 key 可以为 null。</p><h2 id="4、扩容因子为-0-75，有什么好处？"><a href="#4、扩容因子为-0-75，有什么好处？" class="headerlink" title="4、扩容因子为 0.75，有什么好处？"></a>4、扩容因子为 0.75，有什么好处？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the lookup cost (reflected in most of the operations of the HashMap class, including get and put).</span></span><br><span class="line"><span class="comment">// 作为一般的规则，默认扩容因子（.75）在时间和空间成本之间提供了一个很好的折中。较高的值减少了空间开销，但增加了查找成本（反映在 HashMap 类的大多数操作中，包括 get 和 put）。 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure><ul><li>如果是 0.5 的话，空间利用率不高，扩容太频繁。</li><li>如果是 1 的话，因为不是均匀分布，碰撞产生链表，扩容后，链表将更长，查找和修改的时间复杂度将更高。</li><li>0.75 是一个折中的方案。</li><li>注意：扩容触发条件 0.75，不是指数组 75% 的区域被占用时，而是指当前 Map 的容量，包括链表上的元素。</li></ul><h2 id="5、HashMap-如何扩容？"><a href="#5、HashMap-如何扩容？" class="headerlink" title="5、HashMap 如何扩容？"></a>5、HashMap 如何扩容？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">    resize();</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 创建一个容量为原来的 2 倍的新数组</span></span><br><span class="line">    newCap = oldCap &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 当只有一个元素时，根据节点原来的 hash 和新的数组长度得到新的数组下标</span></span><br><span class="line">            <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">            newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// oldCap 初始为 16，即 10000，最高位始终为 1，通过 1 来随机判断使用原数组下标还是加上原数组长度的新数组下标</span></span><br><span class="line">                <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>)</span><br><span class="line">                    loHead = e</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                    hiHead = e</span><br><span class="line">            <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    newTab[j] = loHead;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    newTab[j + oldCap] = hiHead;</span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先，HashMap 需要扩容，否则，链表长度过长，查找和修改的复杂度都将变高。</li><li>扩容时，创建一个容量为原来的 2 倍的新数组，遍历原数组，如果当前位置只有一个元素，则根据节点原来的 hash 和新的数组长度得到新的数组下标，如果是一个链表，则通过 oldCap 来随机判断使用原数组下标还是加上原数组长度的新数组下标</li><li>因为需要扩容，需要额外的性能，在能估算容量的情况下，可以直接设置初始容量。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="6、HashMap-为什么线程不安全？"><a href="#6、HashMap-为什么线程不安全？" class="headerlink" title="6、HashMap 为什么线程不安全？"></a>6、HashMap 为什么线程不安全？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;</span></span><br></pre></td></tr></table></figure><ul><li>HashMap 不是线程安全的，它的线程安全版本是 HashTable 和 ConcurrentHashMap</li><li>它的线程不安全是因为 HashMap 存在变量，如 DEFAULT_INITIAL_CAPACITY 等，对象在方法中使用这些共享变量时，没有加锁。共享变量在并发操作，值容易被覆盖，存在丢失数据的问题。</li><li>在 jdk 1.7 中，并发操作下，扩容时，还可能造成死循环，<a href="https://stackoverflow.com/questions/35534906/java-hashmap-getobject-infinite-loop/44180452#44180452" target="_blank" rel="noopener">Java HashMap.get(Object) infinite loop</a></li></ul><h2 id="7、为什么如果对象作为-HashMap-的-Key，对象需要重写-hashCode-和-equals-方法？"><a href="#7、为什么如果对象作为-HashMap-的-Key，对象需要重写-hashCode-和-equals-方法？" class="headerlink" title="7、为什么如果对象作为 HashMap 的 Key，对象需要重写 hashCode 和 equals 方法？"></a>7、为什么如果对象作为 HashMap 的 Key，对象需要重写 hashCode 和 equals 方法？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 HashMap 通过 Key 对象的 hashCode 计算 hash，还通过 equals 方法比较对象是否相同，如果不重写，相同内容的两个对象，其 hashCode 将不同，也不会相等。</p><p>String 常作为 Map 的 Key，String 如何重写：</p><ul><li>hashCode() - 如果字符串已经存在，那么 hash 不变；如果不存在，通过每个字符的 ASSCII 码计算</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>equals() - 依次比较每个字符是否相同</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：HashSet 是特殊的 HashMap，存放在 HashSet 的对象都需要重写 hashCode() 和 equals() 方法</p><h2 id="8、get-和-containsKey-的时间复杂度是多少？"><a href="#8、get-和-containsKey-的时间复杂度是多少？" class="headerlink" title="8、get() 和 containsKey() 的时间复杂度是多少？"></a>8、get() 和 containsKey() 的时间复杂度是多少？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This implementation provides constant-time performance for the basic operations (get and put)</span></span><br><span class="line"><span class="comment">// 这个实现为基本操作（get 和 put）提供了常量时间性能，假设散列函数将元素正确地分散在存储桶中。</span></span><br></pre></td></tr></table></figure><p>时间复杂度为 O(1)，因为链表的长度不会过长，基本不会达到 8 个</p><h2 id="9、当链表长度大于-8-个时，将链表转换为红黑树，有什么好处？"><a href="#9、当链表长度大于-8-个时，将链表转换为红黑树，有什么好处？" class="headerlink" title="9、当链表长度大于 8 个时，将链表转换为红黑树，有什么好处？"></a>9、当链表长度大于 8 个时，将链表转换为红黑树，有什么好处？</h2><ul><li>链表查找的时间复杂度时 O(n)</li><li>红黑树查找的时间复杂度时 O(logN)</li><li>所以好处是查找和修改的时间复杂度更低</li></ul><h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul><li><a href="https://www.javarticles.com/2012/11/hashmap-faq.html" target="_blank" rel="noopener">HashMap Interview Questions</a></li><li><a href="https://www.quora.com/Why-is-the-load-factor-set-to-0-75-for-a-HashMap-in-Java" target="_blank" rel="noopener">Why is the load factor set to 0.75 for a HashMap in Java?</a></li></ul>]]></content:encoded>
      
      <comments>https://depp.wang/2020/08/20/hashmap-9-question/#disqus_thread</comments>
    </item>
    
    <item>
      <title>在 macOS 中，如何自动压缩截屏图片大小</title>
      <link>https://depp.wang/2020/08/07/how-to-automatically-compress-screenshot-size-in-macos/</link>
      <guid>https://depp.wang/2020/08/07/how-to-automatically-compress-screenshot-size-in-macos/</guid>
      <pubDate>Fri, 07 Aug 2020 14:25:08 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;一、错误的误会&quot;&gt;&lt;a href=&quot;#一、错误的误会&quot; class=&quot;headerlink&quot; title=&quot;一、错误的误会&quot;&gt;&lt;/a&gt;一、错误的误会&lt;/h2&gt;&lt;p&gt;我是这样在 Markdown 中插入截屏图片的：截屏到剪贴板后，直接在 &lt;a href=&quot;https://typora.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Typora&lt;/a&gt; 中粘贴，&lt;a href=&quot;https://apps.apple.com/us/app/ipic-image-file-upload-tool/id1101244278?mt=12&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iPic&lt;/a&gt; 将自动将图片上传到阿里云图床（对象存储）。我一直使用 &lt;a href=&quot;https://www.alfredapp.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Alfred&lt;/a&gt; 的 &lt;a href=&quot;https://www.alfredapp.com/help/features/clipboard/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Clipboard History&lt;/a&gt; 功能查看截图大小，发现图片占内存都很大，全屏截图有 10 多 MB，就想着一定要找到一种方法来缩小截屏大小，不然我的&lt;a href=&quot;https://cn.aliyun.com/price/detail/oss&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阿里云图床费用&lt;/a&gt;得嗖嗖涨。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="一、错误的误会"><a href="#一、错误的误会" class="headerlink" title="一、错误的误会"></a>一、错误的误会</h2><p>我是这样在 Markdown 中插入截屏图片的：截屏到剪贴板后，直接在 <a href="https://typora.io/" target="_blank" rel="noopener">Typora</a> 中粘贴，<a href="https://apps.apple.com/us/app/ipic-image-file-upload-tool/id1101244278?mt=12" target="_blank" rel="noopener">iPic</a> 将自动将图片上传到阿里云图床（对象存储）。我一直使用 <a href="https://www.alfredapp.com/" target="_blank" rel="noopener">Alfred</a> 的 <a href="https://www.alfredapp.com/help/features/clipboard/" target="_blank" rel="noopener">Clipboard History</a> 功能查看截图大小，发现图片占内存都很大，全屏截图有 10 多 MB，就想着一定要找到一种方法来缩小截屏大小，不然我的<a href="https://cn.aliyun.com/price/detail/oss" target="_blank" rel="noopener">阿里云图床费用</a>得嗖嗖涨。</p> <a id="more"></a><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-08-02-024029.png" alt="image" style="zoom:50%;"></p><p>昨天，我将截图不保存到剪贴板，而直接保存到本地，发现图片根本没有 10 多 MB，就几百 KB。想着我这个高分辨率超高清 Retain 全屏截图 🐶 ，不能只有几百 KB 呀 ，一定是我电脑显示有问题。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-08-02-023939.png" alt="image" style="zoom:50%;"></p><p>最后我打开阿里云对象存储在线检查了一下，发现真的只有几百 KB，开始心里默默对 Alfred ***。遂在 Alfred 论坛发<a href="https://www.alfredforum.com/topic/15361-the-copyed-image-in-the-clipboard-that-size-is-a-error-data-between-with-the-actual-size-its-too-large/" target="_blank" rel="noopener">讨论帖</a>，网友回复说，对于剪贴板图片来说，其数据格式是 <a href="https://en.wikipedia.org/wiki/TIFF" target="_blank" rel="noopener">TIFF</a> 数据格式，不是图片本身的内存大小，所以 Clipboard History 数据显示较大。喔霍，原来是个错误的误会呀。</p><p>虽然几百 KB 相对 10 多 MB 是小多了，现在我这小博客无人问津，图床费用每月也就几毛几分钱，图片大点也无所谓。但为了长远考虑，图片当然越小越好。</p><p>正好搜到一篇关于压缩图片的<a href="https://about.gitlab.com/blog/2020/01/30/simple-trick-for-smaller-screenshots/" target="_blank" rel="noopener">优质教程</a>，还包含视频教程，简单的方式就能实现自动压缩图片，那还等什么，得赶快用起来。<strong>强烈推荐看原文</strong>，很通俗易懂。</p><!--下面是基于这篇文章的总结--><h2 id="二、图片压缩"><a href="#二、图片压缩" class="headerlink" title="二、图片压缩"></a>二、图片压缩</h2><h3 id="2-1、压缩时机"><a href="#2-1、压缩时机" class="headerlink" title="2.1、压缩时机"></a>2.1、压缩时机</h3><p>图片压缩有三个时间点，1、截屏时由截屏软件压缩；2、上传到图床时由上传软件压缩；2、上传到图床后由图床压缩。</p><p>下面要介绍的这种方式可以类似看作是第 1 条。</p><p>对于第 2 条，如果你使用 iPic，iPic 有提供可选的有损压缩的功能，先压缩再上传，我大概测试了一下，一般能压缩 60% 多吧（具体视情况而定）。但如果在 Typora 中复制，<a href="https://toolinbox.net/iPic/#comment-4743566071" target="_blank" rel="noopener">不支持压缩</a>，曲线救国的方式是先使用快捷键上传，再在 Typora 中粘贴返回的 URL。个人觉得体验有分裂，没有截屏时就压缩方便，所以才用第 1 种实现。</p><!--，具体损失效果没有对比。--><p>对于第 3 条，七牛云对象存储提供自动图片压缩功能，不过是收费功能。</p><h3 id="2-2、压缩原理"><a href="#2-2、压缩原理" class="headerlink" title="2.2、压缩原理"></a>2.2、压缩原理</h3><p>macOS 默认截屏生成图片的格式为 <a href="https://en.wikipedia.org/wiki/Portable_Network_Graphics" target="_blank" rel="noopener">PNG</a>，更准确的说，是 PNG-32，即每个像素点占 32 位，每个像素点由 4 部分构成，分别是红色（Red）、绿色（Green）、蓝色（Blue）和透明度（Alpha (Transparency)）（简写 RGBA）。所以每种颜色有 2^8（256）个级别，所以图片可以显示 1600 万种颜色（256  ×  256  ×  256, 2^24）。</p><p>截屏一般对颜色要求没那么高，显示 1600 万种颜色与 256 种颜色差别不大，截屏图片基于<a href="https://en.wikipedia.org/wiki/Palette_(computing)" target="_blank" rel="noopener">调色板</a>，可以利用工具将图片显示颜色<a href="http://en.wikipedia.org/wiki/Color_quantization" target="_blank" rel="noopener">更改</a>为 256 种，来实现压缩图片的功能。此时单位像素由 32 位变为 8 位（4 个字节变为 1 个字节），所以大约能压缩 75% 的容量。</p><p>注意：除了 256，还可以选择 128、64、24、16、8、4 等级别，原作者测试 64 跟 256 差不多。这里我选择了 256。</p><h3 id="2-2、pngquant"><a href="#2-2、pngquant" class="headerlink" title="2.2、pngquant"></a>2.2、pngquant</h3><p><a href="https://pngquant.org/" target="_blank" rel="noopener">pngquant</a> 就是一个可以几乎不损害图片质量，通过减少像素大小来压缩 PNG 图片的命令行程序（库），属于有损压缩。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用 HomeBrew 安装 pngquant</span></span><br><span class="line">brew install pngquant</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 32 位的 RGBA PNG 数字转换为 8 位（或更小）的 RGBA 调色板</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> pngquant [颜色数量] [参数] input.png</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   --skip-if-larger  仅保存转化后比原文件小的文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   --strip           去除可选的元数据</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   --ext=.png        设置压缩后图片名和原图片名一样</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   --force           覆盖原文件</span></span><br><span class="line">pngquant 256 --skip-if-larger --strip --ext=.png --force example.png</span><br></pre></td></tr></table></figure><p>当 pngqunt 压缩后，还可以通过 <a href="https://github.com/google/zopfli" target="_blank" rel="noopener">zopfli</a> 进一步无损压缩，但耗时较长，压缩比例也不高，我就没做这步操作。</p><!--zopfli 的原理使用 [DEFLATE](https://en.wikipedia.org/wiki/DEFLATE) 算法来实现无损压缩--><p><a href="https://pngmini.com/" target="_blank" rel="noopener">ImageAlpha</a> 是一个集成 <a href="https://pngquant.org/" target="_blank" rel="noopener">pngquant</a> 的 macOS 客户端，可以图形化调整图片显示颜色数量。</p><h3 id="2-4、压缩效果"><a href="#2-4、压缩效果" class="headerlink" title="2.4、压缩效果"></a>2.4、压缩效果</h3><table><thead><tr><th align="left">PNG-32 (465KB)</th><th align="left">256 colors (117KB)</th></tr></thead><tbody><tr><td align="left"><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-08-04-073500.png" alt="Xnip2020-08-02_20-55-07"></td><td align="left"><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-08-04-073506.png" alt="image-20200802205551304"></td></tr></tbody></table><p>压缩效果：74.8%</p><h3 id="2-5、自动压缩"><a href="#2-5、自动压缩" class="headerlink" title="2.5、自动压缩"></a>2.5、自动压缩</h3><p>现在，只有在本地执行一个命令，就能将图片压缩了。可以将命令作为一个脚本，交给工作流来自动执行，工作流可以选择 Alfred 工作流（<a href="https://www.alfredapp.com/workflows/" target="_blank" rel="noopener">Workflow</a>）、系统自带的 <a href="https://support.apple.com/en-au/guide/automator/welcome/mac" target="_blank" rel="noopener">Automator</a> 和专业工作流软件 <a href="https://www.noodlesoft.com/" target="_blank" rel="noopener">Hazel（</a>试用结束后软件收费）。Alfred 工作流需要关键字或快捷键触发，不符合我们自动压缩的 feelstyle，pass。下面分别演示如何使用 Hazel 和 Automator。 </p><p>Hazel 设置工作流：</p><ol><li>添加指定文件夹，设置触发条件，条件为对文件夹中最近一分钟新增的 PNG 文件执行脚本</li><li>设置脚本，脚本为压缩图片，并复制压缩后的图片到剪贴板</li><li>通知压缩完成</li></ol><p>Automator 设置工作流：</p><ol><li>添加 Folder Action，选择指定文件夹，添加 Run  Shell Script</li><li>设置脚本，将新加入图片作为参数，遍历执行脚本</li><li>没有通知功能</li></ol><p>设置完成后，我们使用截图工具（如： <a href="https://xnipapp.com/" target="_blank" rel="noopener">Xnip</a>）将截图保存到指定文件夹时，将会触发工作流，完成自动压缩。</p><table><thead><tr><th align="center">Hazel</th><th align="center">Automator</th></tr></thead><tbody><tr><td align="center"><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-08-07-092800.png" alt="image-20200807172759510"></td><td align="center"><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-08-07-102228.png" alt="image-20200807182227731"></td></tr><tr><td align="center"><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-08-04-073544.png" alt="image-20200803133233959"></td><td align="center"><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-08-07-135926.png" alt="image-20200807215926183"></td></tr><tr><td align="center"><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-08-04-073539.png" alt="image-20200802211111073"></td><td align="center"></td></tr></tbody></table><!--可以选择开源免费的 [fswatch](https://github.com/emcrisostomo/fswatch) 把.--><ul><li>使用 Automator，需在 Security &amp; Privay（安全与隐私）-&gt; Accessibility（辅助功能）里面开启权限。</li></ul><p>脚本：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pngquant 256 --skip-if-larger --strip --ext=.png --force "$1"</span><br><span class="line">osascript -e "set the clipboard to (read (POSIX file \"$(perl -e "print glob('$1')")\") as &#123;«class PNGf»&#125;)"</span><br></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">The compressed image `<span class="built_in">file</span>` has been copied <span class="keyword">to</span> <span class="built_in">the clipboard</span>.</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for f in "$@"</span><br><span class="line">do</span><br><span class="line">/usr/local/bin/pngquant 256 --skip-if-larger --strip --ext=.png --force "$f"</span><br><span class="line">osascript -e "set the clipboard to (read (POSIX file \"$(perl -e "print glob('$f')")\") as &#123;«class PNGf»&#125;)"</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>ps：Hazel 官方 UI 真心好看。<code>/usr/local/bin/pngquan</code> 与 <code>pnguant</code> 作用一样。</p><!--试用期过了我还是老老实实切换回系统自带的 Automator 吧。--><!--复制到剪贴板--><!--你可能注意到了 `cat "$1" | ./impbcopy -` 这行命令，这是一个从命令行复制图片到剪贴板的命令，由于 Hazel  不提供复制到剪贴板功能（反正我没找到），网上很多办法也不好使，找到一个小哥用 objective-c 写的[复制图片代码](http://www.alecjacobson.com/weblog/?p=3816)，挺好使。--><!--在保存截屏图片的文件夹中，新建文件 `impbcopy.m`，复制代码到 `impbcopy.m`，保存--><!--编译文件，你会看到生成了两个文件，`impbcopy` 和 `impbcopy.dSYM`，命令行执行将用到 `impbcopy`--> <h2 id="三、像素与分辨率"><a href="#三、像素与分辨率" class="headerlink" title="三、像素与分辨率"></a>三、像素与分辨率</h2><!--**像素**--><p>上面一直说像素，所以深入了解一下。</p><p><a href="https://en.wikipedia.org/wiki/Pixel" target="_blank" rel="noopener">像素</a>（Pixel，简写 px）分为物理像素和图片像素。</p><p><strong>物理像素</strong>是物理设备上显示颜色的物理点。物理设备如电脑、手机、电视等。</p><ul><li>以 <a href="https://support.apple.com/kb/SP754?locale=en_AU" target="_blank" rel="noopener">MacBook Pro 2017 13.3-inch</a>（后面简称 MacBook Pro）为例，屏幕尺寸是 13.3 英寸，即屏幕斜对角长为 13.3 英寸（1 英寸 = 2.54 cm）。（斜对角长约 34.0 cm，长约 28.8 cm，宽约 18.0 cm），像素个数为  2560 × 1600，所以每个像素点的面积约为 0.01125 cm × 0.01125 cm。</li><li><a href="https://www.apple.com/iphone-xr/specs/" target="_blank" rel="noopener">iPhone XR</a>，屏幕尺寸为 6.06-inch。（斜对角长约 15.4 cm，长约 14 cm，宽约 6.5 cm），像素个数为：1792 × 828，所以每个像素点的面积约为 0.00785cm × 0.00785 cm。</li></ul><p>我们可以看出，MacBook Rro 和 iPhone XR 屏幕的像素点为正方形。</p><p><strong>图片像素</strong>是图片中最小的单位。同样大小的照片，包含的像素可能不同。小米 10 有一个颗 1 亿像素的摄像头，如果全输出，拍出来的照片，包含像素个数为 12032 × 9024 ，乘积结果为 1.08 亿。iPhone XR 是 1200 万像素，照片像素为 3024  ×  4032。摄像头一般说多少多少像素，对于屏幕，我们一般称分辨率。</p><!--**分辨率 **--><p><a href="https://en.wikipedia.org/wiki/Dispute_resolution" target="_blank" rel="noopener">分辨率</a>，也叫显示分辨率（Display Resolution），分辨率指像素的总和，比如我们说 MacBook Pro 屏幕的分辨率是  2560 × 1600 px。分辨率和屏幕大小尺寸没有关系，MacBook Pro 的分辨率是  2560 × 1600 px，一台 75 英寸的 <a href="https://www.mi.com/mitv5/75/specs" target="_blank" rel="noopener">小米电视 5</a> 的分辨率也才 3840 × 2160 px。小米电视 5 自称是 <a href="https://en.wikipedia.org/wiki/4K_resolution" target="_blank" rel="noopener">4K</a>，其实只是接近 4K，4K 的标准是横向像素达到 4000。衡量屏幕显示的是像素密度。</p><!--**像素密度**--><p><a href="https://en.wikipedia.org/wiki/Pixel_density" target="_blank" rel="noopener">像素密度</a> ，英语为 Pixel Density，也叫 Pixels Per Inch（PPI），即单位英寸像素的多少（个数）。计算公式为 ppi = 像素/英寸。</p><ul><li>以 MacBook Pro 2017 13.3-inch 为例，ppi = √(2560^2 × 1600^2) / 13.3 ≈ 227，即斜对角每英寸有 227 个像素</li><li>以 iPhone XR 为例，ppi = √(1792^2 × 828^2) / 6.06 ≈ 326</li><li>以 <a href="https://www.apple.com/iphone-11-pro/specs/" target="_blank" rel="noopener">iPhone 11 PRO</a> 为例，ppi = √(2436^ × 1125^) / 5.8 ≈ 458</li></ul><p>对于屏幕来说，ppi 越高，显示就越清晰，就越不容易看见颗粒感。</p><h3 id="3-1、像素的内存大小"><a href="#3-1、像素的内存大小" class="headerlink" title="3.1、像素的内存大小"></a>3.1、像素的内存大小</h3><p>上面那张截图占内存太小，找张占内存大一点的分析。</p><table><thead><tr><th>未压缩前</th><th>压缩后</th></tr></thead><tbody><tr><td><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-08-07-101445.png" alt="image-20200807181444442"></td><td><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-08-07-101336.png" alt="image-20200807181336766"></td></tr><tr><td><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-08-07-101537.png" alt="image-20200807181537056"></td><td><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-08-07-101616.png" alt="image-20200807181616576"></td></tr></tbody></table><ul><li>1KB = 1000 Bytes（字节）（十进制换算）；1KB = 1024 Bytes（二进制换算）</li></ul><p>这张全屏壁纸截图未压缩前大小为 2880 × 1800，所以有 5,184,000 个像素点，图片内存为 8.7 MB（8,738,825 bytes），有 69,910,600 位（bit），每个像素点约占 13.5 位。</p><p>压缩后分辨率不变，内存为 2.8 MB，为 23,488,102 位，每个像素点约占 4.3 位。</p><p>可以看出，截屏图片的像素没有达到默认的 32 位，我认为是图片颜色没有特别丰富，所以用不了 32 位表示。测试截颜色单一的屏幕，所需要的内存更低。个人认为这跟 UTF-8 类似，像素点的大小为可变，不常见的颜色更占内存。</p><p>值得注意的是，虽然 MacBook Pro 的屏幕分辨率是 2560 × 1600 px，但系统默认做了一定缩放，缩放为了 2880  ×  1800 px，而屏幕显示为 1440  ×  900 pt（point，1pt = 2px），即将 4 个像素压缩为 1 个像素显示，来实现更好的显示效果，这被称为 Retain 技术。所以在 macOS 中，浏览器前端样式 1 px 对应 1 pt。</p><h2 id="四、PNG-vs-JPEG-JPG"><a href="#四、PNG-vs-JPEG-JPG" class="headerlink" title="四、PNG vs JPEG(JPG)"></a>四、PNG vs JPEG(JPG)</h2><p><a href="https://en.wikipedia.org/wiki/Portable_Network_Graphics" target="_blank" rel="noopener">PNG</a>：<strong>P</strong>ortable <strong>N</strong>etwork <strong>G</strong>raphics，便携式网络图形。是一种支持<a href="https://en.wikipedia.org/wiki/Lossless_compression" target="_blank" rel="noopener">无损压缩</a>的<a href="https://zh.wikipedia.org/wiki/位图" target="_blank" rel="noopener">位图</a>图形格式。PNG 更适合保存截屏。</p><p>无损压缩一方面指压缩后对图片质量没有损失，另一方面指压缩后还可以还原（如压缩包解压）。PNG 图片可以无损压缩，但也可以有损压缩，就像前面的 pngquant 一样。</p><p><a href="https://en.wikipedia.org/wiki/JPEG" target="_blank" rel="noopener">JPEG</a>：<strong>J</strong>oint <strong>P</strong>hotographic <strong>E</strong>xperts <strong>G</strong>roup，联合图像专家小组。一种用于<a href="https://en.wikipedia.org/wiki/Lossy_compression" target="_blank" rel="noopener">有损压缩</a>的图片格式。更适合保存照片。</p><!--对于色彩和阴影复杂的图像是一个很好的选择。--><p>有损压缩的原理一般是变换数据编码方法，变换编码方法为用不精确逼近和部分数据丢弃来表示内容。有损压缩后不能还原。</p><ul><li>JPG：JPG 是  JPEG 图片的一种文件后缀，可以认为两者没有区别。ps：一个号称可以无损压缩 JPEG 图片的网站：<a href="https://www.picdiet.com/zh-cn" target="_blank" rel="noopener">picdiect</a></li></ul><!--修改截屏图片类型：defaults write com.apple.screencapture type PNG--><h2 id="五、结语"><a href="#五、结语" class="headerlink" title="五、结语"></a>五、结语</h2><p>关于图片大小的错觉，来自一次我公众号不能显示文章图片的经历，那张图片是我用 iPhone 拍摄的图片，有几 MB，这造成了我认为苹果设备图片会很大的错觉，所以认为 Clipboard History 显示截屏图片大小就是正确的。我还通过将图片上传到阿里云后，在线打开链接，复制图片到剪贴板，再通过 Clipboard History 来查看图片大小来验证图片是不是真的这么大，这种错误的方式进一步加深了我认为图片确实很大的错觉。汗颜。</p><p>友情提示：使用阿里云对象储存作为图床时，建议设置<a href="https://help.aliyun.com/document_detail/31869.html" target="_blank" rel="noopener">防盗链</a>，避免别人使用你图片链接造成你图床费用大幅增加的问题。</p><p>这篇文章实现自动压缩截屏用时不多，但为了正确表述出「像素与分辨率」却用时不少，而关于为什么 PNG 适合保存截图，JPEG 适合保存照片，也还没彻底搞懂，后面有机会再深入研究一下。</p><p>最后，如果你有更好的方法实现截屏压缩，请一定留言告诉我。</p><h2 id="六、延伸阅读"><a href="#六、延伸阅读" class="headerlink" title="六、延伸阅读"></a>六、延伸阅读</h2><ul><li><a href="https://about.gitlab.com/blog/2020/01/30/simple-trick-for-smaller-screenshots/" target="_blank" rel="noopener">One simple trick to make your screenshots 80% smaller</a></li><li><a href="https://undsgn.com/jpg-vs-png/" target="_blank" rel="noopener">JPG vs PNG: Which to Choose for Your Website?</a></li><li><a href="http://screen-size.info/" target="_blank" rel="noopener">Screen Size Calculator</a></li><li><a href="https://www.piliapp.com/actual-size/cm-ruler/" target="_blank" rel="noopener">What is my monitor size?</a></li></ul>]]></content:encoded>
      
      <comments>https://depp.wang/2020/08/07/how-to-automatically-compress-screenshot-size-in-macos/#disqus_thread</comments>
    </item>
    
    <item>
      <title>一道算法题：水流过几个格子</title>
      <link>https://depp.wang/2020/07/01/how-many-the-grids-does-water-flow-through/</link>
      <guid>https://depp.wang/2020/07/01/how-many-the-grids-does-water-flow-through/</guid>
      <pubDate>Wed, 01 Jul 2020 20:48:37 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://depp.wang&quot;&gt;DeppWang&lt;/a&gt;、&lt;a href=&quot;https://depp.wang/2020/07/01/how-many-the-grids-does-water-flow-through&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目来源&quot;&gt;&lt;a href=&quot;#题目来源&quot; class=&quot;headerlink&quot; title=&quot;题目来源&quot;&gt;&lt;/a&gt;题目来源&lt;/h2&gt;&lt;p&gt;一道做智能的对话机器人公司的算法测试题&lt;/p&gt;
&lt;!--[爱因互动](https://einplus.cn/) Python 职位测试题--&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>作者：<a href="https://depp.wang">DeppWang</a>、<a href="https://depp.wang/2020/07/01/how-many-the-grids-does-water-flow-through">原文地址</a></p></blockquote><h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p>一道做智能的对话机器人公司的算法测试题</p><!--[爱因互动](https://einplus.cn/) Python 职位测试题--><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个矩形的水槽被分为了 N * M 个格子，每个格子内的高度都不同，每个格子和直接相邻的格子相通（对角相邻的不相通）。从最左上角的格子注入水，水会向相通的较低的或同样高的格子流动，但不会流向较高的格子。请写程序计算水一共会流经多少个格子？</p><p> 例如如果格子高度如下分布：</p><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">3 | 5 | 1</span><br><span class="line">---------</span><br><span class="line">2 | 1 | 5  </span><br><span class="line">---------</span><br><span class="line">4 | 2 | 1</span><br></pre></td></tr></table></figure><p>则水会从左上角流经 3、2、1 三个格子，答案为 3。</p><h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>需要利用广度优先搜索（队列）的思路</li><li>将元素位置作为队列元素，而不使用元素值作为队列元素</li><li>将 [0, 0] 加入队列，依次遍历队列，将四周小于当前数值的元素加入队列，直到遍历完</li></ul><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">3 | 5 | 1</span><br><span class="line">---------</span><br><span class="line">2 | 1 | 5  </span><br><span class="line">---------</span><br><span class="line">4 | 2 | 1</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">   <span class="number">3</span></span><br><span class="line">[[<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">   <span class="number">3</span>     <span class="number">2</span></span><br><span class="line">[[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">   ↑     </span><br><span class="line">   <span class="number">3</span>     <span class="number">2</span>     <span class="number">1</span></span><br><span class="line">[[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">         ↑</span><br></pre></td></tr></table></figure><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">5 | 5 | 1</span><br><span class="line">---------</span><br><span class="line">2 | 1 | 5  </span><br><span class="line">---------</span><br><span class="line">4 | 2 | 1</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">   <span class="number">5</span></span><br><span class="line">[[<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">   </span><br><span class="line">   <span class="number">5</span>     <span class="number">5</span>    <span class="number">2</span></span><br><span class="line">[[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">   ↑</span><br><span class="line">   <span class="number">5</span>     <span class="number">5</span>     <span class="number">2</span>     <span class="number">1</span>     <span class="number">1</span></span><br><span class="line">[[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">         ↑</span><br><span class="line">   <span class="number">5</span>     <span class="number">5</span>     <span class="number">2</span>     <span class="number">1</span>     <span class="number">1</span>     </span><br><span class="line">[[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">1</span>]]  [<span class="number">1</span>,<span class="number">1</span>] 已存在，跳过</span><br><span class="line">               ↑</span><br><span class="line">   <span class="number">5</span>     <span class="number">5</span>     <span class="number">2</span>     <span class="number">1</span>     <span class="number">1</span>     </span><br><span class="line">[[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">                     ↑</span><br><span class="line">   <span class="number">5</span>     <span class="number">5</span>     <span class="number">2</span>     <span class="number">1</span>     <span class="number">1</span>     </span><br><span class="line">[[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">                           ↑</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(N^2)。N 为格子数量，因需要判断元素在队列中是否已经存在，所以需要跟其他元素比较</li><li>空间复杂度：O(N)。N 为格子数量，最长需要长度为 N 的额外队列</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printGridNumber</span><span class="params">(self, height_arr)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">judge_contain</span><span class="params">(key, queue)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> queue:</span><br><span class="line">                <span class="keyword">if</span> x == key:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(queue, i, j)</span>:</span></span><br><span class="line">            xlen = len(height_arr)</span><br><span class="line">            ylen = len(height_arr[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">if</span> i - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> height_arr[i - <span class="number">1</span>][j] &lt;= height_arr[i][j] <span class="keyword">and</span> <span class="keyword">not</span> judge_contain([i - <span class="number">1</span>, j], queue):</span><br><span class="line">                queue.append([i - <span class="number">1</span>, j])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> j - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> height_arr[i][j - <span class="number">1</span>] &lt;= height_arr[i][j] <span class="keyword">and</span> <span class="keyword">not</span> judge_contain([i, j - <span class="number">1</span>], queue):</span><br><span class="line">                queue.append([i, j - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> i + <span class="number">1</span> &lt; xlen <span class="keyword">and</span> height_arr[i + <span class="number">1</span>][j] &lt;= height_arr[i][j] <span class="keyword">and</span> <span class="keyword">not</span> judge_contain([i + <span class="number">1</span>, j], queue):</span><br><span class="line">                queue.append([i + <span class="number">1</span>, j])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> j + <span class="number">1</span> &lt; ylen <span class="keyword">and</span> height_arr[i][j + <span class="number">1</span>] &lt;= height_arr[i][j] <span class="keyword">and</span> <span class="keyword">not</span> judge_contain([i, j + <span class="number">1</span>], queue):</span><br><span class="line">                queue.append([i, j + <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        queue = [[<span class="number">0</span>, <span class="number">0</span>]]</span><br><span class="line">        append(queue, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> queue:</span><br><span class="line">            append(queue, x[<span class="number">0</span>], x[<span class="number">1</span>])</span><br><span class="line">            <span class="comment"># print(queue)</span></span><br><span class="line">        <span class="keyword">return</span> len(queue)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    solution = Solution()</span><br><span class="line">    height_arr = [[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]]</span><br><span class="line">    print(solution.printGridNumber(height_arr))</span><br></pre></td></tr></table></figure><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">[[<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>], [<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>]]  # input</span><br><span class="line"><span class="number">3</span>                                  # expect value</span><br><span class="line"></span><br><span class="line">[[<span class="number">5</span>, <span class="number">5</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>], [<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>]]</span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line">[[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]]</span><br><span class="line"><span class="number">9</span></span><br><span class="line"></span><br><span class="line">[[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]]</span><br><span class="line"><span class="number">8</span></span><br><span class="line"></span><br><span class="line">[[<span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>], [<span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>], [<span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]]</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><h2 id="错误思路"><a href="#错误思路" class="headerlink" title="错误思路"></a>错误思路</h2><ul><li>直接遍历所有元素，如果当前值小于左上角、小于周围的值、周围的值小于左上角，则将结果加 1</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printGridNumber</span><span class="params">(self, height_arr)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">judge</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            left_top_height = height_arr[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            xlen = len(height_arr)</span><br><span class="line">            ylen = len(height_arr[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">if</span> i - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> left_top_height &gt;= height_arr[i - <span class="number">1</span>][j] &gt;= height_arr[i][j]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> j - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> left_top_height &gt;= height_arr[i][j - <span class="number">1</span>] &gt;= height_arr[i][j]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> i + <span class="number">1</span> &lt; xlen <span class="keyword">and</span> left_top_height &gt;= height_arr[i + <span class="number">1</span>][j] &gt;= height_arr[i][j]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> j + <span class="number">1</span> &lt; ylen <span class="keyword">and</span> left_top_height &gt;= height_arr[i][j + <span class="number">1</span>] &gt;= height_arr[i][j]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(height_arr) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> len(height_arr[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        left_top_height = height_arr[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># print(left_top_height)</span></span><br><span class="line">        number = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(height_arr)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(height_arr[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> j == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> height_arr[i][j] &lt;= left_top_height <span class="keyword">and</span> judge(i, j):</span><br><span class="line">                    number += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> number</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    solution = Solution()</span><br><span class="line">    height_arr = [[<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]]</span><br><span class="line">    print(solution.printGridNumber(height_arr))</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://depp.wang/2020/07/01/how-many-the-grids-does-water-flow-through/#disqus_thread</comments>
    </item>
    
    <item>
      <title>一个发布文章到博客园的 Python 脚本</title>
      <link>https://depp.wang/2020/06/20/a-python-script-to-edit-and-add-cnblogs-posts/</link>
      <guid>https://depp.wang/2020/06/20/a-python-script-to-edit-and-add-cnblogs-posts/</guid>
      <pubDate>Sat, 20 Jun 2020 20:48:37 GMT</pubDate>
      <description>
      
        &lt;!--一个自动发布、更新本地文章到博客园的 Python 脚本--&gt;

&lt;!--一个可自动发布本地文章到博客园及更新博客园文章的 Python 脚本--&gt;

&lt;!--一个可编辑与新增博客园文章的 Python 脚本--&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://depp.wang/2020/06/20/a-python-script-to-edit-and-add-cnblogs-posts&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我的&lt;a href=&quot;https//depp.wang&quot;&gt;个人独立博客&lt;/a&gt;是基于 Hexo 搭建的，因为小站，Google 搜索引擎收录文章比较慢，还搜不到&lt;/p&gt;
&lt;p&gt;为了解决这个问题，希望把文章也顺便发布到博客平台&lt;a href=&quot;https://www.cnblogs.com/deppwang&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;博客园&lt;/a&gt;上。但不想每次手动复制粘贴，打算利用脚本实现，希望除了发布，并且还能更新文章。原来打算&lt;a href=&quot;https://depp.wang/2020/06/11/how-to-find-the-api-of-a-website-eg-note-youdao-com/&quot;&gt;找到博客园接口&lt;/a&gt;，模拟操作接口实现。搜索发现博客园提供了 &lt;a href=&quot;https://rpc.cnblogs.com/metaweblog/deppwang&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MetaWeblog 接口&lt;/a&gt;，所以利用接口，开发了这个脚本。&lt;a href=&quot;https://github.com/DeppWang/cnblogs-post&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源码地址&lt;/a&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<!--一个自动发布、更新本地文章到博客园的 Python 脚本--><!--一个可自动发布本地文章到博客园及更新博客园文章的 Python 脚本--><!--一个可编辑与新增博客园文章的 Python 脚本--><blockquote><p><a href="https://depp.wang/2020/06/20/a-python-script-to-edit-and-add-cnblogs-posts">原文地址</a></p></blockquote><p>我的<a href="https//depp.wang">个人独立博客</a>是基于 Hexo 搭建的，因为小站，Google 搜索引擎收录文章比较慢，还搜不到</p><p>为了解决这个问题，希望把文章也顺便发布到博客平台<a href="https://www.cnblogs.com/deppwang" target="_blank" rel="noopener">博客园</a>上。但不想每次手动复制粘贴，打算利用脚本实现，希望除了发布，并且还能更新文章。原来打算<a href="https://depp.wang/2020/06/11/how-to-find-the-api-of-a-website-eg-note-youdao-com/">找到博客园接口</a>，模拟操作接口实现。搜索发现博客园提供了 <a href="https://rpc.cnblogs.com/metaweblog/deppwang" target="_blank" rel="noopener">MetaWeblog 接口</a>，所以利用接口，开发了这个脚本。<a href="https://github.com/DeppWang/cnblogs-post" target="_blank" rel="noopener">源码地址</a></p><a id="more"></a><h2 id="如何使用这个脚本"><a href="#如何使用这个脚本" class="headerlink" title="如何使用这个脚本"></a>如何使用这个脚本</h2><p>博客园 -&gt; 管理 -&gt; 设置 -&gt; 允许 MetaWeblog 博客客户端访问</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-06-20-105444.png" alt="image-20200620185444059"></p><p>在 <code>cnblogs-post.py</code> 中配置：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">config = &#123;</span><br><span class="line">    <span class="string">'url'</span>: <span class="string">'https://rpc.cnblogs.com/metaweblog/deppwang'</span>,               <span class="comment"># 你的 MetaWeblog 访问地址</span></span><br><span class="line">    <span class="string">'username'</span>: <span class="string">'DeppWangXQ'</span>,                                           <span class="comment"># 你的登录用户名，可能跟上面的不一致</span></span><br><span class="line">    <span class="string">'password'</span>: <span class="string">'12345678'</span>                                              <span class="comment"># 你的登录密码</span></span><br><span class="line">    <span class="string">'local_post_path'</span>: <span class="string">'/Users/yanjie/GitHub/HexoBlog/source/_posts/'</span>   <span class="comment"># 你的本地博文路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在文章开头，添加文章信息块，至少需要包括 title 和 tags，格式如下：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 一个可编辑与新增博客园文章的 Python 脚本</span><br><span class="line">english_title: a-python-script-to-edit-and-add-cnblogs-posts</span><br><span class="line">date: 2020-06-20 20:48:37</span><br><span class="line">tags: 博客园</span><br><span class="line">categories: Tools</span><br><span class="line">---</span><br><span class="line">正文开始 ...</span><br></pre></td></tr></table></figure><p>脚本根据文章名称来判断是否已经发布，如果已经发布，更新，否则新增。默认只操作最近修改文章，但也可以指定文章数量（count）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python3 cnblogs-post.py [count]   <span class="comment"># macOS/Linux</span></span><br><span class="line">python cnblogs-post.py [count]    <span class="comment"># Windows</span></span><br></pre></td></tr></table></figure><p>删除最近发布文章</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python3 cnblogs-post.py delete    <span class="comment"># macOS/Linux</span></span><br><span class="line">python cnblogs-post.py delete     <span class="comment"># Windows</span></span><br></pre></td></tr></table></figure><h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xmlrpc.client</span><br><span class="line"><span class="keyword">import</span> ssl</span><br><span class="line"></span><br><span class="line">ssl._create_default_https_context = ssl._create_unverified_context</span><br><span class="line"></span><br><span class="line">config = &#123;</span><br><span class="line">    <span class="string">'url'</span>: <span class="string">'https://rpc.cnblogs.com/metaweblog/deppwang'</span>,</span><br><span class="line">    <span class="string">'username'</span>: <span class="string">''</span>, </span><br><span class="line">    <span class="string">'password'</span>: <span class="string">''</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MetaWeblog</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, url, username, password)</span>:</span></span><br><span class="line">        self.url, self.username, self.password = url, username, password</span><br><span class="line">        self.proxy = xmlrpc.client.ServerProxy(self.url)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRecentPosts</span><span class="params">(self, count)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.proxy.metaWeblog.getRecentPosts(<span class="string">''</span>, self.username, self.password, count)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    metaWeblog = MetaWeblog(config[<span class="string">'url'</span>], config[<span class="string">'username'</span>], config[<span class="string">'password'</span>])</span><br><span class="line">    posts = metaWeblog.getRecentPosts(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><h2 id="一文多发"><a href="#一文多发" class="headerlink" title="一文多发"></a>一文多发</h2><p>脚本只实现发布、更新文章到博客园。如果想实现一文多发，可使用 OpenWrit，或自己开发相应脚本，方法为<a href="https://depp.wang/2020/06/11/how-to-find-the-api-of-a-website-eg-note-youdao-com/">找到相应接口</a>，使用模拟操作接口的方式实现</p><p>我个人没有一文多发的需求，感兴趣的同学可以做做</p><!--一文多发更多是面向自媒体工作者，他们需要图形化页面，统计数据等功能。--><!--ArtiPub 使用 [Puppeteer](https://github.com/puppeteer/puppeteer)，太重量级了，稳定性也比较差。一文多发的目的是扩散，最重要是方便、快速（命令行运行即可），除了发布，最好还有更新功能，像阅读统计之类的功能其实可有可无。--><!--OpenWrit 应该也就是使用模拟操作接口的方式实现的，其实我们自己可以找到相应接口，写脚本实现，找接口可参考[这篇文章](https://depp.wang/2020/06/11/how-to-find-the-api-of-a-website-eg-note-youdao-com/)--><!--我个人没有一文多发的需求，感兴趣的同学可以做做--><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://extendswind.top/posts/technical/python3_publish_blog/" target="_blank" rel="noopener">https://extendswind.top/posts/technical/python3_publish_blog/</a></li><li><a href="https://github.com/Whistle1988/auto_post_article" target="_blank" rel="noopener">https://github.com/Whistle1988/auto_post_article</a></li><li><a href="https://rpc.cnblogs.com/metaweblog/deppwang" target="_blank" rel="noopener">https://rpc.cnblogs.com/metaweblog/deppwang</a></li><li><a href="http://samwirch.com/blog/recursively-find-the-last-modified-file-in-python" target="_blank" rel="noopener">http://samwirch.com/blog/recursively-find-the-last-modified-file-in-python</a></li><li><a href="https://github.com/executablebooks/markdown-it-py" target="_blank" rel="noopener">https://github.com/executablebooks/markdown-it-py</a></li></ul>]]></content:encoded>
      
      <comments>https://depp.wang/2020/06/20/a-python-script-to-edit-and-add-cnblogs-posts/#disqus_thread</comments>
    </item>
    
    <item>
      <title>快速排序的几种实现方式</title>
      <link>https://depp.wang/2020/06/18/several-implementations-of-quick-sort/</link>
      <guid>https://depp.wang/2020/06/18/several-implementations-of-quick-sort/</guid>
      <pubDate>Thu, 18 Jun 2020 20:48:37 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://depp.wang/2020/06/18/several-implementations-of-quick-sort/&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;快速排序（quick sort）的特点是分块排序，也叫划分交换排序（partition-exchange sort）&lt;/p&gt;
&lt;p&gt;代码实现方式可以有这么几种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;拼接结果&lt;/li&gt;
&lt;li&gt;左右相互交换&lt;/li&gt;
&lt;li&gt;快慢指针&lt;/li&gt;
&lt;/ol&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p><a href="https://depp.wang/2020/06/18/several-implementations-of-quick-sort/">原文地址</a></p></blockquote><p>快速排序（quick sort）的特点是分块排序，也叫划分交换排序（partition-exchange sort）</p><p>代码实现方式可以有这么几种：</p><ol><li>拼接结果</li><li>左右相互交换</li><li>快慢指针</li></ol><a id="more"></a><h2 id="1-拼接结果"><a href="#1-拼接结果" class="headerlink" title="1. 拼接结果"></a>1. 拼接结果</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="comment"># 当为 0 个或 1 个时，肯定有序，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 选择第一位作为中位数</span></span><br><span class="line">            mid = nums[<span class="number">0</span>]</span><br><span class="line">            less = [num <span class="keyword">for</span> num <span class="keyword">in</span> nums[<span class="number">1</span>:] <span class="keyword">if</span> num &lt;= mid]</span><br><span class="line">            greater = [num <span class="keyword">for</span> num <span class="keyword">in</span> nums[<span class="number">1</span>:] <span class="keyword">if</span> num &gt; mid]</span><br><span class="line">            <span class="keyword">return</span> self.quicksort(less) + [mid] + self.quicksort(greater)</span><br></pre></td></tr></table></figure><p>这种方式最直观，最好理解，但效率不高。为了找出大于和小于中位数的元素，循环遍历了 2 次</p><p>做一点小小的修改，改为一次遍历：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mid = nums[<span class="number">0</span>]</span><br><span class="line">            less, greater = self.partition(nums, mid)[<span class="number">0</span>], self.partition(nums, mid)[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span> self.quicksort(less) + [mid] + self.quicksort(greater)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, nums, mid)</span>:</span></span><br><span class="line">        less, greater = [], []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> num &lt;= mid:</span><br><span class="line">                less.append(num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                greater.append(num)</span><br><span class="line">        <span class="keyword">return</span> less, greater</span><br></pre></td></tr></table></figure><p>优化后，运行时间降低了，但空间使用还很高，每次递归都额外需要 2 个平均长度为  &frac14; n 的数组</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">2</span> ... + n<span class="number">-1</span> + n = ((n + <span class="number">1</span>) * n ) / <span class="number">2</span></span><br><span class="line">平均值 = ((n + <span class="number">1</span>) * n ) / <span class="number">2</span> / n = (n + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">两个数组平分平均值： (n + <span class="number">1</span>) / <span class="number">2</span> / <span class="number">2</span> ≈ <span class="number">1</span>/<span class="number">4</span> n</span><br></pre></td></tr></table></figure><h2 id="2-左右相互交换"><a href="#2-左右相互交换" class="headerlink" title="2. 左右相互交换"></a>2. 左右相互交换</h2><p>其实可以不使用额外空间，直接操作原数组。选择一个基准值，将小于它和大于它的元素相互交换。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        self.quick_sort(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(self, nums, start, end)</span>:</span></span><br><span class="line">        <span class="comment"># end - start &lt; 1</span></span><br><span class="line">        <span class="keyword">if</span> start &gt;= end:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 每次使用最后一个数作为基准值</span></span><br><span class="line">        pivot_index = end</span><br><span class="line">        pivot = nums[pivot_index]</span><br><span class="line">        </span><br><span class="line">        left, right = start, end - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="comment"># 左边跳过所有小于基准值的元素</span></span><br><span class="line">            <span class="keyword">while</span> nums[left] &lt;= pivot <span class="keyword">and</span> left &lt; right:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 右边跳过所有大于基准值的元素</span></span><br><span class="line">            <span class="keyword">while</span> nums[right] &gt; pivot <span class="keyword">and</span> left &lt; right:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 交换</span></span><br><span class="line">            nums[left], nums[right] = nums[right], nums[left]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 此时左右指针重合（left == right），其指向元素可能大于基准值</span></span><br><span class="line">        <span class="keyword">if</span> nums[left] &gt; pivot:</span><br><span class="line">            nums[left], nums[pivot_index] = nums[pivot_index], nums[left]</span><br><span class="line">        <span class="comment"># 使 left 始终作为较大区间的第 1 个元素</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        self.quick_sort(nums, start, left - <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># pivot 不一定在中间，所以包含 left</span></span><br><span class="line">        self.quick_sort(nums, left, end)</span><br></pre></td></tr></table></figure><p>使用此种方式，最好要将开头（或末尾）的元素设为基准值。如果使用中间元素，也最好先交换到开头（或末尾），否则将考虑大量场景。</p><p>排序过程：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">[<span class="number">6</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">1</span>  <span class="number">8</span>  <span class="number">7</span>  <span class="number">2</span>  <span class="number">4</span>]</span><br><span class="line"> ↑                 ↑  ^</span><br><span class="line">[<span class="number">2</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">1</span>  <span class="number">8</span>  <span class="number">7</span>  <span class="number">6</span>  <span class="number">4</span>]</span><br><span class="line">    ↑     ↑           ^</span><br><span class="line">[<span class="number">2</span>  <span class="number">1</span>  <span class="number">3</span>  <span class="number">5</span>  <span class="number">8</span>  <span class="number">7</span>  <span class="number">6</span>  <span class="number">4</span>]</span><br><span class="line">          ↑↑          ^</span><br><span class="line">[<span class="number">2</span>  <span class="number">1</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">8</span>  <span class="number">7</span>  <span class="number">6</span>  <span class="number">5</span>]</span><br><span class="line">          ^           </span><br><span class="line">[<span class="number">2</span>  <span class="number">1</span>  <span class="number">3</span>][<span class="number">4</span>  <span class="number">8</span>  <span class="number">7</span>  <span class="number">6</span>  <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>nums[left] &lt;= pivot 时：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">[<span class="number">6</span>  <span class="number">7</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">8</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">5</span>]</span><br><span class="line"> ↑                 ↑  ^</span><br><span class="line">[<span class="number">2</span>  <span class="number">7</span>  <span class="number">3</span>  <span class="number">1</span>  <span class="number">8</span>  <span class="number">1</span>  <span class="number">6</span>  <span class="number">5</span>]</span><br><span class="line">    ↑           ↑     ^</span><br><span class="line">[<span class="number">2</span>  <span class="number">1</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">8</span>  <span class="number">7</span>  <span class="number">6</span>  <span class="number">5</span>]</span><br><span class="line">          ↑↑          ^</span><br><span class="line">[<span class="number">2</span>  <span class="number">1</span>  <span class="number">3</span>  <span class="number">4</span>][<span class="number">8</span>  <span class="number">7</span>  <span class="number">6</span>  <span class="number">5</span>]</span><br></pre></td></tr></table></figure><h2 id="3-快慢指针"><a href="#3-快慢指针" class="headerlink" title="3. 快慢指针"></a>3. 快慢指针</h2><p>上面这种方式其实使用两个相向指针，也可以使用同向快慢指针实现元素交换。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">import</span> random</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(left, right)</span>:</span></span><br><span class="line">            <span class="comment"># right - left &lt; 1</span></span><br><span class="line">            <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 随机选择一个元素作为 pivot</span></span><br><span class="line">            pivot_index = random.randint(left, right)</span><br><span class="line">            pivot = nums[pivot_index]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 1. 将中位数与末尾数交换，便于操作</span></span><br><span class="line">            nums[pivot_index], nums[right] = nums[right], nums[pivot_index]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 2. 使用快慢指针，将所有小于中位数的元素移动到左边</span></span><br><span class="line">            store_index = left</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(left, right):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &lt;= pivot:</span><br><span class="line">                    nums[store_index], nums[i] = nums[i], nums[store_index]</span><br><span class="line">                    store_index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 3. store_index 位置元素肯定大于等于 pivot，所以交换</span></span><br><span class="line">            nums[right], nums[store_index] = nums[store_index], nums[right]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 因为 pivot 在中间，所以减 1</span></span><br><span class="line">            quick_sort(left, store_index - <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 因为 pivot 在中间，所以加 1</span></span><br><span class="line">            quick_sort(store_index + <span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line">        quick_sort(<span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>排序过程：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">[<span class="number">6</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">1</span>  <span class="number">8</span>  <span class="number">7</span>  <span class="number">2</span>  <span class="number">4</span>]</span><br><span class="line"> ↑↑                   ^</span><br><span class="line">[<span class="number">6</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">1</span>  <span class="number">8</span>  <span class="number">7</span>  <span class="number">2</span>  <span class="number">4</span>]</span><br><span class="line"> ↑     ↑              ^</span><br><span class="line">[<span class="number">3</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">1</span>  <span class="number">8</span>  <span class="number">7</span>  <span class="number">2</span>  <span class="number">4</span>]</span><br><span class="line">    ↑     ↑           ^</span><br><span class="line">[<span class="number">3</span>  <span class="number">1</span>  <span class="number">6</span>  <span class="number">5</span>  <span class="number">8</span>  <span class="number">7</span>  <span class="number">2</span>  <span class="number">4</span>]</span><br><span class="line">       ↑           ↑  ^</span><br><span class="line">[<span class="number">3</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">5</span>  <span class="number">8</span>  <span class="number">7</span>  <span class="number">6</span>  <span class="number">4</span>]</span><br><span class="line">          ↑           ^</span><br><span class="line">[<span class="number">3</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">4</span>  <span class="number">8</span>  <span class="number">7</span>  <span class="number">6</span>  <span class="number">5</span>]</span><br><span class="line">          ^     </span><br><span class="line">[<span class="number">3</span>  <span class="number">1</span>  <span class="number">2</span>][<span class="number">4</span>][<span class="number">8</span>  <span class="number">7</span>  <span class="number">6</span>  <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>随机选择可以增加每次选择的基准值为中位数的几率</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><h3 id="最坏时间复杂度"><a href="#最坏时间复杂度" class="headerlink" title="最坏时间复杂度"></a>最坏时间复杂度</h3><p>每次基准值都是最大 （或最小）值时，所需递归次数最多，有两种情况：</p><ol><li>数组有序时，每次使用最后 1 位（或第 1 位）作为基准值</li></ol><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span></span><br><span class="line">                      ^</span><br><span class="line"> <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span> [<span class="number">8</span>]</span><br><span class="line">                   ^</span><br><span class="line"> <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span> [<span class="number">7</span>]</span><br><span class="line">                ^</span><br><span class="line"> <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span> [<span class="number">6</span>]</span><br><span class="line">             ^  </span><br><span class="line"> <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span> [<span class="number">5</span>]</span><br><span class="line">          ^  </span><br><span class="line"> <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span> [<span class="number">4</span>]</span><br><span class="line">       ^  </span><br><span class="line"> <span class="number">1</span>  <span class="number">2</span> [<span class="number">3</span>]</span><br><span class="line">    ^ </span><br><span class="line"> <span class="number">1</span> [<span class="number">2</span>]</span><br><span class="line"> ^ </span><br><span class="line">[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><ol start="2"><li>随机选择时，每次选择到最大（或最小）的一位</li></ol><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"> <span class="number">6</span>  <span class="number">7</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">8</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">5</span></span><br><span class="line">             ^</span><br><span class="line"> <span class="number">6</span>  <span class="number">7</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">5</span> [<span class="number">8</span>]</span><br><span class="line">    ^         </span><br><span class="line"> <span class="number">6</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">5</span> [<span class="number">7</span>] <span class="number">8</span></span><br><span class="line"> ^ </span><br><span class="line"> <span class="number">3</span>  <span class="number">4</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">5</span> [<span class="number">6</span>] <span class="number">7</span>  <span class="number">8</span></span><br><span class="line">             ^ </span><br><span class="line"> <span class="number">3</span>  <span class="number">4</span>  <span class="number">1</span>  <span class="number">2</span> [<span class="number">5</span>] <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span></span><br><span class="line">    ^ </span><br><span class="line"> <span class="number">3</span>  <span class="number">1</span>  <span class="number">2</span> [<span class="number">4</span>] <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span></span><br><span class="line"> ^</span><br><span class="line"> <span class="number">1</span>  <span class="number">2</span> [<span class="number">3</span>] <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span></span><br><span class="line">    ^</span><br><span class="line"> <span class="number">1</span> [<span class="number">2</span>] <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span></span><br><span class="line"> ^</span><br><span class="line">[<span class="number">1</span>] <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span></span><br></pre></td></tr></table></figure><p>此时递归次数为 n + 1，平均每次排序  &frac12; n 个数。所以最坏时间复杂度：O(n^2)。</p><h3 id="最好时间复杂度"><a href="#最好时间复杂度" class="headerlink" title="最好时间复杂度"></a>最好时间复杂度</h3><p>如果每次选择中位数作为基准值，递归次数会减少么？其实不会减少，但递归中遍历的次数会减少。如果每层遍历看成 n 次的话，可以用下面的这个图表示：</p><!--[图片来自《算法图解》](https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-06-18-124518.png)--><p><figure>  <img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-06-18-124518.png" alt="图片来自《算法图解》">  <figcaption style="text-align: center">图片来自《算法图解》</figcaption></figure></p><p>所以最好时间复杂度为：O(n * log n)</p><h3 id="平均时间复杂度"><a href="#平均时间复杂度" class="headerlink" title="平均时间复杂度"></a>平均时间复杂度</h3><p>最坏时间复杂度的情况很少见，所以平均时间复杂度就是最好时间复杂度 O(n * log n)</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>每次递归均会使用额外空间，所以空间复杂度跟递归次数有关。</p><p>最坏时间复杂度时，最坏空间复杂度也为 O(n)。最好时间复杂度时时，虽然递归没有减少，但当只有 1 个或 0 个元素时，没有使用额外空间，直接返回，所以最好空间复杂度为 O(log n)。平均时间复杂度也为 O(log n)。</p><p>第 1 种实现因为使用额外数组，最坏空间复杂度为 O(n^2)，最好空间复杂度为 O(n * log n)，</p><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># nums = [3, 2, 1, 5, 6, 4]</span></span><br><span class="line">    <span class="comment"># 针对第 1 种</span></span><br><span class="line">    print(Solution().quicksort(nums))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 针对第 2、3 种</span></span><br><span class="line">    <span class="comment"># Solution().quicksort(nums)</span></span><br><span class="line">    <span class="comment"># print(nums)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">[<span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">[]</span><br></pre></td></tr></table></figure><h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul><li><a href="https://en.wikipedia.org/wiki/Quicksort" target="_blank" rel="noopener">Quicksort</a></li><li><a href="https://zh.wikipedia.org/wiki/中位數" target="_blank" rel="noopener">中位数</a></li><li><a href="http://en.wikipedia.org/wiki/Pivot_element" target="_blank" rel="noopener">Pivot element</a></li></ul>]]></content:encoded>
      
      <comments>https://depp.wang/2020/06/18/several-implementations-of-quick-sort/#disqus_thread</comments>
    </item>
    
    <item>
      <title>如何查找某个网站的（如：有道云笔记）的接口</title>
      <link>https://depp.wang/2020/06/11/how-to-find-the-api-of-a-website-eg-note-youdao-com/</link>
      <guid>https://depp.wang/2020/06/11/how-to-find-the-api-of-a-website-eg-note-youdao-com/</guid>
      <pubDate>Thu, 11 Jun 2020 20:48:37 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://depp.wang&quot;&gt;DeppWang&lt;/a&gt;、&lt;a href=&quot;https://depp.wang/2020/06/11/how-to-find-the-api-of-a-website-eg-note-youdao-com&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;开发了个 《一键导出 / 备份「有道云笔记」所有笔记》的&lt;a href=&quot;https://github.com/DeppWang/youdaonote-pull&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;脚本&lt;/a&gt;。主要原理是利用有道云笔记本身的接口。下面是根据正常用户操作逻辑，找到需要的接口，主要是登录和「下载」。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>作者：<a href="https://depp.wang">DeppWang</a>、<a href="https://depp.wang/2020/06/11/how-to-find-the-api-of-a-website-eg-note-youdao-com">原文地址</a></p></blockquote><p>开发了个 《一键导出 / 备份「有道云笔记」所有笔记》的<a href="https://github.com/DeppWang/youdaonote-pull" target="_blank" rel="noopener">脚本</a>。主要原理是利用有道云笔记本身的接口。下面是根据正常用户操作逻辑，找到需要的接口，主要是登录和「下载」。</p><a id="more"></a><h2 id="一、登录"><a href="#一、登录" class="headerlink" title="一、登录"></a>一、登录</h2><p>登录的目的是获取 Cookie</p><h3 id="1-1-找登录接口"><a href="#1-1-找登录接口" class="headerlink" title="1.1 找登录接口"></a>1.1 找登录接口</h3><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-06-10-150019.png" alt="image-20200610230018739" style="zoom:50%;"></p><p>接口应该在登录时执行。使用<strong>错误密码</strong>测试，可得到登录 post 请求接口。注意过滤条件是 <strong>All</strong></p><figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">https://note.youdao.com/login/acc/urs/verify/<span class="meta">check</span>?app=web<span class="variable">&amp;product</span>=YNOTE<span class="variable">&amp;tp</span>=urstoken<span class="variable">&amp;cf</span>=6<span class="variable">&amp;fr</span>=1<span class="variable">&amp;systemName</span>=<span class="variable">&amp;deviceType</span>=<span class="variable">&amp;ru</span>=</span><br><span class="line">https://note.youdao.com/signIn//loginCallback.html<span class="variable">&amp;er</span>=</span><br><span class="line">https://note.youdao.com/signIn//loginCallback.html&amp;</span><br><span class="line">vcode=dman9<span class="variable">&amp;systemName</span>=mac<span class="variable">&amp;deviceType</span>=MacPC<span class="variable">&amp;timestamp</span>=1591770253472</span><br></pre></td></tr></table></figure><h3 id="1-2-推导密码加密规则"><a href="#1-2-推导密码加密规则" class="headerlink" title="1.2 推导密码加密规则"></a>1.2 推导密码加密规则</h3><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-06-10-062936.png" alt="image-20200610142935436"></p><p>本地测试使用同样错误密码用不同加密算法加密，看加密结果是否一致</p><p>发现使用 md5 加密</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Python3</span></span><br><span class="line">password=hashlib.md5(password.encode(<span class="string">'utf-8'</span>)).hexdigest()</span><br></pre></td></tr></table></figure><h3 id="1-3-找返回验证登录状态-Cookie-的接口"><a href="#1-3-找返回验证登录状态-Cookie-的接口" class="headerlink" title="1.3 找返回验证登录状态 Cookie 的接口"></a>1.3 找返回验证登录状态 Cookie 的接口</h3><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-06-10-091312.png" alt="image-20200610171312277" style="zoom:50%;"></p><p>登录成功后，会返回验证登录状态的 Cookie。接口应该在登录成功后执行。发现跳转首页后第一个 XHR 接口中包含验证登录状态的 Cookie，YNOTE_CSTK</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">https://note.youdao.com/yws/mapi/<span class="keyword">user</span>?<span class="keyword">method</span>=<span class="keyword">get</span>&amp;multilevelEnable=<span class="keyword">true</span></span><br></pre></td></tr></table></figure><!--只需要有 YNOTE_CSTK 和 YNOTE_SESS 两个即可登录，两个都需要登录成功后的值，不一定要一起返回的。只暴露 YNOTE_CSTK 不用担心账号被登录--><h2 id="二、「下载」"><a href="#二、「下载」" class="headerlink" title="二、「下载」"></a>二、「下载」</h2><h3 id="2-1-找返回根目录-id-的接口"><a href="#2-1-找返回根目录-id-的接口" class="headerlink" title="2.1 找返回根目录 id 的接口"></a>2.1 找返回根目录 id 的接口</h3><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-06-11-054205.png" alt="image-20200611134205218" style="zoom:50%;"></p><p>我们根据一个笔记 URL 可以看出，URL 里包含了父文件夹 id 和当前文件 id。「我的文件夹」下的 test.md 的 URL：</p><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="symbol">https:</span>/<span class="regexp">/note.youdao.com/web</span><span class="regexp">/#/file</span><span class="regexp">/F83DF1ADA69344D194C7CE861D09B1A1/note</span><span class="regexp">/WEB4aa8bf8074d61befea1dd20f5593f01c/</span></span><br></pre></td></tr></table></figure><p>「我的文件夹」 是根目录，它的 id 是 <code>F83DF1ADA69344D194C7CE861D09B1A1</code>，下面称它为 root_id。</p><p>我们推测，有道云笔记是设计是根据文件夹 id，获取文件夹下的所有文件信息（打开文件夹，可看到文件夹下的文件）。所以我们需要先得到 root_id。当登录成功后，跳转到首页时，应该有接口能得到 root_id。</p><p>测试发现下面接口返回值包含 root_id：</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">https:<span class="regexp">//</span>note.youdao.com<span class="regexp">/yws/</span>api<span class="regexp">/personal/</span>file?method=getByPath&amp;keyfrom=web&amp;cstk=<span class="number">01</span>PvSwwu</span><br></pre></td></tr></table></figure><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-06-11-070108.png" alt="image-20200611150107522" style="zoom:50%;"></p><p>接口返回格式类似这样：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"fileEntry"</span>:&#123;</span><br><span class="line">        <span class="attr">"userId"</span>:<span class="string">"m17191082115@163.com"</span>,</span><br><span class="line">        "id":"F83DF1ADA69344D194C7CE861D09B1A1", // root_id</span><br><span class="line">        "version":22888,</span><br><span class="line">        "name":"ROOT",</span><br><span class="line">        "parentId":"0",</span><br><span class="line">        "createTimeForSort":1497860357,</span><br><span class="line">        "modifyTimeForSort":1497860357,</span><br><span class="line">        ....</span><br><span class="line">    &#125;,</span><br><span class="line">    "fileMeta":&#123;</span><br><span class="line">        "chunkList":"None",</span><br><span class="line">        "sharedCount":0,</span><br><span class="line">        "title":"ROOT",</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">root_id = response.content[<span class="string">'fileEntry'</span>][<span class="string">'id'</span>]</span><br></pre></td></tr></table></figure><h3 id="2-2-找获取目录下所有文件信息的接口"><a href="#2-2-找获取目录下所有文件信息的接口" class="headerlink" title="2.2 找获取目录下所有文件信息的接口"></a>2.2 找获取目录下所有文件信息的接口</h3><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-06-11-052343.png" alt="image-20200611132342543" style="zoom:50%;"></p><p>有了 root_id，需要找到根据 id 获取目录下所有文件信息的接口。</p><p>接口应该在打开文件夹时执行。点击某一个文件夹，测试发现包含当前目录所有文件信息的接口为：</p><figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">https://note.youdao.com/yws/api/personal/<span class="meta">file</span>/9d8a2385eeec77338211b4f04bbf844d?all=true<span class="variable">&amp;f</span>=true<span class="variable">&amp;len</span>=30<span class="variable">&amp;sort</span>=1<span class="variable">&amp;isReverse</span>=false<span class="variable">&amp;method</span>=listPageByParentId<span class="variable">&amp;keyfrom</span>=web<span class="variable">&amp;cstk</span>=01PvSwwu</span><br></pre></td></tr></table></figure><p>接口返回格式跟上面差不多，只是数量更多，属性多了 parentId（父文件夹 id）。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"fileEntry"</span>:&#123;</span><br><span class="line">            <span class="attr">"userId"</span>:<span class="string">"m17191082115@163.com"</span>,</span><br><span class="line">            <span class="attr">"id"</span>:<span class="string">"9d8a2385eeec77338211b4f04bbf844d"</span>,</span><br><span class="line">            <span class="attr">"version"</span>:<span class="number">14168</span>,</span><br><span class="line">            <span class="attr">"name"</span>:<span class="string">"来自手机"</span>,</span><br><span class="line">            "parentId":"F83DF1ADA69344D194C7CE861D09B1A1", // 父文件夹的 id，此时是 root_id</span><br><span class="line">            "createTimeForSort":1550712995,</span><br><span class="line">            "modifyTimeForSort":1550713003,</span><br><span class="line">            ....</span><br><span class="line">        &#125;,</span><br><span class="line">        "fileMeta":&#123;</span><br><span class="line">            "chunkList":null,</span><br><span class="line">            "sharedCount":0,</span><br><span class="line">            "title":"来自手机",</span><br><span class="line">            "fileSize":0,</span><br><span class="line">            ...</span><br><span class="line">        &#125;,</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="2-3-找到获取文件内容的接口"><a href="#2-3-找到获取文件内容的接口" class="headerlink" title="2.3 找到获取文件内容的接口"></a>2.3 找到获取文件内容的接口</h3><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-06-10-095111.png" alt="image-20200610175111568" style="zoom:50%;"></p><p>通过文件夹 id 得到了文件 id（fileId），需要找到根据 fileId 获取文件内容的接口。</p><p>接口应该在点击笔记标题得到笔记内容时执行。点击某一篇笔记标题，可以找到获取文件内容的接口：</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">https:<span class="regexp">//</span>note.youdao.com<span class="regexp">/yws/</span>api<span class="regexp">/personal/</span>sync?method=download&amp;keyfrom=web&amp;cstk=<span class="number">01</span>PvSwwu</span><br></pre></td></tr></table></figure><h2 id="三、模拟浏览器操作"><a href="#三、模拟浏览器操作" class="headerlink" title="三、模拟浏览器操作"></a>三、模拟浏览器操作</h2><h3 id="3-1-设置请求头"><a href="#3-1-设置请求头" class="headerlink" title="3.1 设置请求头"></a>3.1 设置请求头</h3><p>随便哪个页面（如：首页 <code>https://note.youdao.com/</code>）可以看到请求头包含下面这些内容：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-06-10-102800.png" alt="image-20200610182800122" style="zoom:50%;"></p><p>取一部分设置即可</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YoudaoNoteSession</span><span class="params">(requests.Session)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        self.headers = &#123;</span><br><span class="line">            <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36'</span>,</span><br><span class="line">            <span class="string">'Accept'</span>: <span class="string">'*/*'</span>,</span><br><span class="line">            <span class="string">'Accept-Encoding'</span>: <span class="string">'gzip, deflate, br'</span>,</span><br><span class="line">            <span class="string">'Accept-Language'</span>: <span class="string">'zh-CN,zh;q=0.9,en;q=0.8'</span>,</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-模拟「进入网页版」"><a href="#3-2-模拟「进入网页版」" class="headerlink" title="3.2 模拟「进入网页版」"></a>3.2 模拟「进入网页版」</h3><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-06-10-113424.png" alt="image-20200610193423993" style="zoom: 50%;"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.get(<span class="string">'https://note.youdao.com/web/'</span>)</span><br></pre></td></tr></table></figure><p>点击「进入网页版」，会重定向到登录页面</p><h3 id="3-3-模拟打开登录页"><a href="#3-3-模拟打开登录页" class="headerlink" title="3.3 模拟打开登录页"></a>3.3 模拟打开登录页</h3><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-06-10-060620.png" alt="image-20200610140619564" style="zoom: 67%;"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.get(<span class="string">'https://note.youdao.com/signIn/index.html?&amp;callback=https%3A%2F%2Fnote.youdao.com%2Fweb%2F&amp;from=web'</span>)</span><br></pre></td></tr></table></figure><p>跳转登录页后，要执行下面 3 个接口：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.get(<span class="string">'https://note.youdao.com/login/acc/pe/getsess?product=YNOTE&amp;_='</span> + timestamp())</span><br><span class="line">self.get(<span class="string">'https://note.youdao.com/auth/cq.json?app=web&amp;_='</span> + timestamp())</span><br><span class="line">self.get(<span class="string">'https://note.youdao.com/auth/urs/login.json?app=web&amp;_='</span> + timestamp())</span><br></pre></td></tr></table></figure><h2 id="四、结语"><a href="#四、结语" class="headerlink" title="四、结语"></a>四、结语</h2><p>根据找到的接口，模拟用户操作也有不少应用场景。除了开发像这种导出文件的脚本，可以开发一切你想自动化执行的操作。比方 cnblogs、juejin 发文章等。比较麻烦的就是像上面这样找接口了，可以先看看有没有人有过总结。</p><p>也可以利用一些浏览器的 API，如 <a href="https://github.com/puppeteer/puppeteer" target="_blank" rel="noopener">Puppeteer</a>，它提供一个真实的浏览器环境，可以真正模拟用户操作，不需要找到所有接口，只需要设置网页 url，以及设置需要操作的「按钮」属性。因为提供浏览器环境，它属于重量级操作。可以看看 <a href="https://github.com/crawlab-team/artipub" target="_blank" rel="noopener">ArtiPub</a> 如何使用 Puppeteer。这种方式有点不好的地方就是平台可能改前端属性，需要注意更新。</p><!--有什么不明白的看看[源码](http://github.com/DeppWang/youdaonote-pull/blob/master/pull.py)就知道了。--><p>全文完。</p><!--cnblogs.com 发布文章是用 i.cnblogs.com/api/posts 接口。所以 ArtiPub 没有接口？-->]]></content:encoded>
      
      <comments>https://depp.wang/2020/06/11/how-to-find-the-api-of-a-website-eg-note-youdao-com/#disqus_thread</comments>
    </item>
    
    <item>
      <title>iTranswarp 部署记录</title>
      <link>https://depp.wang/2020/05/26/itranswarp-deploy-record/</link>
      <guid>https://depp.wang/2020/05/26/itranswarp-deploy-record/</guid>
      <pubDate>Tue, 26 May 2020 17:58:35 GMT</pubDate>
      <description>
      
        &lt;p&gt;作者：&lt;a href=&quot;https://depp.wang&quot;&gt;DeppWang&lt;/a&gt;、&lt;a href=&quot;https://depp.wang/2020/05/26/itranswarp-deploy-record/&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目的：使用 &lt;a href=&quot;https://github.com/michaelliao/itranswarp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iTranswarp&lt;/a&gt; 学习 ngix 配置&lt;/p&gt;
&lt;p&gt;如果你只想本地启动，直接修改 ip，使用 docker-compose 即可&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>作者：<a href="https://depp.wang">DeppWang</a>、<a href="https://depp.wang/2020/05/26/itranswarp-deploy-record/">原文地址</a></p><p>目的：使用 <a href="https://github.com/michaelliao/itranswarp" target="_blank" rel="noopener">iTranswarp</a> 学习 ngix 配置</p><p>如果你只想本地启动，直接修改 ip，使用 docker-compose 即可</p><a id="more"></a><h2 id="Google-Cloud-Platform-配置"><a href="#Google-Cloud-Platform-配置" class="headerlink" title="Google Cloud Platform 配置"></a>Google Cloud Platform 配置</h2><p>本地部署耗资源，服务器部署</p><p>腾讯云 clone GitHub 项目太慢，使用 <a href="https://console.cloud.google.com/" target="_blank" rel="noopener">Google Cloud Platform</a>，招商银行国际信用卡注册</p><p>Compute Engine 新建「虚拟机实例」 CentOS7</p><p>实例配置（防火墙）入站端口</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">0</span> tcp:<span class="number">13306</span>,<span class="number">16379</span>,<span class="number">443</span>,<span class="number">80</span></span><br></pre></td></tr></table></figure><p>「元数据」添加公钥 id_rsa.pub，使用 SSH 公钥登录，原理请看<a href="https://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="noopener">SSH 原理与运用（一）：远程登录</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -i ~/.ssh/id_rsa(私钥) your_user_name@ip</span><br><span class="line"></span><br><span class="line">ssh -i ~/.ssh/id_rsa_4 deppwxq@35.201.176.108 # 示例</span><br></pre></td></tr></table></figure><p>安装 Git、配置别名</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install git-core</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global alias.st status</span><br><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.unstage <span class="string">'reset HEAD'</span></span><br><span class="line">git config --global alias.last <span class="string">'log -1'</span></span><br><span class="line">git config --global alias.lg <span class="string">"log --color --graph --pretty=format:'% Cred% h% Creset -% C(yellow)% d% Creset % s % Cgreen(% cr) % C(bold blue)&lt;% an&gt;% Creset' --abbrev-commit"</span></span><br></pre></td></tr></table></figure><p>切换为 ohmyzsh（个人习惯）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum update &amp;&amp; sudo yum -y install zsh</span><br><span class="line">sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换 zsh 失败时，重新切换</span></span><br><span class="line">sudo chsh -s /bin/zsh your_user_name</span><br><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure><ul><li>可能需要输入用户密码，用户密码为 Google 账号密码</li><li>未生效时重启实例，重启 ip 会变！</li></ul><p>语言设置为英文（默认就是英文，为何 Git 显示中文）</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">localectl</span></span><br></pre></td></tr></table></figure><p>安装 <a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">Docker</a>，<a href="https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">Docker 教程</a></p><p>安装 <a href="https://docs.docker.com/compose/install/#install-compose" target="_blank" rel="noopener">Docker-Compose</a>，<a href="https://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html" target="_blank" rel="noopener">Docker-Compose 教程</a></p><p>重启实例，ip 会变！需要重启 docker daemon</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo<span class="built_in"> service </span>docker start</span><br></pre></td></tr></table></figure><h2 id="服务器运行项目"><a href="#服务器运行项目" class="headerlink" title="服务器运行项目"></a>服务器运行项目</h2><p>先 fork 项目</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/your-name/itranswarp.git <span class="comment"># 使用 HTTPS</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> itranswarp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> docker</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp .env.example .env</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim .env <span class="comment"># 修改为服务器公网 ip</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker-compose up <span class="comment"># 启动</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker-compose stop <span class="comment"># 停止</span></span></span><br></pre></td></tr></table></figure><p>修改服务器 hosts，相当于 DNS</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">vim <span class="regexp">/etc/</span>hosts</span><br></pre></td></tr></table></figure><p>使用 <a href="https://zh.wikipedia.org/wiki/Lynx" target="_blank" rel="noopener">lynx</a> 模拟服务器本地浏览器打开 <code>https://www.local.itranswarp.com/</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install lynx</span><br><span class="line">lynx https://www.local.itranswarp.com/</span><br></pre></td></tr></table></figure><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-05-25-143614.png" alt="image-20200525223613874"></p><p>远程连接 Redis</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 远程连接</span></span><br><span class="line">redis-cli -h XXX.XXX.XXX.XXX(ip) -p port -a password</span><br><span class="line">redis-cli -h ip -p 16379 -a JFPRJ</span><br></pre></td></tr></table></figure><p>远程连接 Mysql 使用 Navicat Premium</p><p>进入容器</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container exec -it [containerId] /bin/bash # 启动容器实例 bash</span><br><span class="line">or</span><br><span class="line">docker exec -it [containerId] /bin/bash</span><br></pre></td></tr></table></figure><h2 id="使用自定义域名"><a href="#使用自定义域名" class="headerlink" title="使用自定义域名"></a>使用自定义域名</h2><h3 id="配置域名解析"><a href="#配置域名解析" class="headerlink" title="配置域名解析"></a>配置域名解析</h3><p>（例：万网）配置域名解析</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">A www.xingquan.wang ip</span><br><span class="line">A static.xingquan.wang ip</span><br><span class="line">A source.xingquan.wang ip</span><br><span class="line">A @xingquan.wang ip</span><br></pre></td></tr></table></figure><h3 id="申请数字证书"><a href="#申请数字证书" class="headerlink" title="申请数字证书"></a>申请数字证书</h3><p><a href="https://freessl.org/" target="_blank" rel="noopener">freessl</a> 申请免费数字证书</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">www<span class="selector-class">.xingquan</span><span class="selector-class">.wang</span></span><br><span class="line">static<span class="selector-class">.xingquan</span><span class="selector-class">.wang</span></span><br><span class="line">source<span class="selector-class">.xingquan</span><span class="selector-class">.wang</span></span><br><span class="line">xingquan.wang</span><br></pre></td></tr></table></figure><p>可四个域名同时申请同一个数字证书，也可分开申请</p><p>离线申请，使用 <a href="https://keymanager.org/" target="_blank" rel="noopener">KeyManager</a>，最后「导出证书」，解压可得到两个文件：<code>**</code>.crt，<code>**</code>.key。crt 为数字证书，key 为服务器私钥，深入理解请看<a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=2665513779&idx=1&sn=a1de58690ad4f95111e013254a026ca2&chksm=80d67b70b7a1f26697fa1626b3e9830dbdf4857d7a9528d22662f2e43af149265c4fd1b60024&scene=21#wechat_redirect" target="_blank" rel="noopener">一个故事讲完 https</a></p><h3 id="修改项目配置文件"><a href="#修改项目配置文件" class="headerlink" title="修改项目配置文件"></a>修改项目配置文件</h3><p>clone fork 项目到本地，（切换分支）修改配置。</p><p>全局将 local.itranswarp.com 修改为你的域名（如：xingquan.wang）</p><p>修改 local.itranswarp.com.crt / local.itranswarp.com.key 为 xingquan.wang.crt、xingquan.wang.key，使用「导出证书」的 crt、key 替换。local-conf 文件夹下可不修改</p><p>修改配置后，只重启 docker-compose（容器），配置是否生效？生效</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><a href="https://www.xingquan.wang" target="_blank" rel="noopener">https://www.xingquan.wang</a></p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-05-26-084417.png" alt="image-20200526164417094" style="zoom:50%;"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学习到</p><ul><li>HTTPS、证书</li><li>ngix 配置</li></ul><p>问题：</p><ul><li>Docker 如何进入容器操作，如查看日志、修改数据库</li><li>iTranswarp 作为博客，没有订阅地址？</li></ul><p>admin 默认密码为 123456</p>]]></content:encoded>
      
      <comments>https://depp.wang/2020/05/26/itranswarp-deploy-record/#disqus_thread</comments>
    </item>
    
    <item>
      <title>一个一键导出/备份「有道云笔记」所有笔记的脚本</title>
      <link>https://depp.wang/2020/05/18/export-youdaonote-all-notes/</link>
      <guid>https://depp.wang/2020/05/18/export-youdaonote-all-notes/</guid>
      <pubDate>Mon, 18 May 2020 13:26:55 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://depp.wang&quot;&gt;DeppWang&lt;/a&gt;、&lt;a href=&quot;https://depp.wang/2020/05/18/export-youdaonote-all-notes/&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;出发点&quot;&gt;&lt;a href=&quot;#出发点&quot; class=&quot;headerlink&quot; title=&quot;出发点&quot;&gt;&lt;/a&gt;出发点&lt;/h2&gt;&lt;p&gt;原来一直是有道云笔记的忠实用户，后面接触到了所见即所得的 &lt;a href=&quot;https://typora.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Typora&lt;/a&gt;，有点用不惯有道云笔记了，想着有什么法子能电脑本地文件和有道云笔记同步，这样电脑使用 Typora，手机使用有道云笔记。发现有道云笔记有 &lt;a href=&quot;http://note.youdao.com/open/developguide.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Open API&lt;/a&gt; ，打算利用提供的 API，写两个脚本，一个 pull 所有文件到本地，一个 push 本地文件到云笔记。但 API 太难用了，N 多年没更新了，问客服也没更新的意思，开发到最后发现竟然没有 Markdown 文件的接口，醉了。遂放弃。&lt;/p&gt;
&lt;p&gt;现在我使用 Typora + &lt;a href=&quot;https://www.dropbox.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dropbox&lt;/a&gt; + &lt;a href=&quot;https://www.mweb.im/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MWeb&lt;/a&gt; 实现同步笔记和手机查看编辑的功能，很香。&lt;/p&gt;
&lt;p&gt;最近给朋友推荐此方式，但发现有道云笔记最新的 Mac 客户端和网页端去除了导出所有笔记的功能！这是什么逻辑，怕用户跑了么。所以在原来 pull 脚本的基础上修改得到此脚本。&lt;/p&gt;
&lt;p&gt;脚本地址：&lt;a href=&quot;https://github.com/DeppWang/youdaonote-pull&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/DeppWang/youdaonote-pull&lt;/a&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>作者：<a href="https://depp.wang">DeppWang</a>、<a href="https://depp.wang/2020/05/18/export-youdaonote-all-notes/">原文地址</a></p></blockquote><h2 id="出发点"><a href="#出发点" class="headerlink" title="出发点"></a>出发点</h2><p>原来一直是有道云笔记的忠实用户，后面接触到了所见即所得的 <a href="https://typora.io/" target="_blank" rel="noopener">Typora</a>，有点用不惯有道云笔记了，想着有什么法子能电脑本地文件和有道云笔记同步，这样电脑使用 Typora，手机使用有道云笔记。发现有道云笔记有 <a href="http://note.youdao.com/open/developguide.html" target="_blank" rel="noopener">Open API</a> ，打算利用提供的 API，写两个脚本，一个 pull 所有文件到本地，一个 push 本地文件到云笔记。但 API 太难用了，N 多年没更新了，问客服也没更新的意思，开发到最后发现竟然没有 Markdown 文件的接口，醉了。遂放弃。</p><p>现在我使用 Typora + <a href="https://www.dropbox.com/" target="_blank" rel="noopener">Dropbox</a> + <a href="https://www.mweb.im/" target="_blank" rel="noopener">MWeb</a> 实现同步笔记和手机查看编辑的功能，很香。</p><p>最近给朋友推荐此方式，但发现有道云笔记最新的 Mac 客户端和网页端去除了导出所有笔记的功能！这是什么逻辑，怕用户跑了么。所以在原来 pull 脚本的基础上修改得到此脚本。</p><p>脚本地址：<a href="https://github.com/DeppWang/youdaonote-pull" target="_blank" rel="noopener">https://github.com/DeppWang/youdaonote-pull</a></p><a id="more"></a><h2 id="使用提示"><a href="#使用提示" class="headerlink" title="使用提示"></a>使用提示</h2><ol><li>脚本单纯本地运行，不用担心你的账号密码泄露。但注意，如果你自己修改脚本，注意不要将 config.json 文件 push 到 GitHub</li><li>.note 格式笔记下载后为 xml 格式，<strong>默认将 .note 格式笔记转换为 Markdown 格式</strong>，table 等未转换，需要手动复制</li><li>有道云笔记图床图片在有道云笔记外不显示，<strong>默认下载到本地，使用本地图片链接，可设置上传到免费的 <a href="https://sm.ms" target="_blank" rel="noopener">SM.MS</a> 上</strong></li><li>如果你不是开发者，可能对下面的命令行操作有所陌生，建议按步骤慢慢操作一遍。后续我会更加完善此文档，并根据需求看是否应该提供网页下载</li><li>请确认代码是否为最新，有问题请提交 issue</li></ol><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><!--针对普通用户--><h3 id="一、导出前的准备工作"><a href="#一、导出前的准备工作" class="headerlink" title="一、导出前的准备工作"></a>一、导出前的准备工作</h3><h4 id="1、安装-Git、clone-项目"><a href="#1、安装-Git、clone-项目" class="headerlink" title="1、安装  Git、clone 项目"></a>1、安装  <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a>、clone 项目</h4><ul><li>可根据 <a href="https://www.liaoxuefeng.com/wiki/896043488029600/896067074338496" target="_blank" rel="noopener">廖雪峰 Git 教程</a> 安装 Git，测试是否安装成功</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure><ul><li>打开命令行软件，如 Terminal (macOS)、PowerShell(Windows)，clone 项目，里面包含脚本</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pwd</span><br><span class="line">git clone https://github.com/DeppWang/youdaonote-pull.git</span><br><span class="line">cd youdaonote-pull</span><br></pre></td></tr></table></figure><h4 id="2、安装-Python3、安装依赖模块（包）"><a href="#2、安装-Python3、安装依赖模块（包）" class="headerlink" title="2、安装 Python3、安装依赖模块（包）"></a>2、安装 Python3、安装依赖模块（包）</h4><ul><li>可根据 <a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1016959856222624" target="_blank" rel="noopener">廖雪峰 Python 教程</a> 安装 Python3，测试是否安装成功</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 --version  # macOS/Linux</span><br><span class="line">python --version  # Windows</span><br></pre></td></tr></table></figure><ul><li>安装 requests 依赖包</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> macOS/Linux</span></span><br><span class="line">sudo easy_install pip3 # 安装 Python3 Package Installer</span><br><span class="line">pip3 install requests # 安装 requests 包，脚本依赖 requests</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Windows</span></span><br><span class="line">pip install requests # 安装 requests 包，脚本依赖 requests</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 有问题可参考 https://www.liaoxuefeng.com/wiki/1016959663602400/1017493741106496</span></span><br></pre></td></tr></table></figure><h4 id="3、设置脚本参数配置文件"><a href="#3、设置脚本参数配置文件" class="headerlink" title="3、设置脚本参数配置文件"></a>3、设置脚本参数配置文件</h4><p>config.json</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"username"</span>: <span class="string">""</span>,</span><br><span class="line">   <span class="attr">"password"</span>: <span class="string">""</span>,</span><br><span class="line">   <span class="attr">"local_dir"</span>: <span class="string">""</span>,</span><br><span class="line">   <span class="attr">"ydnote_dir"</span>: <span class="string">""</span>,</span><br><span class="line">   <span class="attr">"smms_secret_token"</span>: <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>username：<strong>必填</strong>，你的有道云笔记用户名</li><li>password：<strong>必填</strong>，你的有道云笔记密码</li><li>local_dir：选填，本地存放导出文件的文件夹，不填则默认为当前文件夹</li><li>ydnote_dir：选填，有道云笔记指定导出文件夹名，不填则导出所有文件</li><li>smms_secret_token：选填， <a href="https://sm.ms" target="_blank" rel="noopener">SM.MS</a> 的 Secret Token（注册后 -&gt; Dashboard -&gt; API Token），用于上传笔记中有道云图床图片到 SM.MS 图床，不填则只下载到本地（youdaonote-images 文件夹），Markdown 使用本地链接</li><li>建议使用 <a href="https://www.sublimetext.com/3" target="_blank" rel="noopener">Sublime</a> 编辑 config.json</li></ul><p>示例：</p><ul><li>macOS</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"username"</span>: <span class="string">"deppwang@163.com"</span>,</span><br><span class="line">   <span class="attr">"password"</span>: <span class="string">"12345678"</span>,</span><br><span class="line">   <span class="attr">"local_dir"</span>: <span class="string">"/Users/yanjie/Dropbox/youdaonote/test"</span>,</span><br><span class="line">   <span class="attr">"ydnote_dir"</span>: <span class="string">""</span>,</span><br><span class="line">   <span class="attr">"smms_secret_token"</span>: <span class="string">"SGSLk9yWdTe4RenXYqEPWkqVrx0Yexample"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Windows</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"username"</span>: <span class="string">"deppwang@163.com"</span>,</span><br><span class="line">   <span class="attr">"password"</span>: <span class="string">"12345678"</span>,</span><br><span class="line">   <span class="attr">"local_dir"</span>: <span class="string">"D:/Dropbox/youdaonote/test"</span>,</span><br><span class="line">   <span class="attr">"ydnote_dir"</span>: <span class="string">""</span>,</span><br><span class="line">   <span class="attr">"smms_secret_token"</span>: <span class="string">"SGSLk9yWdTe4RenXYqEPWkqVrx0Yexample"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、运行导出脚本"><a href="#二、运行导出脚本" class="headerlink" title="二、运行导出脚本"></a>二、运行导出脚本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 pull.py # macOS/Linux</span><br><span class="line">python pull.py  # Windows</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-06-09-130325.jpg" alt=""></p><!--[](https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-06-07-140101.jpg)--><h3 id="三、多次导出"><a href="#三、多次导出" class="headerlink" title="三、多次导出"></a>三、多次导出</h3><p>多次导出时，同样使用以下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 pull.py # macOS/Linux</span><br><span class="line">python pull.py # Windows</span><br></pre></td></tr></table></figure><p>根据有道云笔记的最后修改时间是否大于本地文件最后修改时间来判断是否更新。再次导出时，只会导出有道云笔记上次导出后新增、修改的笔记，不会覆盖本地已经修改的文件。<strong>但有道云笔记和本地不要同时修改同一个文件，这样会导致本地修改丢失</strong>！</p><p>导出是根据最后修改时间来判断，所以被更新文件和新导出一样，会重复下载图片</p><h2 id="后续开发计划"><a href="#后续开发计划" class="headerlink" title="后续开发计划"></a>后续开发计划</h2><ul><li><input checked disabled type="checkbox"> 将 .note 文件转换为 MarkDown 文件</li><li><input checked disabled type="checkbox"> 解决有道云图床图片不能显示问题，实现方式为默认下载到本地，使用本地图片链接，也可上传到 SM.MS 图床</li><li><input checked disabled type="checkbox"> 首次导出使用账号密码登录，再次导出时使用 Cookie 登录（Cookie 保存在 cookies.json 中），避免频繁操作时因为需要输入验证码导致登录不上的情况</li><li><input disabled type="checkbox"> 优化如果同一目录存在同名的 .md 和 .note 文件，.md 文件将被覆盖的情况</li><li><input disabled type="checkbox"> 并发执行以加快速度</li><li><input disabled type="checkbox"> 针对非开发者用户，提供网页输入账号密码直接下载所有笔记压缩包的方式</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>正常用户操作时，浏览器（前端）调用服务器（后端）接口，接口返回文件内容由前端渲染显示。</li><li>原理是利用有道云笔记本身的接口，模拟操作接口，将前端显示改为存放到本地。可以看看<a href="https://depp.wang/2020/06/11/how-to-find-the-api-of-a-website-eg-note-youdao-com">如何找到有道云笔记的接口</a></li><li>Xml 转换为 Markdown：使用了 <a href="http://docs.python.org/3.7/library/xml.etree.elementtree.html" target="_blank" rel="noopener">xml.etree.ElementTreeI</a></li></ul><h2 id="感谢（参考）"><a href="#感谢（参考）" class="headerlink" title="感谢（参考）"></a>感谢（参考）</h2><ul><li><a href="https://github.com/wesley2012/YoudaoNoteExport" target="_blank" rel="noopener">YoudaoNoteExport</a></li></ul>]]></content:encoded>
      
      <comments>https://depp.wang/2020/05/18/export-youdaonote-all-notes/#disqus_thread</comments>
    </item>
    
    <item>
      <title>从虚拟机角度理解，为什么静态块函数先于构造函数执行</title>
      <link>https://depp.wang/2020/05/06/static-block-method-and-constructor-method/</link>
      <guid>https://depp.wang/2020/05/06/static-block-method-and-constructor-method/</guid>
      <pubDate>Wed, 06 May 2020 15:02:25 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://depp.wang&quot;&gt;DeppWang&lt;/a&gt;、&lt;a href=&quot;https://depp.wang/2020/05/06/static-block-method-and-constructor-method/&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;常常有关于静态块函数、构造函数执行顺序的面试题，如果死记硬背，往往容易混淆。需要从虚拟角度来理解，当真正理解后，其实很简单。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>作者：<a href="https://depp.wang">DeppWang</a>、<a href="https://depp.wang/2020/05/06/static-block-method-and-constructor-method/">原文地址</a></p></blockquote><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>常常有关于静态块函数、构造函数执行顺序的面试题，如果死记硬背，往往容易混淆。需要从虚拟角度来理解，当真正理解后，其实很简单。</p><a id="more"></a><p>一个面试题栗子，请输出下面代码的运行结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticSuper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"super static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StaticSuper() &#123;</span><br><span class="line">        System.out.println(<span class="string">"super constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> <span class="keyword">extends</span> <span class="title">StaticSuper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StaticTest() &#123;</span><br><span class="line">        System.out.println(<span class="string">"constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"in main"</span>);</span><br><span class="line">        StaticTest s = <span class="keyword">new</span> StaticTest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">super <span class="keyword">static</span> <span class="keyword">block</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">block</span></span><br><span class="line"><span class="keyword">in</span> main</span><br><span class="line">super <span class="function"><span class="keyword">constructor</span></span></span><br><span class="line"><span class="function"><span class="title">constructor</span></span></span><br></pre></td></tr></table></figure><h2 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h2><p>当执行 StaticTest.main() 时，类加载器加载 StaticTest.class 文件到虚拟机，新建一个与之对应的 Class 对象，如果有类变量，为类变量设置初始值。</p><p>执行 StaticTest.main()，其实是执行 invokestatic 指令，Java 虚拟机规范规定，执行 invokestatic 指令时，需要先初始化类，初始化类时，执行类构造器 <code>&lt;clinit&gt;()</code> 方法， <code>&lt;clinit&gt;()</code> 方法为类变量赋值以及执行静态代码块，虚拟机保证执行 <code>&lt;clinit&gt;()</code> 方法前先执行父类 <code>&lt;clinit&gt;()</code> 方法。</p><p>执行完 <code>&lt;clinit&gt;()</code> 方法后执行 main() 方法</p><p>执行 new 指令时，实例化生成对象，并为实例变量设置初始值（如果没有初始值），再调用实例构造方法  <code>&lt;init&gt;()</code>  为实例变量赋值。</p><h2 id="三、加入构造代码块"><a href="#三、加入构造代码块" class="headerlink" title="三、加入构造代码块"></a>三、加入构造代码块</h2><p>有时候，为了加大难度，里面还会加上构造代码块</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticSuper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"super static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"super constructor block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StaticSuper() &#123;</span><br><span class="line">        System.out.println(<span class="string">"super constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> <span class="keyword">extends</span> <span class="title">StaticSuper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"constructor block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StaticTest() &#123;</span><br><span class="line">        System.out.println(<span class="string">"constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"in main"</span>);</span><br><span class="line">        StaticTest s = <span class="keyword">new</span> StaticTest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造代码块可以看成一个公共构造函数，使用任何构造函数前都需要先执行构造代码块。所以执行结果为：</p><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">super <span class="keyword">static</span> <span class="keyword">block</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">block</span></span><br><span class="line"><span class="keyword">in</span> main</span><br><span class="line">super <span class="function"><span class="keyword">constructor</span> <span class="title">block</span></span></span><br><span class="line"><span class="function"><span class="title">super</span> <span class="title">constructor</span></span></span><br><span class="line"><span class="function"><span class="title">constructor</span> <span class="title">block</span></span></span><br><span class="line"><span class="function"><span class="title">constructor</span></span></span><br></pre></td></tr></table></figure><h2 id="四、应用"><a href="#四、应用" class="headerlink" title="四、应用"></a>四、应用</h2><p>静态代码块属于类构造函数的范畴，所以常用于设置静态变量。如，Integer 里面的 IntegerCache。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            ...</span><br><span class="line">            high = h;</span><br><span class="line"></span><br><span class="line">            cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> j = low;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>1、我们<strong>将静态代码块看成类构造方法</strong>，类构造方法肯定先于实例构造方法执行。</p><p>2、构造代码块可以看成公共构造函数，先于构造函数执行</p><p>这方面的内容可以<a href="https://weread.qq.com/web/reader/cf1320d071a1a78ecf19254k283328802332838023a7529" target="_blank" rel="noopener">《深入理解 Java 虚拟机》（第 3 版）- 7.3 类加载的过程</a>，会比看博文理解得更深刻。</p><!--当运行 StaticTest.main() 后，类加载器就会寻找已经编译的 StaticTest.class 文件，将其加载到虚拟机中，--><blockquote><!--静态块函数也叫静态初始化函数（static initializer）是一段在加载类时会执行的程序代码，它会在其他程序可以使用该类之前就执行。--></blockquote><blockquote><!--构造函数的作用是用于给对象进行初始化。不建立对象，构造函数时不会执行。--></blockquote><!--运行过程如下：--><!--当运行 StaticTest.main()(这是一个 static 方法) 后，类装载器就会寻找已经编译的 StaticTest.class 文件。在装载的过程中，装载器注意到它有一个基类（StaticSuper.class），于是它再装载基类。不管创不创建基类对象，这个过程总会发生。如果基类还有基类，那么第二个基类也会被装载，依此类推。--><!--所有基类装载完成后，先执行根基类的 static 初始化函数，然后是下一个派生类的 static 初始化函数，依此类推。这个顺序非常重要，因为派生类的 “static 初始化函数” 有可能要依赖基类成员的正确初始化。所以依次输出 `super static block`,`static  block`--><!--当所有必要的类都已经装载结束，开始执行 main() 方法体，先输出 `in main`，再用 new StaticSuperTest() 创建对象。--><!--类 StaticTest 存在父类 StaticSuper，先调用 StaticSuper 的构造函数，输出 `super constructor`，最后调用 StaticSuperTest 的构造函数输出 `constructor`。--><!--可以使用 super 显式来指定调用哪个构造函数。基类的构造过程以及构造顺序，同派生类的相同。--><!--五、延伸阅读--><!--[Java 提高篇 ---- 静态代码块、构造代码块、构造函数以及 Java 类初始化顺序](http://www.cnblogs.com/Qian123/p/5713440.html)-->]]></content:encoded>
      
      <comments>https://depp.wang/2020/05/06/static-block-method-and-constructor-method/#disqus_thread</comments>
    </item>
    
    <item>
      <title>一道算法题：查找数组 arr 中第 k 小的奇数</title>
      <link>https://depp.wang/2020/05/06/find-the-k-th-smallest-odd-number-in-the-array-arr/</link>
      <guid>https://depp.wang/2020/05/06/find-the-k-th-smallest-odd-number-in-the-array-arr/</guid>
      <pubDate>Wed, 06 May 2020 08:09:37 GMT</pubDate>
      <description>
      
        &lt;!--题目来源--&gt;

&lt;!--「北京波粒子科技有限公司」面试题--&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;查找数组 arr 中第 k 小的奇数，如果不存在则返回 0。&lt;/p&gt;
&lt;p&gt;计算出时间复杂度（注意代码注释，尽可能不用全排序，不要使⽤库函数或脚本中已经实现好的排序算法和⼯具，需要⾃⼰实现数据结构和所需要的算法）&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<!--题目来源--><!--「北京波粒子科技有限公司」面试题--><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>查找数组 arr 中第 k 小的奇数，如果不存在则返回 0。</p><p>计算出时间复杂度（注意代码注释，尽可能不用全排序，不要使⽤库函数或脚本中已经实现好的排序算法和⼯具，需要⾃⼰实现数据结构和所需要的算法）</p><a id="more"></a><h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>属于 Top K 问题</li><li>假设数组中数据范围有限，使用一个额外数组，存放每个数字出现的次数，数组下标位置就是数字大小，此种方式为「计数排序法」</li><li>时间复杂度：O(N)，N 为第 k 小的奇数的大小</li><li>最坏时间复杂度：当不存在时，需要遍历完 counter 数组，O(M)，M 为指定数组的范围</li><li>空间复杂度：O(M)，需要长度为 M 的额外数组。</li><li>标签：<code>计数排序</code></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 统计每个数字出现的次数</span></span><br><span class="line">        <span class="keyword">int</span>[] counter = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10001</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">            counter[num] = counter[num] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历 counter，查找第 k 小的奇数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">0</span>; num &lt; counter.length; num++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (counter[num] &gt; <span class="number">0</span> &amp;&amp; x &lt; k &amp;&amp; num % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x == k) &#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">23</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">45</span>, <span class="number">12</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> Solution().findKth(arr, k));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!--参考：https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/3chong-jie-fa-miao-sha-topkkuai-pai-dui-er-cha-sou/-->]]></content:encoded>
      
      <comments>https://depp.wang/2020/05/06/find-the-k-th-smallest-odd-number-in-the-array-arr/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spring 中的反射与反射的原理</title>
      <link>https://depp.wang/2020/05/05/reflection-in-spring-and-reflection-principle/</link>
      <guid>https://depp.wang/2020/05/05/reflection-in-spring-and-reflection-principle/</guid>
      <pubDate>Tue, 05 May 2020 08:09:37 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://depp.wang&quot;&gt;DeppWang&lt;/a&gt;、&lt;a href=&quot;https://depp.wang/2020/05/05/reflection-in-spring-and-reflection-principle/&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-04-29-154427.jpg&quot; alt=&quot;image source: https://coderius.biz.ua/blog/article/vvedenie-v-php-reflection-api&quot;&gt;&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://depp.wang/2020/04/19/realize-a-simple-spring-ioc-container/&quot;&gt;造轮子：实现一个简易的 Spring IoC 容器&lt;/a&gt;一文中提到 Spring 在创建 Bean 实例和依赖注入时使用了反射，本文来具体分析一下 Spring 中的反射以及反射的原理。&lt;/p&gt;
&lt;!--[造轮子：实现一个简易的 Spring IoC 容器](https://mp.weixin.qq.com/s/0kfeHOK6FjbGQ0PwzWe58A)--&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>作者：<a href="https://depp.wang">DeppWang</a>、<a href="https://depp.wang/2020/05/05/reflection-in-spring-and-reflection-principle/">原文地址</a></p></blockquote><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-04-29-154427.jpg" alt="image source: https://coderius.biz.ua/blog/article/vvedenie-v-php-reflection-api"></p><p>在<a href="https://depp.wang/2020/04/19/realize-a-simple-spring-ioc-container/">造轮子：实现一个简易的 Spring IoC 容器</a>一文中提到 Spring 在创建 Bean 实例和依赖注入时使用了反射，本文来具体分析一下 Spring 中的反射以及反射的原理。</p><!--[造轮子：实现一个简易的 Spring IoC 容器](https://mp.weixin.qq.com/s/0kfeHOK6FjbGQ0PwzWe58A)--><a id="more"></a><h2 id="一、Spring-中的反射"><a href="#一、Spring-中的反射" class="headerlink" title="一、Spring 中的反射"></a>一、Spring 中的反射</h2><h3 id="1-1、创建-Bean-实例时的反射"><a href="#1-1、创建-Bean-实例时的反射" class="headerlink" title="1.1、创建 Bean 实例时的反射"></a>1.1、创建 Bean 实例时的反射</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过类加载器，根据 class 路径，得到其类对象</span></span><br><span class="line">Class&lt;?&gt; clz = Thread.currentThread().getContextClassLoader().loadClass(<span class="string">"org.deppwang.litespring.v1.service.PetStoreService"</span>);</span><br><span class="line"><span class="comment">// 根据类对象生成 Bean 实例</span></span><br><span class="line"><span class="keyword">return</span> clz.newInstance();</span><br></pre></td></tr></table></figure><p>反射体现在 <code>clz.newInstance();</code> 中，核心代码可分为两部分：</p><p>1、<strong>利用反射</strong>获取当前类 PetStoreService 的所有构造方法信息（Constructor 对象）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.lang.Class.java</span></span><br><span class="line"><span class="comment">// 调用 native 方法，此时 publicOnly 为 false</span></span><br><span class="line">res = getDeclaredConstructors0(publicOnly);</span><br><span class="line"><span class="comment">// native 方法，从 jvm 中的 class 文件中获取构造方法信息，再转换为 Constructor 对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> Constructor&lt;T&gt;[] getDeclaredConstructors0(<span class="keyword">boolean</span> publicOnly);</span><br></pre></td></tr></table></figure><p>2、<strong>利用反射</strong>通过默认构造方法生成实例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sun.reflect.NativeConstructorAccessorImpl.java</span></span><br><span class="line"><span class="comment">// 调用 native 方法，var1 代表构造方法的参数，此时为 null</span></span><br><span class="line"><span class="keyword">return</span> newInstance0(<span class="keyword">this</span>.c, var1);</span><br><span class="line"><span class="comment">// native 方法，真正生成实例的方法，执行 class 文件的构造方法 &lt;init&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title">newInstance0</span><span class="params">(Constructor&lt;?&gt; var0, Object[] var1)</span></span>;</span><br></pre></td></tr></table></figure><!--new 指令--><h3 id="1-2、构造方法依赖注入时的反射"><a href="#1-2、构造方法依赖注入时的反射" class="headerlink" title="1.2、构造方法依赖注入时的反射"></a>1.2、构造方法依赖注入时的反射</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过反射获取当前类所有的构造方法信息（Constructor 对象）</span></span><br><span class="line">Constructor&lt;?&gt;[] candidates = beanClass.getDeclaredConstructors();</span><br><span class="line"><span class="comment">// 设置构造方法参数实例</span></span><br><span class="line">Object[] argsToUse = <span class="keyword">new</span> Object[parameterTypes.length];</span><br><span class="line">argsToUse[i] = getBean(beanNames.get(i));</span><br><span class="line"><span class="comment">// 使用带有参数的 Constructor 对象实现实例化 Bean。此时使用反射跟上面一样（newInstance0），只是多了参数</span></span><br><span class="line"><span class="keyword">return</span> constructorToUse.newInstance(argsToUse);</span><br></pre></td></tr></table></figure><h3 id="1-3、setter-方法依赖注入时的反射"><a href="#1-3、setter-方法依赖注入时的反射" class="headerlink" title="1.3、setter() 方法依赖注入时的反射"></a>1.3、setter() 方法依赖注入时的反射</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过反射获取当前类所有的方法信息（Method 对象）</span></span><br><span class="line">Method[] methods = bean.getClass().getDeclaredMethods();</span><br><span class="line"><span class="comment">// 获得方法参数实例</span></span><br><span class="line">Object propertyBean = getBean(propertyName);</span><br><span class="line"><span class="comment">// 通过反射执行调用 setter() 方法。invoke：调用方法，propertyBean 作为方法的参数</span></span><br><span class="line">method.invoke(bean, propertyBean);</span><br></pre></td></tr></table></figure><p>bean.getClass().getDeclaredMethods(); 中的核心代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.lang.Class.java</span></span><br><span class="line"><span class="comment">// 调用 native 方法，publicOnly 为 false</span></span><br><span class="line">getDeclaredMethods0(publicOnly);</span><br><span class="line"><span class="comment">// native 方法，从 jvm 中的 class 文件中获取方法信息，再转换为 Method</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> Method[]      getDeclaredMethods0(<span class="keyword">boolean</span> publicOnly);</span><br></pre></td></tr></table></figure><p>method.invoke(bean, propertyBean); 中的核心代码：</p><!--根据 var0 找到 class 文件的 setter() 方法，执行 setter() 方法？--><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sun.reflect.NativeMethodAccessorImpl.java</span></span><br><span class="line"><span class="comment">// 调用 native 方法，var1: bean、var2: propertyBean</span></span><br><span class="line"><span class="keyword">return</span> invoke0(<span class="keyword">this</span>.method, var1, var2);</span><br><span class="line"><span class="comment">// native 方法，运行 class 文件中的字节码指令</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title">invoke0</span><span class="params">(Method var0, Object var1, Object[] var2)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="1-4、-Autowired-依赖注入时的反射"><a href="#1-4、-Autowired-依赖注入时的反射" class="headerlink" title="1.4、@Autowired 依赖注入时的反射"></a>1.4、@Autowired 依赖注入时的反射</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过反射得到当前类所有的字段信息（Field 对象）</span></span><br><span class="line">Field[] fields = bean.getClass().getDeclaredFields();</span><br><span class="line"><span class="comment">// 判断字段是否有 @Autowired 注解</span></span><br><span class="line">Annotation ann = field.getAnnotation(Autowired.class);</span><br><span class="line"><span class="comment">// 设置字段可连接，相当于将非 public（private、default、protect）更改为 public</span></span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 通过反射设置字段的值</span></span><br><span class="line">field.set(bean, getBean(field.getName()));</span><br></pre></td></tr></table></figure><p>bean.getClass().getDeclaredFields(); 中的核心代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.lang.Class.java</span></span><br><span class="line"><span class="comment">// 调用 native 方法，此时 publicOnly 为 false</span></span><br><span class="line">getDeclaredFields0(publicOnly);</span><br><span class="line"><span class="comment">// native 方法，从 jvm 中获取 class 文件的字段信息，再转换为 Field</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> Field[]       getDeclaredFields0(<span class="keyword">boolean</span> publicOnly);</span><br></pre></td></tr></table></figure><p>field.set(bean, getBean(field.getName())); 中的核心代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sun.reflect.UnsafeObjectFieldAccessorImpl.java</span></span><br><span class="line"><span class="comment">// 调用 native 方法，将目标对象 var1 指定偏移量 fieldOffset 处的字段值设置（修改）为 var2。var1 为 bean, var2 为参数实例</span></span><br><span class="line">unsafe.putObject(var1, <span class="keyword">this</span>.fieldOffset, var2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sun.misc.Unsafe.java</span></span><br><span class="line"><span class="comment">// native 方法，直接修改堆中对象字段的数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="二、class-文件与类对象"><a href="#二、class-文件与类对象" class="headerlink" title="二、class 文件与类对象"></a>二、class 文件与类对象</h2><p>class 文件由 java 文件编译而来，class 文件包含字段表、方法表、<code>&lt;init&gt;</code> 方法（构造方法）等。</p><p>当类加载器将 class 文件加载进虚拟机元空间（Meta-space，jdk 1.8）时，虚拟机在元空间中创建一个与之对应的类对象（Class 实例）。并将 class 文件由存放在磁盘的静态结构转换为存放在内存的运行时结构。</p><!--（在元数据中？）--><p>我们可以认为一个类（class 文件）对应一个类对象，当前类的所有对象共用一个类对象。<strong>类对象作为访问存放在 jvm 的 class 文件的入口。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> Field[]       getDeclaredFields0(<span class="keyword">boolean</span> publicOnly);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> Method[]      getDeclaredMethods0(<span class="keyword">boolean</span> publicOnly);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> Constructor&lt;T&gt;[] getDeclaredConstructors0(<span class="keyword">boolean</span> publicOnly);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ReflectionData 缓存反射对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> Field[] declaredFields;</span><br><span class="line">        <span class="keyword">volatile</span> Field[] publicFields;</span><br><span class="line">        <span class="keyword">volatile</span> Method[] declaredMethods;</span><br><span class="line">        <span class="keyword">volatile</span> Method[] publicMethods;</span><br><span class="line">        <span class="keyword">volatile</span> Constructor&lt;T&gt;[] declaredConstructors;</span><br><span class="line">        <span class="keyword">volatile</span> Constructor&lt;T&gt;[] publicConstructors;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1、获得类对象的方式"><a href="#2-1、获得类对象的方式" class="headerlink" title="2.1、获得类对象的方式"></a>2.1、获得类对象的方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、通过对象</span></span><br><span class="line">Class cls = object.getClass();</span><br><span class="line"><span class="comment">// Object.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、通过类加载器</span></span><br><span class="line">Class cls = Thread.currentThread().getContextClassLoader().loadClass(<span class="string">"org.deppwang.litespring.v1.service.PetStoreService"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、通过 Class 类，本质上也是通过类加载器</span></span><br><span class="line">Class cls = Class.forName(<span class="string">"org.deppwang.litespring.v1.service.PetStoreService"</span>);</span><br><span class="line"><span class="comment">// Class.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; forName0(String name, <span class="keyword">boolean</span> initialize,</span><br><span class="line">                                            ClassLoader loader,</span><br><span class="line">                                            Class&lt;?&gt; caller)</span><br></pre></td></tr></table></figure><!--// 4、直接用类名Class cls = String.class;--><h2 id="三、反射方法"><a href="#三、反射方法" class="headerlink" title="三、反射方法"></a>三、反射方法</h2><p>以下是常用的反射方法。</p><h3 id="3-1、Feild-相关"><a href="#3-1、Feild-相关" class="headerlink" title="3.1、Feild 相关"></a>3.1、Feild 相关</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field[] fields = cls.getFields(); <span class="comment">// 获取所有公共的 Field（包括父类）</span></span><br><span class="line">Field[] fields = cls.getDeclaredFields(); <span class="comment">// 获取当前类的所有 Field（不包括父类），包括公共和非公共</span></span><br><span class="line">Field field = cls.getDeclaredField(<span class="string">"fieldName"</span>); <span class="comment">// 指定获取当前类某个 Field</span></span><br><span class="line">field.set(Object, Object); <span class="comment">// 设置（修改）字段值</span></span><br><span class="line">field.get(Object); <span class="comment">// 获取字段值</span></span><br></pre></td></tr></table></figure><p>field.get(Object) 核心代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用 native 方法，获取字段对应的值</span></span><br><span class="line"><span class="keyword">return</span> unsafe.getObject(var1, <span class="keyword">this</span>.fieldOffset);</span><br><span class="line"></span><br><span class="line"><span class="comment">// native 方法，从堆中获取对象指定位置的对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">getObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-2、Method-相关"><a href="#3-2、Method-相关" class="headerlink" title="3.2、Method 相关"></a>3.2、Method 相关</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method[] methods = cls.getMethods(); <span class="comment">// 获取所有公共的 Method（包括父类）</span></span><br><span class="line">Method[] methods = cls.getDeclaredMethods(); <span class="comment">// 获取当前类的所有 Method（不包括父类），包括公共和非公共</span></span><br><span class="line">method.invoke(Object instance, Object... parameters); <span class="comment">// 运行方法</span></span><br></pre></td></tr></table></figure><p>运行方法使用场景：要么是修改对象的数据，如 void setter() 方法；要么是获得执行方法的返回结果。</p><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">String <span class="keyword">result</span> = <span class="function"><span class="keyword">method</span>.<span class="title">invoke</span><span class="params">()</span>.<span class="title">toString</span><span class="params">()</span>;</span></span><br></pre></td></tr></table></figure><h3 id="3-3、Constructor-相关"><a href="#3-3、Constructor-相关" class="headerlink" title="3.3、Constructor 相关"></a>3.3、Constructor 相关</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] constructors = cls.getConstructors(); <span class="comment">// 获取所有公共的 Constructor（包括父类）</span></span><br><span class="line">Constructor&lt;?&gt;[] constructors = cls.getDeclaredConstructors(); <span class="comment">// 获取当前类的所有Constructor（不包括父类），包括公共和非公共</span></span><br><span class="line">constructor.newInstance(Object... parameters); <span class="comment">// 运行构造方法</span></span><br></pre></td></tr></table></figure><!--默认包含一个无参公有构造方法，当存在自定义构造方法时，就没有默认构造方法--><p>当没有明确编写构造方法，Java 编译器将为该类构建一个默认构造函数 <code>&lt;init&gt;</code></p><h2 id="四、native-方法"><a href="#四、native-方法" class="headerlink" title="四、native 方法"></a>四、native 方法</h2><p>Java 1.1 新增「Java 本地接口」(Java Native Interface，JNI)，JNI 是一种包容极广的编程接口，允许我们从 Java 应用程序里调用 native 方法，native 方法由其它语言（C 、C++ 或汇编语言等）编写。native 方法用于实现 Java 无法处理的功能。</p><h3 id="4-1、简单示例"><a href="#4-1、简单示例" class="headerlink" title="4.1、简单示例"></a>4.1、简单示例</h3><p>一个在 Java 中使用 Java 本地接口（JNI）的简单示例。</p><ul><li>环境：<strong>jdk8、macOS 10.15</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">intMethod</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 启动时载入 libMain.dylib</span></span><br><span class="line">        System.loadLibrary(<span class="string">"Main"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Main().intMethod(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Main.c:</span></span><br><span class="line"><span class="comment">// 将 Main.h 引入</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Main.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于继承 "Main.h" 的 Java_Main_intMethod</span></span><br><span class="line"><span class="function">JNIEXPORT jint JNICALL <span class="title">Java_Main_intMethod</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    JNIEnv *env, jobject obj, jint i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i * i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译与运行:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同时生成 Main.class 和 Main.h</span></span><br><span class="line">javac Main.java -h .</span><br><span class="line"><span class="comment">// 根据 Main.c 生成 libMain.dylib</span></span><br><span class="line">gcc -dynamiclib -O3 \</span><br><span class="line">    -I/usr/include \</span><br><span class="line">    -I$JAVA_HOME/include \</span><br><span class="line">    -I$JAVA_HOME/include/darwin \</span><br><span class="line">    Main.c -o libMain.dylib</span><br><span class="line"><span class="comment">// 指定 library 的路径为当前路径</span></span><br><span class="line">java -cp . -Djava.library.path=$(pwd) Main</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Main.h .h 作为头文件*/</span></span><br><span class="line"><span class="comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Header for class Main */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Included_Main</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Included_Main</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     Main</span></span><br><span class="line"><span class="comment"> * Method:    intMethod</span></span><br><span class="line"><span class="comment"> * Signature: (I)I</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jint JNICALL Java_Main_intMethod</span><br><span class="line">  (JNIEnv *, jobject, jint);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javac Main.java -h .</span><br><span class="line"><span class="comment">// 可拆分为两个命令</span></span><br><span class="line">javac Main.java</span><br><span class="line">javah -jni Main</span><br></pre></td></tr></table></figure><h3 id="4-2、原理"><a href="#4-2、原理" class="headerlink" title="4.2、原理"></a>4.2、原理</h3><p>运行 Main.class 时，将 libMain.dylib 载入虚拟机，JVM 调用 libMain.dylib 的 Java_Main_intMethod，传入参数，libMain.dylib 由系统直接运行，返回结果。</p><ul><li>*env 用于将 java 类型数据与本地（此处为 C 语言）类型数据之间的转换</li><li>jint 还是 Java 数据类型，Java 基本数据类型可以映射（使用），不用通过 *env 转换</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*C code*/</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_ClassName_MethodName</span><br><span class="line">  (JNIEnv *env, jobject obj, jstring javaString)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*Get the native string from javaString*/</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *nativeString = (*env)-&gt;GetStringUTFChars(env, javaString, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Do something with the nativeString*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*DON'T FORGET THIS LINE!!!*/</span></span><br><span class="line">    (*env)-&gt;ReleaseStringUTFChars(env, javaString, nativeString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!--Unsafe 类--><!-- - 存放 native 方法的类？--><h3 id="4-3、参考"><a href="#4-3、参考" class="headerlink" title="4.3、参考"></a>4.3、参考</h3><ul><li><a href="https://medium.com/@bschlining/a-simple-java-native-interface-jni-example-in-java-and-scala-68fdafe76f5f" target="_blank" rel="noopener">A Simple Java Native Interface (JNI) example in Java and Scala</a></li><li><a href="https://www.codejava.net/java-core/the-java-language/native-keyword#" target="_blank" rel="noopener">Java native keyword example</a></li><li><a href="https://www.protechtraining.com/blog/post/java-native-interface-jni-example-65" target="_blank" rel="noopener">Java Native Interface: JNI Example</a></li><li><a href="https://depp.wang/Java-Books/docs/Java编程思想.pdf">Java 编程思想 - 附录<strong>A</strong> 使用非<strong>JAVA</strong>代码</a></li><li><a href="https://zh.wikipedia.org/wiki/Java本地接口" target="_blank" rel="noopener">Java本地接口 - WiKi</a></li></ul><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>反射反射，哪里体现反射字面意思？</p><p>可以这么理解，通过 native 方法得到反射对象，操作反射对象，像镜子一样，将反射到原对象上。</p><p>我们发现，反射和 native 方法的关系：</p><ul><li>获取字段、方法、构造方法对象，native() 方法实现</li><li>获取字段值、设置修改字段值，native() 方法实现</li><li>运行方法，native() 方法实现</li><li>运行构造方法，native() 方法实现</li></ul><p>我们可以得出结论，<strong>反射由 native 方法实现</strong>。</p><p>我们说通过反射实现一个功能，我们也可以说：</p><ul><li>通过反射方法实现</li><li>通过反射 API 实现</li><li>通过 native 方法实现</li></ul><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-05-05-123303.png" alt=""></p><p>反射是一种非常规（native 方法实现）方式获取 class 文件信息、运行 class 文件字节码指令和操作对象数据的能力。</p><!--我们可以认为反射就是 native() 方法，可以把它看做一组 API，通过反射 API，可以运行时获取对象的信息，如字段、方法和构造函数，也可以修改字段值和运行方法和构造方法。--><p>一句话总结 ：反射是一种运行时<strong>获取和修改</strong>对象数据的能力。</p><p>关于运行时：Java 是静态语言，先编译，后运行。编译时不执行代码，代码都是运行时执行。</p><h2 id="六、延伸阅读"><a href="#六、延伸阅读" class="headerlink" title="六、延伸阅读"></a>六、延伸阅读</h2><ul><li><a href="https://www.cnblogs.com/techspace/p/6931397.html" target="_blank" rel="noopener">JAVA 反射原理</a></li><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255945147512512" target="_blank" rel="noopener">廖雪峰 Java 教程 - 反射</a></li><li><a href="https://www.geeksforgeeks.org/reflection-in-java/" target="_blank" rel="noopener">Reflection in Java</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html" target="_blank" rel="noopener">oracle reflect docs</a></li><li><a href="https://stackoverflow.com/questions/37628/what-is-reflection-and-why-is-it-useful" target="_blank" rel="noopener">What is reflection and why is it useful?</a></li><li><a href="https://dzone.com/articles/understanding-sunmiscunsafe" target="_blank" rel="noopener">Understanding sun.misc.Unsafe</a></li><li><a href="https://www.baeldung.com/java-unsafe" target="_blank" rel="noopener">Guide to sun.misc.Unsafe</a></li></ul><!--运行期类型鉴定 (RTTI)--><!--全限定名：指编译后的 class 文件在 jar 包中的路径，package 路径的 . 转换为 /-->]]></content:encoded>
      
      <comments>https://depp.wang/2020/05/05/reflection-in-spring-and-reflection-principle/#disqus_thread</comments>
    </item>
    
    <item>
      <title>造轮子：实现一个简易的 Spring IoC 容器</title>
      <link>https://depp.wang/2020/04/19/realize-a-simple-spring-ioc-container/</link>
      <guid>https://depp.wang/2020/04/19/realize-a-simple-spring-ioc-container/</guid>
      <pubDate>Sun, 19 Apr 2020 08:09:37 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://depp.wang&quot;&gt;DeppWang&lt;/a&gt;、&lt;a href=&quot;https://depp.wang/2020/04/19/realize-a-simple-spring-ioc-container&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-04-19-110638.jpg&quot; alt=&quot;source:https://fernandofranzini.wordpress.com/&quot;&gt;&lt;/p&gt;
&lt;p&gt;我通过实现一个简易的 Spring IoC 容器，算是真正入门了 Spring 框架。本文是对实现过程的一个总结提炼，&lt;strong&gt;需要配合源码阅读&lt;/strong&gt;，&lt;a href=&quot;https://github.com/DeppWang/litespring&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源码地址&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;结合本文和源码，你应该可以学到：Spring 的原理和 Spring Boot 的原理。&lt;/p&gt;
&lt;p&gt;Spring 框架是 Java 开发的，Java 是面向对象的语言，所以 Spring 框架本身有大量的抽象、继承、多态。对于初学者来说，光是理清他们的逻辑就很麻烦，我摒弃了那些包装，只实现了最本质的功能。代码不是很严谨，但只为了理解 Spring 思想却够了。&lt;/p&gt;
&lt;p&gt;下面正文开始。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>作者：<a href="https://depp.wang">DeppWang</a>、<a href="https://depp.wang/2020/04/19/realize-a-simple-spring-ioc-container">原文地址</a></p></blockquote><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-04-19-110638.jpg" alt="source:https://fernandofranzini.wordpress.com/"></p><p>我通过实现一个简易的 Spring IoC 容器，算是真正入门了 Spring 框架。本文是对实现过程的一个总结提炼，<strong>需要配合源码阅读</strong>，<a href="https://github.com/DeppWang/litespring" target="_blank" rel="noopener">源码地址</a>。</p><p>结合本文和源码，你应该可以学到：Spring 的原理和 Spring Boot 的原理。</p><p>Spring 框架是 Java 开发的，Java 是面向对象的语言，所以 Spring 框架本身有大量的抽象、继承、多态。对于初学者来说，光是理清他们的逻辑就很麻烦，我摒弃了那些包装，只实现了最本质的功能。代码不是很严谨，但只为了理解 Spring 思想却够了。</p><p>下面正文开始。</p><a id="more"></a><h2 id="零、Spring-的作用"><a href="#零、Spring-的作用" class="headerlink" title="零、Spring 的作用"></a>零、Spring 的作用</h2><p>在没有 Spring 框架的远古时代，我们业务逻辑一般长这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PetStoreService</span> </span>&#123;</span><br><span class="line">    AccountDao accountDao = <span class="keyword">new</span> AccountDao();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PetStoreService petStoreService = <span class="keyword">new</span> PetStoreService();</span><br></pre></td></tr></table></figure><p>到处都是  <strong>new</strong> 关键字，需要开发人员显式的使用 new 关键字来创建对象（实例）。这样有很多弊端，如，创建的对象太多（多次创建多个对象），耦合性太强（默认 new），等等。</p><p>有个叫 <a href="https://en.wikipedia.org/wiki/Rod_Johnson_(programmer)" target="_blank" rel="noopener">Rod Johnson</a> 老哥对此很不爽，就开发了一个叫 <a href="https://spring.io/" target="_blank" rel="noopener">Spring</a> 的框架，就是为了干掉 new 关键字（哈哈，我杜撰的，只是为了说明 Spring 的作用）。</p><p>有了 Spring 框架，<strong>由框架来新建对象，管理对象，并处理对象之间的依赖</strong>，我们程序员就可以专注于业务逻辑（专心搬砖），不用关心对象的创建了。我们来看看 Spring 框架是如何实现的吧。</p><p>注：以下 Spring 框架简写为 Spring</p><p>本节源码对应：<strong>v0</strong></p><h2 id="一、实现「实例化-Bean-」"><a href="#一、实现「实例化-Bean-」" class="headerlink" title="一、实现「实例化 Bean 」"></a>一、实现「实例化 Bean 」</h2><p>首先，我们需要标记哪些类交给 Spring 管理，可以借助 xml 标记，将其标记为 <code>&lt;bean&gt;</code>：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--petstore-v1.xml--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"petStore"</span> <span class="attr">class</span>=<span class="string">"org.deppwang.litespring.v1.service.PetStoreService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountDao"</span> <span class="attr">class</span>=<span class="string">"org.deppwang.litespring.v1.dao.AccountDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring 的第一步操作就是根据 xml 的标记来实例化类，在 Spring 中，我们管类叫 Bean，所以实例化类也可以称为实例化 Bean。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BeanIocContainer iocContainer = <span class="keyword">new</span> BeanIocContainer(<span class="string">"petstore-v1.xml"</span>);</span><br></pre></td></tr></table></figure><p>Spring 如何根据 xml 配置来实现实例化类？</p><p>大致可以分为三步（配合源码 <strong>v1</strong> 阅读）：</p><ol><li><p>从 xml 配置文件获取 Bean 信息：id、beanClassName（路径），将其作为 BeanDefinition（Bean 定义类）的属性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BeanDefinition bd = <span class="keyword">new</span> BeanDefinition(id, beanClassName);</span><br></pre></td></tr></table></figure></li><li><p>使用一个 Map 存放所有 BeanDefinition，此时 Spring 本质上是一个 Map，存放 BeanDefinition</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">64</span>);</span><br></pre></td></tr></table></figure></li><li><p>当获取 Bean 实例时，通过类加载器，根据路径，得到其类对象，通过类对象利用<strong>反射</strong>创建 Bean 实例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> Thread.currentThread().getContextClassLoader().loadClass(bd.getBeanClassName()).newInstance();</span><br></pre></td></tr></table></figure></li></ol><p>关于类加载和反射，前者可以看看<a href="https://book.douban.com/subject/34907497/" target="_blank" rel="noopener">《深入理解 Java 虚拟机》</a>第 7 章，后者可以看看 <a href="https://depp.wang/2020/04/29/reflection-in-spring-and-reflection-principle/">Spring 中的反射与反射的原理</a>。本文只学习 Spring，这两个知识点不做深入讨论。</p><p>本节源码对应：<strong>v1</strong></p><h2 id="二、实现「填充属性（依赖注入）」"><a href="#二、实现「填充属性（依赖注入）」" class="headerlink" title="二、实现「填充属性（依赖注入）」"></a>二、实现「填充属性（依赖注入）」</h2><!--使用 Spring 时，我们希望只需要声明一下就能使用--><!--直接 new 改为依赖注入--><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PetStoreService</span> </span>&#123;</span><br><span class="line">    AccountDao accountDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当不默认 new 时，实现实例化 Bean 后，此时成员变量（属性）还为 null：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-04-17-143303.png" alt=""></p><!--当一个 Bean 的成员变量类型是另一个 Bean 时，我们可以说一个 Bean 依赖于另一个 Bean。当不默认 new 时，就需要使用依赖注入（**D**ependency **I**njection，简称 DI）的方式设置依赖。依赖注入让属性不为 null，所以也可以称为填充属性。--><!--Spring 通过依赖注入的方式实现填充属性。--><p>此时需要通过一种方式实现让属性不为 null，我们管这一步叫填充属性。</p><p>当一个 Bean 的成员变量类型是另一个 Bean 时，我们可以说一个 Bean 依赖于另一个 Bean。所以填充属性，也可以称为依赖注入（<strong>D</strong>ependency <strong>I</strong>njection，简称 DI）。</p><p>抛开 Spring 不谈，在正常情况下，我们有两种方式实现依赖注入，1、使用构造方法；2、使用 Setter() 方法。一般使用构造方法（因为依赖可能有多个）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PetStoreService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PetStoreService</span><span class="params">(AccountDao accountDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PetStoreService petStore = <span class="keyword">new</span> PetStoreService(<span class="keyword">new</span> AccountDao()); <span class="comment">// 将依赖 new AccountDao() 注入 petStore</span></span><br></pre></td></tr></table></figure><p>Spring 也是通过这两种方式来实现依赖注入。</p><p>我们需要告诉 Spring，需要为类使用什么方式注入依赖，注入什么依赖。比如，我们想 Spring 使用构造函数的方式，注入 AccountDao 依赖。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"petStore"</span> <span class="attr">class</span>=<span class="string">"org.deppwang.litespring.v2.service.PetStoreService"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"accountDao"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring 如何根据 <code>&lt;constructor-arg&gt;</code> 来实现依赖注入？</p><p>大致也分为 3 步（配合源码 <strong>v2</strong> 阅读）：</p><ol><li><p>从 xml 中获取构造函数的参数实例的 id，存放到 BeanDefinition 的 constructorArguments 中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bd.getConstructorArgumentValues().add(argumentName);</span><br></pre></td></tr></table></figure></li><li><p>通过反射得到 PetStoreService 所有的构造函数（Constructor 对象），找到参数跟 constructorArguments 一致的 Constructor 对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] candidates = beanClass.getDeclaredConstructors();</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>通过 constructorArguments 获取到所有参数实例，再利用反射，通过 Constructor 对象实现填充属性。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> constructorToUse.newInstance(argsToUse);</span><br></pre></td></tr></table></figure></li></ol><p>基于 Setter() 方法实现依赖注入的方式跟构造方法差不多，源码中有实现，请看源码。</p><p>实际上，Spring 默认先尝试使用构造函数注入依赖，当没有配置 <code>&lt;constructor-arg&gt;</code> 时，使用 <code>&lt;property&gt;</code>。</p><p>因为 Spring 实现了依赖注入，所以我们程序员没有了创建对象的控制权，所以也被称为控制反转（<strong>I</strong>nversion <strong>o</strong>f <strong>C</strong>ontrol，简称  IoC）。因为 Spring 使用 Map 管理 BeanDefinition，我们也可以将 Spring 称为 IoC 容器。</p><p>本节源码对应：<strong>v2</strong></p><h2 id="三、使用「单例模式、工厂方法模式」"><a href="#三、使用「单例模式、工厂方法模式」" class="headerlink" title="三、使用「单例模式、工厂方法模式」"></a>三、使用「单例模式、工厂方法模式」</h2><p>前面两步实现了获取 Bean 实例时创建 Bean 实例，但 Bean 实例经常使用，不能每次都新创建。其实在 Spring 中，一个 Bean 只对应一个 Bean 实例，这需要使用单例模式。</p><blockquote><p>单例模式：一个类有且只有一个实例</p></blockquote><p>Spring 使用类对象创建 Bean 实例，是如何实现单例模式的？</p><p>Spring 其实使用一个 Map 存放所有 Bean 实例。创建时，先看 Map 中是否有 Bean 实例，没有就创建；获取时，直接从 Map 中获取。这种方式能保证一个类只有一个 Bean 实例。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">64</span>);</span><br></pre></td></tr></table></figure><p>因为存放 Bean 实例也是 Map，这是除 beanDefinitionMap 外，Spring 称为 IoC 容器的另一个原因。</p><p>我们将创建对象的控制权交给 Spring（BeanIocContainer.java），我们可以认为 BeanIocContainer.java 是一个创建对象的工厂（专门生产对象），也可以称为简单工厂。<strong>它实现了创建对象和使用对象分离</strong>。</p><p>Spring 为了使用不同的方式均可实现实例化 Bean，不能只是简单工厂，需要使用工厂方法模式。</p><blockquote><p>工厂方法模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。来源：《Head First 设计模式》</p></blockquote><p>简单的理解就是：将创建对象的方法抽象，作为一个工厂方法。</p><p>这里的「让子类决定实例化哪一个类」，也可以看成让子类决定如何实现实例化类。</p><p>我们可以把工厂方法模式理解为简单工厂的升级版，可通过子类实现多种方式创建对象，是一种简单工厂的「多态」。</p><p>早期 Spring 使用 Bean 的策略是用到时再实例化所用 Bean，杰出代表是 XmlBeanFactory。后期为了实现更多的功能，新增了 ApplicationContext，初始化时就实例化所有 Bean，两者都继承于 BeanFactory 接口。</p><!--两者的区别：ApplicationContext 初始化时就实例化所有 Bean，BeanFactory 用到时再实例化所用 Bean。--><!--这里创建对象的工厂方法是**构造方法**。--><p>实现：将 BeanIocContainer 修改为 BeanFactory 接口，只提供 getBean() 方法。实现不同的子类对应不同的方式实例化 Bean。</p><p>Spring 使用 <strong>getBean()</strong> 作为工厂方法。getBean() 包含创建对象的方法。</p><p>本节源码对应：<strong>v3</strong></p><h2 id="四、实现「注解」"><a href="#四、实现「注解」" class="headerlink" title="四、实现「注解」"></a>四、实现「注解」</h2><p>在业务开发中，如果每个业务类均设置构造函数，并且需要在 xml 中配置，那么就太繁琐，还容易出错。Spring 从 2.5<sup><a href="https://www.tutorialspoint.com/spring/spring_annotation_based_configuration.htm" target="_blank" rel="noopener">ref</a></sup> 开始，新增了注解，可以使用注解来替代业务类的 xml 配置和构造函数。</p><ul><li>使用 @Component 注解代替 <code>&lt;bean&gt;</code></li><li>使用 @Autowired 注解代替 <code>&lt;constructor-arg&gt;</code> + 构造函数。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PetStoreService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring 如何根据注解来实现实例化 Bean 和依赖注入？或者说，这两个注解起了什么作用？</p><p>1、@Component 用于生成 BeanDefinition，实现原理（配合源码 <strong>v4</strong> 阅读）：</p><ul><li><p>根据 <code>&lt;context:component-scan&gt;</code> 指定路径，找到路径下所有包含 @Component 注解的 Class 文件，作为 BeanDefinition</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String basePackagesStr = ele.attributeValue(<span class="string">"base-package"</span>);</span><br></pre></td></tr></table></figure></li><li><p>如何判断 Class 是否有 @Component：利用字节码技术，获取 Class 文件中的元数据（注解），判断元数据中是否有 @Componet</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">annotationMetadata.hasAnnotation(Component.class.getName())</span><br></pre></td></tr></table></figure></li></ul><p>2、@Autowired 用于依赖注入，实现原理（配合源码 <strong>v4</strong> 阅读）：</p><ul><li><p>通过反射，得到所有的属性（Field 对象），查看 Field 对象中是否有 @Autowired 类型的注解，有，则使用反射实现依赖注入</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field[] fields = bean.getClass().getDeclaredFields();</span><br><span class="line">field.set(bean, getBean(field.getName()));</span><br></pre></td></tr></table></figure></li><li><p>注意：使用 @Autowired 时，既没有使用构造方法，也没有使用 Setter() 方法</p></li></ul><p>@Component + @Autowired 实现 Spring 对业务类的管理。被 @Component + @Autowired  修饰的业务类算是一种特殊的 Bean。</p><p>至此，我们还是在需要通过配置文件来实现组件扫描。有没有完全不使用配置文件的方式？有！</p><p>我们可以使用 @Configuration 替代配置文件，并使用 @ComponentScan 来替代配置文件的  <code>&lt;context:component-scan&gt;</code> 。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 将类标记为 @Configuration，代表这个类是相当于一个配置文件</span></span><br><span class="line"><span class="meta">@ComponentScan</span> <span class="comment">// ComponentScan 扫描 PetStoreConfig.class 所在路径及其所在路径所有子路径的文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PetStoreConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(PetStoreConfig.class);</span><br><span class="line">        PetStoreService userService = context.getBean(PetStoreService.class);</span><br><span class="line">        userService.getAccountDao();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用注解其实跟使用 xml 配置文件一样，目的是将配置类作为入口，实现扫描组件，将其加载进 IoC 容器中的功能。</p><p>AnnotationConfigApplicationContext 是专为针对配置类的启动类。其实现机制，可以 Google 查阅。</p><p>前面说：在 Spring 中，我们管类叫 Bean。其实不完全正确，类要称为 Bean，需要满足一个条件：</p><ul><li>当有成员变量时，要么有 @Autowired 注解，要么有对应的构造函数或者 Setter() 方法</li></ul><p>即可以被 Spring 管理的类，称为 Bean。</p><p>名词解释：</p><ul><li>Component：组件</li><li>Autowired：自动装配</li></ul><p>本节源码对应：<strong>v4</strong></p><h2 id="五、注解-Bean"><a href="#五、注解-Bean" class="headerlink" title="五、注解 @Bean"></a>五、注解 @Bean</h2><p>只要类是一个 Bean，就可以由 Spring 管理。</p><p>业务类为了减少配置，可使用 @Component + @Autowired 实现依赖注入。</p><p>将其他 Bean 注入容器时，虽然可以通过 xml 实现，但仍然比较麻烦，Spring 提供了一个注解 @Bean，当一个方法标记为 @Bean 时，它的返回值将被注入容器。</p><p>举个栗子：我们可以将一个线程池 Executor 实例注入容器，再 @Autowired 使用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">sendMessageExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExecutorService executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">2</span>,</span><br><span class="line">                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">1024</span>), <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ExecutorService service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这如果用 xml 来实现，就比较麻烦了，还不直观。</p><!--如果 Bean 没有构造函数或者 Setter 方法，需要引用 @Autowired--><p>注意：@Bean 需要和 @Configuration 一起使用</p><p>本节源码对应：<strong>v5</strong></p><!--如果一个标记为 @Bean 的函数需要使用另一个类，那么另一个类也要注入容器？除非它本身也作为 Bean--><h2 id="六、Spring-Boot-原理"><a href="#六、Spring-Boot-原理" class="headerlink" title="六、Spring Boot 原理"></a>六、Spring Boot 原理</h2><p>前面说到了 @Configuration 和 @ComponentScan，这就不得不提 Spring Boot。因为 Spring Boot 就使用了  @Configuration 和 @ComponentScan，你可以点开 @SpringBootApplication 看到。</p><p>我们发现，Spring Boot 启动时，并没有使用 AnnotationConfigApplicationContext 来指定启动某某 Config 类。这是因为它使用了 @EnableAutoConfiguration 注解。</p><p>Spring Boot 利用了 @EnableAutoConfiguration 来自动加载<strong>启动类路径（base-package）</strong>下标识为 @Configuration 的配置类到容器中。有时项目引入 jar 包的部分类也需要注入容器，如果引用 jar 包与启动类路径不一致，就需要一个额外标识，一个名为 spring.factories 文件。jar 包将需要自动加载的配置类放在 spring.factories 中，Spring Boot 将自动加载 jar 包 spring.factories 中的配置类。spring.factories 需放置于META-INF 下。</p><p>关于 @EnableAutoConfiguration 的详细工作原理，可以看看<a href="http://tengj.top/2017/03/09/springboot3/" target="_blank" rel="noopener">这篇文章</a></p><p>如 Spring Boot 项目启动时，autocofigure 包中将被自动加载到容器的（部分）配置类如下：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-04-05-092624.png?ynotemdtimestamp=1587214457308" alt=""></p><p>以上也是 Spring Boot 的原理。</p><h3 id="Starter-包"><a href="#Starter-包" class="headerlink" title="Starter 包"></a>Starter 包</h3><p>在 Spring Boot 中，我们引入的部分 jar 包一般包含一个字段，<strong>starter</strong>，我们叫 starter 包。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-04-18-151532.png" alt=""></p><p>标识为 starter（启动器），可以看作是一个依赖总集，用于方便引用依赖。starter 包不需要额外配置，相关 Bean 会自动装配到容器。这是如何实现自动装配 Bean 呢。其实很简单，也是利用 spring.factories + 配置类。</p><p>1、starter 包包含自己的 spring.factories。如 spring-cloud-starter-eureka-server：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-04-18-134518.png" alt=""></p><p>如 druid-spring-boot-starter：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-04-19-085235.png" alt=""></p><p>2、将相关配置类放在 autocofigure 中，由 autoconfigure 来自动装配。如 spring-boot-starter-jdbc：</p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-10-15-074720.png" alt="image-20201015154719951" style="zoom:67%;"><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-10-15-074801.png" alt="image-20201015154801013"></p><p>如 spring-boot-starter-amqp：</p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-10-15-074258.png" alt="image-20201015154258123" style="zoom:50%;"><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-10-15-074549.png" alt="image-20201015154548874"></p><p>一般来说，我们在 application.properties(application.yml) 配置的数据将由相应配置类读取。</p><p>有时候我们还需要自定义 starter 包，比如在 Spring Cloud 中，当某个应用要调用另一个应用的代码时，要么调用方使用 HTTP，要么将被调用方自定义为 starter 包，让调用方依赖引用，再 @Autowired 使用。此时需要在被调用方设置配置类和 spring.factories：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderAppConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># spring.factories</span></span><br><span class="line"><span class="comment"># Auto Configure</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span></span><br><span class="line"><span class="string">com.amy.cloud.amycloudact.ProviderAppConfiguration</span></span><br></pre></td></tr></table></figure><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-04-18-111026.png" alt=""></p><p>当然，你也可以把这两个文件放在调用方（此时要指定扫描路径），但一般放在被调用方。注意：如果你两个应用的 base-package 路径一样，那么可以不用这一步。</p><!--[Starter 包官方介绍](https://docs.spring.io/spring-boot/docs/1.2.1.RELEASE/reference/htmlsingle/#using-boot-starter-poms)--><p>说了 Spring Boot，那么在 Spring MVC，如何将引入 jar 包的组件注入容器？</p><ul><li>跟扫描本项目包一样，在 xml ，增加引入 jar 包的扫描路径：</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"引入 jar 包的 base-package"</span> /&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>嗯，本节没有源码</p><h2 id="七、结语"><a href="#七、结语" class="headerlink" title="七、结语"></a>七、结语</h2><p>Spring 的原理离不开两个关键词：反射和注解。</p><ul><li>反射：在创建 Bean 实例和依赖注入是都需要使用反射。</li><li>注解：使用注解可大大提升代码可阅读性，降低复杂度。注解本质上是作为一个标识，获取注解时需要使用字节码技术。</li></ul><p>现在我们一般很少使用 xml 来设置 bean，但了解了 xml 可以更好的理解 Spring 注解的原理。</p><p>来个注解小结：</p><ul><li>@Component 作为组件标识，代表需要 Spring 管理</li><li>@Autowired 用于判断是否需要依赖注入，代替构造函数</li><li>@ComponentScan 指定组件扫描路径，不指定即为当前路径</li><li>@Configuration 代表配置类，作为 Spring 寻找需要被管理 Bean 的入口</li><li>@Bean 实现将任意 Bean 注入容器</li><li>@EnableAutoConfiguration 实现自动加载配置类到容器</li></ul><p>以上实现了一个简易的 Spring IoC 容器，顺便说了一下 Spring Boot 原理。Spring 还有很多重要功能，如：处理对象之间的依赖、管理 Bean 生命周期、AOP 的实现，等等。</p><p>全文完。</p>]]></content:encoded>
      
      <comments>https://depp.wang/2020/04/19/realize-a-simple-spring-ioc-container/#disqus_thread</comments>
    </item>
    
    <item>
      <title>你真的会写单例模式吗</title>
      <link>https://depp.wang/2020/04/10/singleton-pattern/</link>
      <guid>https://depp.wang/2020/04/10/singleton-pattern/</guid>
      <pubDate>Fri, 10 Apr 2020 08:09:37 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://depp.wang&quot;&gt;DeppWang&lt;/a&gt;、&lt;a href=&quot;https://depp.wang/2020/04/10/singleton-pattern/&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;又一篇一抓一大把的博文，可是你真的的搞懂了吗？点开看看，事后，你也来一篇。。。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;人生在世，谁不面试。单例模式：一个搞懂不加分，不搞懂减分的知识点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-04-10-143047.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;单例模式是面试中非常喜欢问的了，我们往往自认为已经完全理解了，没什么问题了。但要把它手写出来的时候，可能出现各种小错误，下面是我总结的快速准确的写出单例模式的方法。&lt;/p&gt;
&lt;p&gt;单例模式有各种写法，什么「双重检锁法」、什么「饿汉式」、什么「饱汉式」，总是记不住、分不清。这就对了，人的记忆力是有限的，我们应该记的是最基本的单例模式怎么写。&lt;/p&gt;
&lt;p&gt;单例模式：一个类有且只能有一个对象（实例）。单例模式的 3 个要点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;外部不能通过 new 关键字（构造函数）的方式新建实例，所以构造函数为私有：&lt;code&gt;private Singleton(){}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;只能通过类方法获取实例，所以获取实例的方法为公有、且为静态：&lt;code&gt;public static Singleton getInstance()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;实例只能有一个，那只能作为类变量的「数据」，类变量为静态 （另一种记忆：静态方法只能使用静态变量）：&lt;code&gt;private static Singleton instance&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>作者：<a href="https://depp.wang">DeppWang</a>、<a href="https://depp.wang/2020/04/10/singleton-pattern/">原文地址</a></p></blockquote><p>又一篇一抓一大把的博文，可是你真的的搞懂了吗？点开看看，事后，你也来一篇。。。</p><blockquote><p>人生在世，谁不面试。单例模式：一个搞懂不加分，不搞懂减分的知识点</p></blockquote><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-04-10-143047.jpg" alt="img"></p><p>单例模式是面试中非常喜欢问的了，我们往往自认为已经完全理解了，没什么问题了。但要把它手写出来的时候，可能出现各种小错误，下面是我总结的快速准确的写出单例模式的方法。</p><p>单例模式有各种写法，什么「双重检锁法」、什么「饿汉式」、什么「饱汉式」，总是记不住、分不清。这就对了，人的记忆力是有限的，我们应该记的是最基本的单例模式怎么写。</p><p>单例模式：一个类有且只能有一个对象（实例）。单例模式的 3 个要点：</p><ol><li>外部不能通过 new 关键字（构造函数）的方式新建实例，所以构造函数为私有：<code>private Singleton(){}</code></li><li>只能通过类方法获取实例，所以获取实例的方法为公有、且为静态：<code>public static Singleton getInstance()</code></li><li>实例只能有一个，那只能作为类变量的「数据」，类变量为静态 （另一种记忆：静态方法只能使用静态变量）：<code>private static Singleton instance</code></li></ol><a id="more"></a><h2 id="一、最基础、最简单的写法"><a href="#一、最基础、最简单的写法" class="headerlink" title="一、最基础、最简单的写法"></a>一、最基础、最简单的写法</h2><p>类加载的时候就新建实例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Singleon using static initialization in Java"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here is how to access this Singleton class</span></span><br><span class="line">Singleton.getInstance().show();</span><br></pre></td></tr></table></figure><p>当执行 Singleton.getInstance() 时，类加载器加载 Singleton.class 进虚拟机，虚拟机在方法区（元数据区）为类变量分配一块内存，并赋值为空。再执行类构造器 <code>&lt;client&gt;()</code> 方法，新建实例指向类变量 instance。这个过程在类加载阶段执行，并由虚拟机保证线程安全。所以执行 getInstance() 前，实例就已经存在，所以 getInstance() 是线程安全的。</p><p>很多博文说 instance 还需要声明为 final，其实不用。final 的作用在于不可变，使引用 instance 不能指向另一个实例，保证变量可见性（线程安全）。这里 instance 不会指向其他实例，用不上。当然，加上也没问题。</p><p>看到这里，单例模式的写法你已经学到了。后面的是加餐，可以选择不看了。</p><!--// final 修饰的基本数据类型，在编译期时，初始化数据放在常量池--><p>这个写法有一个不足之处，就是如果需要通过参数设置实例，则无法做到。举个栗子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能设置 name！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Singleon using static initialization in Java"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here is how to access this Singleton class</span></span><br><span class="line">Singleton.getInstance(<span class="string">"test"</span>).show();</span><br></pre></td></tr></table></figure><h2 id="二、可通过参数设置实例的写法"><a href="#二、可通过参数设置实例的写法" class="headerlink" title="二、可通过参数设置实例的写法"></a>二、可通过参数设置实例的写法</h2><p>考虑到这种情况，就在调用 getInstance() 方法时，再新建实例。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">",hashcode: "</span> + instance.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton.getInstance(<span class="string">"test"</span>).show();</span><br></pre></td></tr></table></figure><p>这里加了 <code>synchronized</code> 关键字，能保证线程安全（只会生成一个实例），但效率不高。因为实例创建成功后，再获取实例时就不用加锁了。</p><p>当不加 synchronized 时，会发生什么：</p><p>instance 是类的变量，类存放在方法区（元数据区），元数据区线程共享，所以类变量 instance 线程共享，类变量也是在主内存中。线程执行 getInstance() 时，在自己工作内存新建一个栈帧，将主内存的 instance 拷贝到工作内存。多个线程并发访问时，都认为 <code>instance == null</code>，就将新建多个实例，那单例模式就不是单例模式了。</p><p>测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                Singleton.getInstance(<span class="string">"test"</span>).show();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、改良版加锁的写法"><a href="#三、改良版加锁的写法" class="headerlink" title="三、改良版加锁的写法"></a>三、改良版加锁的写法</h2><p>实现只在创建的时候加锁，获取时不加锁。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么要判断两次：</strong></p><p>多个线程将 instance 拷贝进工作内存，即多个线程读取到 instance == null。虽然每次只有一个线程进入 synchronized 方法，当进入线程成功新建了实例，synchronized 保证了可见性（在 unlock 操作前将变量写回了主内存），此时 instance 不等于 null 了。但其他线程已经执行到 synchronized 这里了，某个线程就又会进入 synchronized 方法，如果不判断一次，就会再次新建一个实例。</p><p><strong>为什么要用 volatile 修饰 instance：</strong></p><p>synchronized 已经可以实现原子性、可见性、有序性，其中实现原子性：一次只有一个线程执行同步块的代码。但计算机为了提升运行效率，会指令重排序。</p><p>代码 <code>instance = new Singleton();</code> 会被计算机拆为 3 步执行。</p><ul><li>A：在堆中分配一块内存空间</li><li>B：在内存空间位置新建一个实例</li><li>C：将引用指向实例，即，引用存放实例的内存空间地址</li></ul><p>线程可能按 ACB 执行，如果 instance 都在 synchronized 里面，怎么重排序都没啥问题。问题出现在还有 instance 在 synchronized 外边，因为此时外边一群饿狼（线程），就在等待一个 instance 这块肉不为 null。</p><p>模拟一下指令重排序的出错场景：多线程环境下，正好一个线程，在同步块中按 ACB 执行，执行到 AC 时（并将 instance 写回了主内存），另一个线程执行第一个判断时，从主内存拷贝了最新的 instance，认为 instance 不为空，返回 instance，但此时 instance 还没被正确初始化，所以出错。</p><p>volatile 修饰 instance 时，虚拟机在 ACB 后添加一个 <code>lock</code> 指令，lock 指令之前的操作执行完成后，后面的操作才能执行。只有当 ACB 都执行完了之后，其他线程才能读取 instance 的值，即：只有当写操作完成之后，读操作才能开始。这也是 Java 虚拟机规范的其中一条先行发生原则：对 volatile 修饰的变量，读操作，必须等写操作完成。</p><p>所以用 volatile 修饰 instance，是使用它的禁止指令重排序特性：禁止读指令重排序到写指令之前。（它禁止不了 lock 指令前的指令重排序。）</p><p>你可能认为上面的解释太复杂，不好理解。对，确实比较复杂，看不懂，下次问到再看吧。</p><h2 id="四、其他非主流写法"><a href="#四、其他非主流写法" class="headerlink" title="四、其他非主流写法"></a>四、其他非主流写法</h2><p>枚举写法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当面试官让我写一个单例模式，我总是觉得写这个好像有点另类。</p><p>静态内部类写法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE; </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个写法还是比较有逼格的，但稍不注意就容易出错。</p><h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><p>单例模式主要为了节省内存开销，Spring 容器的 Bean 就是通过单例模式创建出来的。</p><p>单例模式没写出来，那也没啥事，因为那下一个问题你也不一定能答出来 :-)。</p><!--单例模式不会写，也不影响你称为大佬，哈哈。--><h2 id="六、延伸阅读"><a href="#六、延伸阅读" class="headerlink" title="六、延伸阅读"></a>六、延伸阅读</h2><ul><li><a href="http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/" target="_blank" rel="noopener">如何正确写出单例模式</a></li><li><a href="http://javarevisited.blogspot.com/2012/12/how-to-create-thread-safe-singleton-in-java-example.html" target="_blank" rel="noopener">How to create thread safe Singleton in Java</a></li><li><a href="https://javarevisited.blogspot.com/2012/07/why-enum-singleton-are-better-in-java.html" target="_blank" rel="noopener">Why Enum Singleton are better in Java</a></li><li><a href="https://stackoverflow.com/questions/228164/on-design-patterns-when-should-i-use-the-singleton" target="_blank" rel="noopener">On design patterns: When should I use the singleton? </a></li></ul><!--![个人公众号](https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-04-10-150424.png)-->]]></content:encoded>
      
      <comments>https://depp.wang/2020/04/10/singleton-pattern/#disqus_thread</comments>
    </item>
    
    <item>
      <title>随意修改你文章的 url 吧，一个 js 解决原 url 不能访问的问题</title>
      <link>https://depp.wang/2020/03/27/redirect-404-url-by-js/</link>
      <guid>https://depp.wang/2020/03/27/redirect-404-url-by-js/</guid>
      <pubDate>Fri, 27 Mar 2020 20:48:37 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://depp.wang&quot;&gt;DeppWang&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;阅读提示：此文适用于有自己博客的同学。&lt;/p&gt;
&lt;p&gt;昨天在公众号分享了一篇在 &lt;a href=&quot;https://depp.wang/2020/03/26/how-to-insert-slide-in-markdown/&quot;&gt;如何在 Markdown 里面插入幻灯片&lt;/a&gt;的文章，微信公众号由于平台限制，幻灯片只能在原文里面才能看到效果，不巧，原文链接手误写错了一个单词，本来是 insert，写成了 inset。&lt;/p&gt;
&lt;figure class=&quot;highlight livecodeserver&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;https&lt;/span&gt;://depp.wang/&lt;span class=&quot;number&quot;&gt;2020&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;03&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;26&lt;/span&gt;/how-&lt;span class=&quot;built_in&quot;&gt;to&lt;/span&gt;-inset-slide-&lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;-markdown/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;应该是&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;https&lt;/span&gt;://depp.wang/&lt;span class=&quot;number&quot;&gt;2020&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;03&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;26&lt;/span&gt;/how-&lt;span class=&quot;built_in&quot;&gt;to&lt;/span&gt;-insert-slide-&lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;-markdown/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;作为一个强迫症患者，不能忍受这样的问题。可一旦我修改了原文链接，公众号这边要么删了重发，要么来个留言，说原文链接已经修改。两种方式可以解决问题，但是不爽。&lt;/p&gt;
&lt;p&gt;除了像我手误写错链接单词的情况，&lt;strong&gt;很多时候，我们文章修改题目后，如果想修改 url（url 是文章题目的英文），就会面临原 url 失效的问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你也有上面这种困扰，那么可以看看我的解决思路。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>作者：<a href="https://depp.wang">DeppWang</a></p></blockquote><p>阅读提示：此文适用于有自己博客的同学。</p><p>昨天在公众号分享了一篇在 <a href="https://depp.wang/2020/03/26/how-to-insert-slide-in-markdown/">如何在 Markdown 里面插入幻灯片</a>的文章，微信公众号由于平台限制，幻灯片只能在原文里面才能看到效果，不巧，原文链接手误写错了一个单词，本来是 insert，写成了 inset。</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="keyword">https</span>://depp.wang/<span class="number">2020</span>/<span class="number">03</span>/<span class="number">26</span>/how-<span class="built_in">to</span>-inset-slide-<span class="keyword">in</span>-markdown/</span><br><span class="line">应该是</span><br><span class="line"><span class="keyword">https</span>://depp.wang/<span class="number">2020</span>/<span class="number">03</span>/<span class="number">26</span>/how-<span class="built_in">to</span>-insert-slide-<span class="keyword">in</span>-markdown/</span><br></pre></td></tr></table></figure><p>作为一个强迫症患者，不能忍受这样的问题。可一旦我修改了原文链接，公众号这边要么删了重发，要么来个留言，说原文链接已经修改。两种方式可以解决问题，但是不爽。</p><p>除了像我手误写错链接单词的情况，<strong>很多时候，我们文章修改题目后，如果想修改 url（url 是文章题目的英文），就会面临原 url 失效的问题。</strong></p><p>如果你也有上面这种困扰，那么可以看看我的解决思路。</p><a id="more"></a><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>我的思路是这样：自定义一个 404 页面，链接失效就显示 404 页面，404 页面引入一个重定向指定 url 的 js。</p><p>重定向指定 url 的 js 的代码很简单：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">redirectUrl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> redirectObj = &#123;</span><br><span class="line">        <span class="string">"https://depp.wang/2020/03/26/how-to-inset-slide-in-markdown/"</span>: <span class="string">"https://depp.wang/2020/03/26/how-to-insert-slide-in-markdown/"</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> newUrl = redirectObj[<span class="built_in">window</span>.location.href];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> newUrl !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="built_in">window</span>.location = newUrl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">redirectUrl();</span><br></pre></td></tr></table></figure><ul><li>此 js 使用条件：显示 404 页面时，原 url 不变，不能是重定向到 404 页面</li></ul><p>404 页面引入 js，404 页面可以用<a href="https://www.qq.com/404/" target="_blank" rel="noopener">腾讯公益 404 页面</a>：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--404.html--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-type"</span> <span class="attr">content</span>=<span class="string">"text/html;charset=utf-8;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge,chrome=1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"robots"</span> <span class="attr">content</span>=<span class="string">"all"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"robots"</span> <span class="attr">content</span>=<span class="string">"index,follow"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"https://qzone.qq.com/gy/404/style/404style.css"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"https://depp.wang/redirectUrl.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> // 此处修改为你自己的 js 地址</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/plain"</span> <span class="attr">src</span>=<span class="string">"http://www.qq.com/404/search_children.js"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">charset</span>=<span class="string">"utf-8"</span> <span class="attr">homePageUrl</span>=<span class="string">"/"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">homePageName</span>=<span class="string">"回到主页"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://qzone.qq.com/gy/404/data.js"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://qzone.qq.com/gy/404/page.js"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>代码来源：<a href="http://theme-next.iissnan.com/theme-settings.html#volunteer-404" target="_blank" rel="noopener">http://theme-next.iissnan.com/theme-settings.html#volunteer-404</a></li><li>如果你使用 <a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">Hexo </a>+ <a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="noopener">Next</a>，注意 404.html 放在主题的 source 目录下。</li></ul><p>引入 js 代码时要注意路径，最好直接使用绝对路径。使用相对路径要考虑原文章所在路径与 js 文件路径之间的关联。</p><p>多说一嘴，相对路径有时候有点不好理解，需要理解相对路径常用两个符号 <code>.</code> 和 <code>..</code> 的含义：</p><ul><li><code>.</code>：一个点代表当前文件所在的文件夹（路径）。在 Linux 中，复制文件到当前路径的命令：<code>cp **/test.md .</code>。示例：<code>src=&quot;./redirectUrl.js&quot;</code>，代表引入和当前文件在同一个文件夹的 redirectUrl.js</li><li><code>..</code>：两个点代表当前文件所在的上一层文件夹（路径）。在 Linux 中，切换到上一层的命令： <code>cd ..</code></li></ul><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-27-074330.gif" alt=""></p>]]></content:encoded>
      
      <comments>https://depp.wang/2020/03/27/redirect-404-url-by-js/#disqus_thread</comments>
    </item>
    
    <item>
      <title>如何在 Markdown 里面插入幻灯片</title>
      <link>https://depp.wang/2020/03/26/how-to-insert-slide-in-markdown/</link>
      <guid>https://depp.wang/2020/03/26/how-to-insert-slide-in-markdown/</guid>
      <pubDate>Thu, 26 Mar 2020 20:48:37 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://depp.wang&quot;&gt;DeppWang&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;效果示例&lt;/strong&gt;：&lt;/p&gt;
&lt;script async class=&quot;speakerdeck-embed&quot; data-id=&quot;9780d352c95f4361bd8c6fa164554afc&quot; data-ratio=&quot;1.77777777777778&quot; src=&quot;//speakerdeck.com/assets/embed.js&quot;&gt;&lt;/script&gt;

&lt;ul&gt;
&lt;li&gt;幻灯片来自：&lt;a href=&quot;https://deepu.tech/memory-management-in-jvm/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://deepu.tech/memory-management-in-jvm/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>作者：<a href="https://depp.wang">DeppWang</a></p></blockquote><p><strong>效果示例</strong>：</p><script async class="speakerdeck-embed" data-id="9780d352c95f4361bd8c6fa164554afc" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script><ul><li>幻灯片来自：<a href="https://deepu.tech/memory-management-in-jvm/" target="_blank" rel="noopener">https://deepu.tech/memory-management-in-jvm/</a></li></ul><a id="more"></a><p><strong>使用前提</strong>：博客（网站）使用可渲染 js 脚本的 markdown 解析器，如 hexo 静态博客。我测试了一下，掘金、博客园等将 markdown 转换（解析）为 html 时，会忽略幻灯片 js 脚本。</p><p><strong>原理</strong>：在网页中内嵌一个 js 脚本。</p><p><strong>步骤</strong>： </p><ol><li>将多个图片转换为一个 PDF，可使用 <a href="https://smallpdf.com/jpg-to-pdf" target="_blank" rel="noopener">Smallpdf</a> 转换。pdf 示例：<a href="https://drive.google.com/file/d/1RJ3j2F5hh4oR-RWOBRNI5DJCcT6Oh2VE/view?usp=sharing" target="_blank" rel="noopener">presentation.pdf</a></li><li>在  <a href="https://speakerdeck.com/" target="_blank" rel="noopener">Speaker Deck</a> 上传 PDF，生成<a href="https://speakerdeck.com/deppwang/google-drive-presentation" target="_blank" rel="noopener">幻灯片</a>，点击分享按钮，获取幻灯片可内嵌（Embed）到 markdown 的 js 脚本</li><li>在 markdown 粘贴 js 脚本即可</li></ol><p><strong>js 脚本</strong>：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">class</span>=<span class="string">"speakerdeck-embed"</span> <span class="attr">data-id</span>=<span class="string">"69f38a5da6a64b4086368afca27bc7e1"</span> <span class="attr">data-ratio</span>=<span class="string">"1.77777777777778"</span> <span class="attr">src</span>=<span class="string">"//speakerdeck.com/assets/embed.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>最终效果</strong>：</p><script async class="speakerdeck-embed" data-id="69f38a5da6a64b4086368afca27bc7e1" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script>]]></content:encoded>
      
      <comments>https://depp.wang/2020/03/26/how-to-insert-slide-in-markdown/#disqus_thread</comments>
    </item>
    
    <item>
      <title>互联网协议入门</title>
      <link>https://depp.wang/2020/03/20/internet-protocol-suite-introduction/</link>
      <guid>https://depp.wang/2020/03/20/internet-protocol-suite-introduction/</guid>
      <pubDate>Fri, 20 Mar 2020 20:48:37 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://depp.wang&quot;&gt;DeppWang&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;互联网上的数据能从一台设备发送到另一台设备，整个过程由&lt;a href=&quot;https://zh.wikipedia.org/wiki/TCP/IP协议族&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;互联网协议&lt;/a&gt;（ Internet Protocol Suite）实现的。 &lt;/p&gt;
&lt;p&gt;对于互联网协议，一直一知半解。知道会分为几层，但为什么分层，分层有什么好处，都不甚理解。通过&lt;a href=&quot;www.ruanyifeng.com&quot;&gt;阮一峰&lt;/a&gt;的这两篇文章，大概有了一个初步认识，下面是我对互联网协议的理解。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;互联网协议入门（一）&lt;em&gt;阮一峰&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;互联网协议入门（二）&lt;em&gt;阮一峰&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>作者：<a href="https://depp.wang">DeppWang</a></p></blockquote><p>互联网上的数据能从一台设备发送到另一台设备，整个过程由<a href="https://zh.wikipedia.org/wiki/TCP/IP协议族" target="_blank" rel="noopener">互联网协议</a>（ Internet Protocol Suite）实现的。 </p><p>对于互联网协议，一直一知半解。知道会分为几层，但为什么分层，分层有什么好处，都不甚理解。通过<a href="www.ruanyifeng.com">阮一峰</a>的这两篇文章，大概有了一个初步认识，下面是我对互联网协议的理解。</p><ul><li><a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="noopener">互联网协议入门（一）<em>阮一峰</em></a></li><li><a href="http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html" target="_blank" rel="noopener">互联网协议入门（二）<em>阮一峰</em></a></li></ul><a id="more"></a><!--一直以来的疑惑：--><!--为什么说 Dubbo 基于 TCP 协议，Spring Cloud 基于 HTTP 协议？难道 Spring Cloud 就没有使用应用层吗？HTTP 协议没有用到 TCP 协议吗（没有经过传输层吗）？怎么好像两者是并列的关系。为什么基于 TCP 协议的 Dubbo 就更快一些呢？--><!--一个打开网页的请求如何从客户端发送到服务端，并接受到请求的，其请求包是格式是怎样的。--><!--对于手机来说，这几层体现在哪里？或者说是哪个软件实现这几层的？--><h2 id="一、五层模型"><a href="#一、五层模型" class="headerlink" title="一、五层模型"></a>一、五层模型</h2><p>我也认为将互联网协议分为五层，可以更好的去理解它，从上往下分别是：应用层、传输层、网络层、（数据）链路层（链接层）和物理层（实体层）。如果死记硬背，往往过几天就忘了，所以需要了解其原理，当我们理解了全文，让我们去说文章的名字，那还不是轻而易举吗！</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-16-091651.png" alt="图片来自阮一峰博客"></p><p>大多数文章或书籍都是从上往下来讲解互联网协议，但是个人感觉总是没有深入其理，阮一峰<strong>自下而上</strong>的讲解每一层的功能，让人记忆深刻。我也依葫芦画瓢，先自下而上分析一下每一层的功能，再结合 <a href="https://www.wireshark.org/" target="_blank" rel="noopener">Wireshark</a> 抓包工具，来稍稍看看互联网协议的真面目。</p><h3 id="1-1-层与协议"><a href="#1-1-层与协议" class="headerlink" title="1.1 层与协议"></a>1.1 层与协议</h3><p>为什么叫某某层？为什么要分层？层是什么？</p><p>我觉得层这个叫法很形象，一层一层，好像平行，各自独立。维基百科的解释是：「<strong>整个通信网络的任务，可以划分成不同的功能区块，即所谓的层级（<a href="https://zh.wikipedia.org/w/index.php?title=Layer&action=edit&redlink=1" target="_blank" rel="noopener">layer</a>）</strong>」，我们可以理解为，每一层是实现了一个功能，有不同的分工。就跟写代码一样，如果把所有功能放一起，改一行代码就可能影响全部，所以根据不同功能拆成不同的方法。我觉得叫什么不重要，可以叫应用块、应用组，等等。<strong>主要知道，每一层是为了完成一个功能就行。</strong></p><p>我们知道，每一层都有自己对应的协议（Protocol），比如，网络层有 IP 协议。那何为协议？跟这个层又有什么关联？维基百科上有这么一句话：「网络层功能由 IP 协议规定和实现，故又称 IP 层」。我们可以看出，每一层的功能其实是协议来规定和实现的。所以，协议可以理解为，<strong>有大家都遵守的规则（规定），并负责去实现这个规则。</strong></p><h2 id="二、物理层（Physcial-Layer）"><a href="#二、物理层（Physcial-Layer）" class="headerlink" title="二、物理层（Physcial Layer）"></a>二、物理层（Physcial Layer）</h2><p>我们电脑现在不用插网线就能上网（连 WIFI），但是路由器插网线了，在家里，路由器一般又需要通过一根网线连接入户光纤盒（又称为光猫），光纤盒又需要通过一根光纤连接到其他设备。电脑连接 WiFi，电脑的数据发送到路由器，是通过无线电波。所以传输数据需要物理载体，类似网线、光纤、无线电波。<strong>我们将传输数据的物理载体称为物理层（Physcial Layer）</strong>。为什么我们访问美国的网站就慢一些，因为美国网站的服务器在美国，数据通过海底光缆传输，耗时会久一些。这也是为什么很多公司要在不同城市部署服务器的原因之一吧。</p><p>数据在物理载体中传输，传输的是什么呢？<strong>是 0 和 1 组成的电信号</strong>，为什么是 0 和 1 组成的电信号呢？这个吧，姑且通过类比的方式来解释，因为计算机只能识别 0 1 二进制，所以要传输 0 和 1 组成的电信号吧。</p><!--问好脸：网速的快慢由每 1 秒能传输电信号的多少决定？--><h2 id="三、链路层（Link-Layer）"><a href="#三、链路层（Link-Layer）" class="headerlink" title="三、链路层（Link Layer）"></a>三、链路层（Link Layer）</h2><p>物理层只是一个传输载体，没有「自主意识」， 我们需要借助物理层上的<a href="https://zh.wikipedia.org/wiki/数据链路层" target="_blank" rel="noopener">链路层</a>（Link Layer），<strong>链路层的功能：将数据从一处发送到另一处</strong>，链路层在发送方和接收方都有，在发送方：链路层将数据转换为电信号，并将其发送出去；在接收方：链路层收到电信号，并将电信号转换为数据。链路层和物理层之间的关系可以这样表示：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-131628.jpg" alt=""></p><p>在<a href="https://zh.wikipedia.org/wiki/局域网" target="_blank" rel="noopener">局域网</a>内，将数据从一处发送到另一处需要使用<a href="https://zh.wikipedia.org/wiki/以太网" target="_blank" rel="noopener">以太网</a>（Ethernet）。<strong>局域网的通俗理解，连接同一个 <a href="https://zh.wikipedia.org/wiki/Wi-Fi" target="_blank" rel="noopener">WiFi</a> （路由器 Router）的设备在同一个局域网内。</strong></p><h3 id="3-1-以太网"><a href="#3-1-以太网" class="headerlink" title="3.1 以太网"></a>3.1 以太网</h3><p>以太网是一种局域网技术，它可以实现局域网内的设备通信，我们现在电脑一般连 WiFi，WiFi 可以认为是「无线以太网」。</p><p>我们可以理解为，<strong>在局域网内，链路层的功能其实是由以太网实现的</strong>（局域网外的链路层比较复杂，本文不讨论）。 局域网内的链路层和以太网的关系可以这样表示（物理层作为以太网的传输载体）：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-121930.jpg" alt=""></p><p><strong>以太网需要规定电信号的格式，以便双方解读</strong>。以太网规定一组电信号为一个数据包，叫帧（Frame），帧包含两部分，标头（Head）和数据（Data），标头包含发送方地址、接收方地址等信息，数据则是数据包的具体内容。我们一般将帧称为以太网数据包，或者<a href="https://zh.wikipedia.org/wiki/以太网帧格式" target="_blank" rel="noopener">以太帧</a>，以太帧格式类似下面这样：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-17-065355.png" alt="以太帧，图片来自阮一峰博客"></p><p>每台网络设备都有自己的网卡，<strong>以太网是将数据从一块<a href="https://zh.wikipedia.org/wiki/网卡" target="_blank" rel="noopener">网卡</a>发送到另一块网卡</strong>，每块网卡需要有自己的「身份证号」，叫 <a href="https://zh.wikipedia.org/wiki/MAC地址" target="_blank" rel="noopener">MAC 地址</a>（iPhone 手机的 MAC 地址叫无线局域网地址），由 12 个十六进制数表示：</p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-121841.jpg" style="zoom:50%;"><blockquote><p>MAC地址：（<strong>M</strong>edia <strong>A</strong>ccess <strong>C</strong>ontrol Address），直译为媒体存取控制位址，也称为局域网地址（LAN Address），<strong>以太网地址</strong>（Ethernet Address）或<strong>物理地址</strong>（Physical Address），它是一个用来确认网络设备位置的地址。</p></blockquote><p>所以以太网发送前需要知道接收方网卡的 MAC 地址，即标头的接收方地址，但正常情况下，不知道接收方 MAC 地址，需要使用 <a href="https://zh.wikipedia.org/wiki/地址解析协议" target="_blank" rel="noopener">ARP 协议</a>得到（这个本文后面解释）</p><p>假设已经知道了 MAC 地址，那么在局域网内，以太网可以根据 MAC 地址，将数据发送给对方。但如果对方没有在一个局域网内，如何发送给对方呢？此时，就需要<a href="https://zh.wikipedia.org/wiki/网络层" target="_blank" rel="noopener">网络层</a>（Network Layer）出马了！</p><hr><p>以太网在 Windows 中的体现：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-123642.jpg" alt=""></p><p>在 macOS 的体现： <a href="https://zh.wikipedia.org/wiki/PPPoE" target="_blank" rel="noopener">PPPoE</a>（英语：<strong>P</strong>oint-to-<strong>P</strong>oint <strong>P</strong>rotocol <strong>o</strong>ver <strong>E</strong>thernet），以太网上的点对点协议。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-123706.jpg" alt=""></p><h2 id="四、网络层（Network-Layer）"><a href="#四、网络层（Network-Layer）" class="headerlink" title="四、网络层（Network Layer）"></a>四、网络层（Network Layer）</h2><p>首先，我们要区分接收方是否在一个局域网，使用 MAC 地址不能区分，需要设备有另外一个地址，能代表它所处的具体是哪个网络（局域网），我们称这个地址为「<strong>网络地址</strong>」。</p><p><strong>网络层的作用，就是根据网络地址找到目的主机处于哪一个局域网</strong>。实现这一功能的协议称为网络协议，即 <a href="https://zh.wikipedia.org/wiki/网际协议" target="_blank" rel="noopener">IP 协议</a> 。网络地址用于 IP 协议，所以网络地址也可以叫它 IP 地址。<strong>注意</strong>：我们叫 IP 协议，是一种习惯，其实 IP(<strong>I</strong>nternet <strong>P</strong>rotocol) 本身就有协议的意思。</p><!--如果设备连 WiFi，WiFi 是局域网，路由器会为设备分配一个局域网 IP 地址，它只能在局域网内部使用，所以也叫内部（本地） IP。局域网有一个对外访问互联网的 IP，称为外部 IP，**一个局域网内的所有设备共用一个外部 IP 地址**。在百度输入IP，显示的 IP 就是外部 IP，在「设置->网络」中看到的 IP 是内部 IP。我们称局域网为内网，内是相对的概念，代表没有外部 IP 就不能访问。--><p>如果设备连 WiFi，路由器会为设备分配一个 IP 地址。</p><h3 id="4-1-IP-协议"><a href="#4-1-IP-协议" class="headerlink" title="4.1 IP 协议"></a>4.1 IP 协议</h3><blockquote><p><strong>IP</strong> 协议：英语全称为：<strong>I</strong>nternet <strong>P</strong>rotocol，即<strong>网络协议</strong>，也称<strong>网际协议</strong>。</p></blockquote><p>现在大部分使用的还是 IP 协议第四版，简称 IPv4，IP 地址为 32 位（4*8，二进制）。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052908.png" alt="图片来自阮一峰博客"></p><p>有了 IP 地址，网络层可以通过 IP 地址来区分是否处于一个局域网。如何根据 IP 地址判断设备是否处于同一个局域网？答案是利用<a href="https://zh.wikipedia.org/wiki/子网#网络掩码" target="_blank" rel="noopener">子网掩码</a>。IP 地址分为两部分，网络部分和主机部分，如果子网掩码为 <code>255.255.255.0</code>（二进制表示：<code>11111111.11111111.11111111.00000000</code>），表示前 24 位代表网络部分，如果两个 IP 地址前 24 位相同，则代表是在同一个局域网中。</p><h3 id="4-2-IP-数据包"><a href="#4-2-IP-数据包" class="headerlink" title="4.2 IP 数据包"></a>4.2 IP 数据包</h3><p>数据经过网络层，IP 协议为数据加上包含发送方 IP 地址和接收方 IP 地址的标头，包装为 IP 数据包：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-17-134735.png" alt="图片来自阮一峰博客"></p><p>IP 数据包到达链路层时，直接作为作为以太帧的数据部分，嵌入以太帧。此时的以太帧的格式如下：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-17-134810.png" alt="图片来自阮一峰博客"></p><p>如果通过子网掩码判断接收方在一个局域网，就通过以太网发送，此时需要得到其 MAC 地址，前面说，需要 ARP 协议得到其 MAC 地址，何为 ARP 协议？</p><h3 id="4-3-ARP-协议"><a href="#4-3-ARP-协议" class="headerlink" title="4.3 ARP 协议"></a>4.3 ARP 协议</h3><p>ARP 协议，英语全称为：<strong>A</strong>ddress <strong>R</strong>esolution <strong>P</strong>rotocol，即地址解析协议，是一种通过 IP 地址得到 MAC 地址的协议。默认情况，发送方知道接收方的 IP 地址（通过 <a href="https://zh.wikipedia.org/wiki/域名系统" target="_blank" rel="noopener">DNS</a> 得到，这个又后面解释），所以发送方使用「广播」（broadcasting）的方式给当前局域网所有主机发送一个以太帧，包含对方的 IP 地址，对方 MAC 地址设为 <code>ff:ff:ff:ff:ff:ff</code>，接收方根据接收者 IP 地址判断自己是否为接收者，是，就发送一个数据包告诉对方自己的 MAC 地址，不是，就丢弃这个包。</p><p>通过这种方式，发送方就可以通过接收方的 IP 地址得到 MAC 地址。</p><p>如果通过子网掩码判断接收方不在一个局域网，通过 APR 协议就得不到对方的 MAC 地址，那就要使用<a href="https://zh.wikipedia.org/wiki/路由" target="_blank" rel="noopener">路由</a>（Route）的方式发送了。</p><h3 id="4-4-路由"><a href="#4-4-路由" class="headerlink" title="4.4 路由"></a>4.4 路由</h3><p>路由，简单来说，就是得到路由器的 MAC 地址，数据先发送到<a href="https://zh.wikipedia.org/wiki/路由器" target="_blank" rel="noopener">路由器</a>（Router），由路由器来发送下一个路由器，通过一系列路由中转，最后发给目标主机。</p><!--路由器往外发送时，使用的是外部 IP（互联网 IP）。使用外部 IP 才能和互联网通信，外部 IP 是名片--><p>其实就像发送快递一样，在快递上写上收件人的地址，由快递点发送给下一个中转站，再中转，最后收件人收到快递。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-030924.png" alt=""></p><p>一个简单的路由器，需要实现 IP 协议和链路层协议。</p><p>如果把上面的过程说的仔细一点，以太网是将以太帧发送给路由器链路层，路由器链路层将数据包发送给路由器网络层，路由器有一个路由表，网络层在路由表找到跟当前路由器相连的、离目的主机最近的路由器，路由器通过 ARP 协议，得到下一个路由器的 MAC 地址，让路由器链路层根据 MAC 地址，发送给下一个路由器。通过一系列中转，来到目的主机所在的路由器。使用同样的方式，通过以太网将以太帧发送给目的主机。整个过程大概是这样：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-030834.png" alt=""></p><p>我们常说，网络层负责寻址和路由，寻址就是寻找最近的 IP 地址，路由就是找到最近的路由 MAC 地址（我这么理解，不一定正确）。我们可以理解为：整个通信过程中的网络层负责寻址和路由，发送方的网络层其实负责它自己的寻址和路由。</p><!--前面说，局域网内的链路层是由以太网实现的。那么局域网外的后链路层呢？是通过骨干网等实现。--><h2 id="五、传输层（Transport-Layer）"><a href="#五、传输层（Transport-Layer）" class="headerlink" title="五、传输层（Transport Layer）"></a>五、传输层（Transport Layer）</h2><p>网络层和链路层实现了互联网任意两台主机之间的网络通信，此时还有两个问题，<strong>1、设备不止一个程序，具体发送给哪一个程序？2、没有保证数据包能发送成功。</strong></p><p>这时候就需要<a href="https://zh.wikipedia.org/wiki/传输层" target="_blank" rel="noopener">传输层</a>（Transport Layer），<strong>传输层的功能是保证数据能可靠传输到对方主机的应用程序上。</strong></p><p>应用是进程，<strong>每个进程使用网卡时，需要有一个编号，这个编号就是端口</strong>。系统默认占用 0 到 1023 的端口，系统会为软件随机分配 1024 到 65535 之间的端口。 常见术语套接字（Socket）就是 IP 地址 + 端口的组合称谓。</p><p>传输层要为发送的数据包中增加发送方和接收方的端口号。</p><p>传输层功能实现一般有两种协议，1 是 <a href="https://zh.wikipedia.org/wiki/传输控制协议" target="_blank" rel="noopener">TCP 协议</a>，2 是 <a href="https://zh.wikipedia.org/wiki/用户数据报协议" target="_blank" rel="noopener">UDP 协议</a>。</p><h3 id="5-1-TCP-协议"><a href="#5-1-TCP-协议" class="headerlink" title="5.1 TCP 协议"></a>5.1 TCP 协议</h3><blockquote><p><strong>TCP</strong> 协议，英语全称为：<strong>T</strong>ransmission <strong>C</strong>ontrol <strong>P</strong>rotocol，即，<strong>传输控制协议</strong></p></blockquote><p>TCP 协议使用用三次握手来保证线路的可靠，失败后，有失败重传机制，它是一个很复杂的协议，传输层的称谓，也是来源于 TCP 这个 <strong>传输控制协议</strong>。</p><p>TCP 协议发送的数据包叫 TCP 数据包，它的标头包含发送方端口和接收方端口，</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-17-141857.png" alt="图片来自阮一峰博客"></p><p>它发送数据包给网络层，网络层将 TCP 数据包作为 IP 数据包的数据部分，再发给链路层。此时以太帧格式如下：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-17-141939.png" alt="图片来自阮一峰博客"></p><p>因为以太帧有长度限制，TCP 协议没有规定数据的长度，所以当 TCP 数据包过长时，以太帧装不下，此时 TCP 数据包需要切分为多个 TCP 数据包。我们常常看到有的书籍说：传输层负责「请求报文」的分割。这就是传输层为什么要分割「请求报文」的缘故。</p><p>传输层保证数据的「可靠传输」，这句话常常被我们误解为，是由传输层传输数据，现在我们知道，传输数据的其实是链路层，传输层其实只是失败重传（当然不止这一个功能，这里这么说是为了方便理解）。所以这句话的重点在于<strong>可靠</strong>，不在传输。</p><h3 id="5-2-UDP-协议"><a href="#5-2-UDP-协议" class="headerlink" title="5.2 UDP 协议"></a>5.2 UDP 协议</h3><blockquote><p><strong>UDP 协议</strong>，英语全称为： <strong>U</strong>ser <strong>D</strong>atagram <strong>P</strong>rotocol，即<strong>用户数据包协议</strong></p></blockquote><p>传输层有一种简单的协议，叫 UDP 协议，UDP 协议只是为数据简单的加上包含发送方端口和接收方端口的标头，就将 UDP 数据包扔给网络层，它不保证是否能成功的发送给接收方，它是一种不可靠的传输协议。因为简单，减少了时间开销，常用于对时间有较高要求的应用程序。</p><h2 id="六、应用层（Application-Layer）"><a href="#六、应用层（Application-Layer）" class="headerlink" title="六、应用层（Application Layer）"></a>六、应用层（Application Layer）</h2><p>链路层、网络层、传输层实现了数据包能从主机应用发送到目的主机应用。正常情况下，网络上主要传输的数据是应用产生的。传输的数据各种各样，有网络请求，有电子邮件等等。数据需要由<a href="https://zh.wikipedia.org/wiki/应用层" target="_blank" rel="noopener">应用层</a>（Application Layer）封装，即规定数据的格式。</p><p>规定「HTML 数据」格式的是 <a href="https://zh.wikipedia.org/wiki/超文本传输协议" target="_blank" rel="noopener">HTTP 协议</a>。可以说，HTTP 协议是应用层的一种实现。</p><h3 id="6-1-HTTP-协议"><a href="#6-1-HTTP-协议" class="headerlink" title="6.1 HTTP 协议"></a>6.1 HTTP 协议</h3><blockquote><p><strong>HTTP 协议</strong>：英文全称为：H<strong>yper</strong>T<strong>ext **T</strong>ransfer <strong>P</strong>rotocol，即超文本转移（传输）协议</p></blockquote><p>当我们打开百度首页时，输入的就是一个网址 <code>www.baidu.com</code>，这是一个 GET 请求，HTTP 协议将请求封装为应用层数据包。这样，百度的服务器应用层就可以根据 HTTP 协议来解析数据包。</p><p>HTTP 请求的数据包一般称为请求报文，分为报文首部和报文主题，报文首部即为请求头，请求头格式如下：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-123839.jpg" alt=""></p><p>包含的应用层数据包的以太帧格式如下：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-17-143436.png" alt="图片来自阮一峰博客"></p><h3 id="6-2-DNS"><a href="#6-2-DNS" class="headerlink" title="6.2 DNS"></a>6.2 DNS</h3><blockquote><p> <strong>DNS</strong>：英语全称为： <strong>D</strong>omain <strong>N</strong>ame <strong>S</strong>ystem，即<strong>域名系统</strong></p></blockquote><p>类似  <code>www.baidu.com</code> 这样的网址域名，是为了用户方便记忆，网络通信时，需要将域名转换为 IP 地址，这是由 <a href="https://zh.wikipedia.org/wiki/域名系统" target="_blank" rel="noopener">DNS</a> 负责的，它也属于应用层。</p><h2 id="七、WireShark-抓包分析"><a href="#七、WireShark-抓包分析" class="headerlink" title="七、WireShark 抓包分析"></a>七、WireShark 抓包分析</h2><p>当 Mac 连 WIFI 后，可以在「设置-&gt;网络」中看见下面这些内容：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-123927.jpg" alt="TCP/IP"></p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-123948.jpg" alt="MAC 地址"></p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-124038.jpg" alt="DNS 地址"></p><p>此时电脑，有自己的 IP 地址、MAC 地址、还知道路由器的 IP 地址、DNS 服务器地址（由路由器负责域名解析，所以 DNS 地址其实就是 IP 地址）和当前的子网掩码。还可以看出，路由器动态分配 IP 地址是由 <a href="https://zh.wikipedia.org/wiki/动态主机设置协议" target="_blank" rel="noopener">DHCP</a> 实现的。</p><p>通过打开百度首页，结合抓包工具 Wireshark 来看看网络通信过程中的数据包的内容。</p><p>关于如何使用 Wireshark，请看 <a href="https://juejin.im/post/5c87059ae51d452f3f64b110" target="_blank" rel="noopener">使用 wireshark 学习网络协议</a>。通过 <code>ping www.baidu.com</code> 得到百度的 IP 地址为 <code>61.135.169.121</code>，在 Wireshark 中配置过滤条件后，通过使用命令 <code>curl www.baidu.com</code> 来模拟打开百度首页：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-124128.jpg" alt=""></p><p>此时在 Wireshark 中可以看出，TCP 协议发送了以太帧，以太帧的格式是：Ethernet II 标头 + IP 4 标头 + TCP 标头 + TCP 数据，TCP 标头显示源端口为 53732，目的地端口为 80；IP 标头显示源 IP 地址为 <code>192.168.31.206</code>，目的地 IP 地址为 <code>61.135.169.121</code>；以太网标头显示源 MAC 地址为 <code>f0:18:98:46:bf:65</code>，目的地 MAC 地址为 <code>28:6c:07:9d:e2:8e</code>（小米路由器地址）。帧的长度为 78 字节，TCP 数据包的长度为 44 个字节。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-124202.jpg" alt=""></p><p>这与我们前面说的相符合，目的主机不在同一个局域网，通过以太网发送以太帧给路由器，再由路由器负责路由发送。</p><p>前三个数据包为 TCP 的 3 次握手，接着发送了 HTTP 数据包，HTTP 数据包包含了请求的内容：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-124319.jpg" alt="">整个过程：先使用 TCP 协议完成了 3 次握手，然后使用 HTTP 协议发送了 GET 请求，接收到了百度的 HTTP 响应，最后使用 TCP 协议完成了 4 次挥手。</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-124357.jpg" alt=""></p><h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>互联网协议整个网络通信过程可以用下面这张图描述：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-083129.png" alt="图片来自 Wiki"></p><p>对于发送方的数据处理，<strong>这个过程像是一个俄罗斯套娃的过程</strong>：</p><p><img src="https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-17-150358.png" alt="图片来自 Wiki"></p><p>如果用发快递来类比一下：</p><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">应用层：将物体打包为快递  </span><br><span class="line">      <span class="string">|</span></span><br><span class="line">传输层：为快递填上收件人门牌号；如果快递丢失重新发送</span><br><span class="line">      <span class="string">|</span></span><br><span class="line">网络层：为快递填上收件人小区地址；并根据收件人小区地址，找到下一个快递中转站的地址，最终找到整个线路</span><br><span class="line">      <span class="string">|</span></span><br><span class="line">链路层：为快递填上下一个中转地地址；并负责将快递发往到下一个中转站</span><br><span class="line">      <span class="string">|</span></span><br><span class="line">物理层：运快递的车</span><br></pre></td></tr></table></figure><p>在互联网协议中，因为 TCP/IP 协议最重要，所以互联网协议也可以叫做 「<strong>TCP/IP 协议族</strong>」。</p><p>此文只是个人对互联网协议的浅显理解，毕竟没有深入研究，可能有诸多不当处，欢迎留言指出。</p><p>最后我想说一句，阮一峰牛逼。有的知识点是知道怎么回事，就是不能正确的表达出来，遣词排句真的很需要功力，真的需要常年累月的积累。</p><!--解疑现在来说说，为什么说 SpringCloud 基于 HTTP 协议，Dubbo 基于 TCP 协议。我是这么理解的，因为 SpringClout 框架直接接受 HTTP 请求，而 Dubbo 让数据没有使用 HTTP 协议包装数据包。直接将数据包装为 TCP 数据包。--><h2 id="九、延伸阅读"><a href="#九、延伸阅读" class="headerlink" title="九、延伸阅读"></a>九、延伸阅读</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="noopener">互联网协议入门（一）<em>阮一峰</em></a></li><li><a href="http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html" target="_blank" rel="noopener">互联网协议入门（二）<em>阮一峰</em></a></li><li><a href="https://juejin.im/post/5c87059ae51d452f3f64b110" target="_blank" rel="noopener">使用wireshark学习网络协议</a></li></ul>]]></content:encoded>
      
      <comments>https://depp.wang/2020/03/20/internet-protocol-suite-introduction/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hexo + NexT 博客优化（修改）记录</title>
      <link>https://depp.wang/2020/03/12/hexo-next-all-change/</link>
      <guid>https://depp.wang/2020/03/12/hexo-next-all-change/</guid>
      <pubDate>Thu, 12 Mar 2020 20:48:37 GMT</pubDate>
      <description>
      
        &lt;p&gt;有问题建议先看&lt;a href=&quot;https://theme-next.iissnan.com/faqs.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;，和 &lt;a href=&quot;https://github.com/iissnan/hexo-theme-next/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;issue&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、样式修改&quot;&gt;&lt;a href=&quot;#一、样式修改&quot; class=&quot;headerlink&quot; title=&quot;一、样式修改&quot;&gt;&lt;/a&gt;一、样式修改&lt;/h2&gt;&lt;p&gt;注意：重新部署后，样式若没更新，清除浏览器缓存&lt;/p&gt;
&lt;h3 id=&quot;分类横向展示&quot;&gt;&lt;a href=&quot;#分类横向展示&quot; class=&quot;headerlink&quot; title=&quot;分类横向展示&quot;&gt;&lt;/a&gt;分类横向展示&lt;/h3&gt;&lt;p&gt;&lt;code&gt;themes\next\source\css\_common\component\pages\categories.styl&lt;/code&gt; 中修改：&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-class&quot;&gt;.category-list-item&lt;/span&gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;margin&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;5px&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;10px&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  display: inline-block; // 新增&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;display: inline-block&lt;/code&gt;：可以不换行，让其他元素元素显示在旁边；并且可以设置高度。&lt;a href=&quot;https://www.w3schools.com/css/css_inline-block.asp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;w3schools: CSS Layout - display: inline-block&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>有问题建议先看<a href="https://theme-next.iissnan.com/faqs.html" target="_blank" rel="noopener">官方文档</a>，和 <a href="https://github.com/iissnan/hexo-theme-next/issues" target="_blank" rel="noopener">issue</a></p><h2 id="一、样式修改"><a href="#一、样式修改" class="headerlink" title="一、样式修改"></a>一、样式修改</h2><p>注意：重新部署后，样式若没更新，清除浏览器缓存</p><h3 id="分类横向展示"><a href="#分类横向展示" class="headerlink" title="分类横向展示"></a>分类横向展示</h3><p><code>themes\next\source\css\_common\component\pages\categories.styl</code> 中修改：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.category-list-item</span> &#123; </span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">5px</span> <span class="number">10px</span>; </span><br><span class="line">  display: inline-block; // 新增</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>display: inline-block</code>：可以不换行，让其他元素元素显示在旁边；并且可以设置高度。<a href="https://www.w3schools.com/css/css_inline-block.asp" target="_blank" rel="noopener">w3schools: CSS Layout - display: inline-block</a></li></ul><a id="more"></a><h3 id="设置图片居中"><a href="#设置图片居中" class="headerlink" title="设置图片居中"></a>设置图片居中</h3><p>Mist 主题： <code>themes\next\source\css\_schemes\Mist\_posts-expanded.styl</code> 中修改</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">.post-body img &#123; margin: auto; &#125; // 0 - &gt; auto</span><br></pre></td></tr></table></figure><ul><li>_schemes：方案</li><li>图片链接格式不为 <code>![]()</code> 时，需要用 <code>&lt;p&gt;&lt;/p&gt;</code> 包裹，此时图片才有间距</li></ul><h3 id="设置字体大小"><a href="#设置字体大小" class="headerlink" title="设置字体大小"></a>设置字体大小</h3><p><code>themes\next\source\css\_custom\custom.styl</code> 中新增：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正文字体的大小</span></span><br><span class="line"><span class="variable">$font</span>-size-base = <span class="number">15px</span> <span class="comment">// 原 14 px</span></span><br></pre></td></tr></table></figure><ul><li><code>_custom\custom.styl</code> 为全局自定义样式</li><li>如果未生效，在 <code>themes\next\source\css\_variables\base.styl</code> 中修改</li></ul><h3 id="更改内容区域的宽度（已还原）"><a href="#更改内容区域的宽度（已还原）" class="headerlink" title="更改内容区域的宽度（已还原）"></a>更改内容区域的宽度（已还原）</h3><p><code>themes\next\source\css\_custom\custom.styl</code> 中新增：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改成你期望的宽度</span></span><br><span class="line"><span class="variable">$content</span>-desktop = <span class="number">800px</span> <span class="comment">// 原 700px</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当视窗超过 1600px 后的宽度</span></span><br><span class="line"><span class="variable">$content</span>-desktop-large = <span class="number">1000px</span> <span class="comment">// 原 900px</span></span><br></pre></td></tr></table></figure><ul><li>如果未生效，在 <code>themes\next\source\css\_variables\base.styl</code> 中修改</li></ul><h3 id="更改-h1-h2-字体大小"><a href="#更改-h1-h2-字体大小" class="headerlink" title="更改 h1 h2 字体大小"></a>更改 h1 h2 字体大小</h3><p>在 <code>themes\next\source\css\_custom\custom.styl</code> 中新增：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Custom styles.</span></span><br><span class="line"><span class="comment">// 新增</span></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2em</span>; <span class="comment">// 2em = 32px</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.5em</span>; <span class="comment">// 1.5em = 24px, 1em = 16px</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>em: <a href="https://www.w3.org/Style/Examples/007/units.en.html#translations#:~:text=use%20the%20default%20size%20of%20the%20device" target="_blank" rel="noopener">use the default size of the device</a>，即根据正文字体的大小决定</li></ul><h3 id="设置-h2-下划线"><a href="#设置-h2-下划线" class="headerlink" title="设置 h2 下划线"></a>设置 h2 下划线</h3><p> <code>themes\next\source\css\_common\component\post\post-expand.styl</code> 中修改</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.posts-expand</span> <span class="selector-class">.post-body</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  // 新增</span><br><span class="line">  <span class="selector-tag">h1</span>, <span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: .<span class="number">3em</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#eaecef</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>也可以在  <code>themes\next\source\css\_schemes\Mist\_posts-expanded.styl</code> 修改？</li><li>只为文章内容中的 h1 h2 标题添加下划线</li></ul><h3 id="修改-h1-h2-h3-h4-间距"><a href="#修改-h1-h2-h3-h4-间距" class="headerlink" title="修改 h1 h2 h3 h4 间距"></a>修改 h1 h2 h3 h4 间距</h3><p>在 <code>themes\next\source\css\_custom\custom.styl</code> 中新增：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, <span class="selector-tag">h6</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!--正常来说，标题和段落之间就要要比段落与段落之间隔得近？--><h3 id="URL-中文改为英文"><a href="#URL-中文改为英文" class="headerlink" title="URL 中文改为英文"></a>URL 中文改为英文</h3><p>文章标题块添加 english-tile，<code>站点配置文件</code>修改 permalink</p><p><code>站点配置文件</code>设置 tag_map、category_map</p><h2 id="二、功能添加"><a href="#二、功能添加" class="headerlink" title="二、功能添加"></a>二、功能添加</h2><ul><li>底部添加版权声明、微信公众号图片、分享按钮</li></ul><h3 id="添加-Disqus-评论"><a href="#添加-Disqus-评论" class="headerlink" title="添加 Disqus 评论"></a>添加 Disqus 评论</h3><p>教程：<a href="https://depp.wang/2017/06/15/hexo-disqus">Hexo 添加 Disqus 评论</a></p><p>缺点：只能科学上网后才能评论</p><hr><h5 id="也可以使用-Gitalk"><a href="#也可以使用-Gitalk" class="headerlink" title="也可以使用 Gitalk"></a>也可以使用 <a href="https://github.com/gitalk/gitalk" target="_blank" rel="noopener">Gitalk</a></h5><p>教程：</p><ul><li><a href="https://asdfv1929.github.io/2018/01/20/gitalk/" target="_blank" rel="noopener">使用 gitalk 评论插件</a></li><li><a href="https://liujunzhou.top/2018/8/10/gitalk-error/" target="_blank" rel="noopener">gitalk-error</a></li><li><a href="https://priesttomb.github.io/%E6%97%A5%E5%B8%B8/2018/02/12/%E5%A4%84%E7%90%86Gitalk%E4%B8%AD%E7%94%B1%E4%BA%8E%E6%96%87%E7%AB%A0URL%E8%BF%87%E9%95%BF%E5%AF%BC%E8%87%B4%E7%9A%84Validation-Failed(422)/" target="_blank" rel="noopener">处理Gitalk中由于文章URL过长导致的Validation Failed(422)</a></li></ul><p>缺点：发布文章后需要页面点击初始化；issue 不美观</p><h3 id="添加-Algolia-搜索"><a href="#添加-Algolia-搜索" class="headerlink" title="添加 Algolia 搜索"></a>添加 Algolia 搜索</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export HEXO_ALGOLIA_INDEXING_KEY=*** # 使用 export 临时设置一个环境变量</span><br><span class="line">echo $HEXO_ALGOLIA_INDEXING_KEY      # 查看环境变量是否设置成功</span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li><a href="https://www.npmjs.com/package/hexo-algolia" target="_blank" rel="noopener">hexo-algolia</a> 和  <a href="https://www.npmjs.com/package/hexo-algoliasearch" target="_blank" rel="noopener">hexo-algoliasearch</a> 不要同时使用</li><li>使用 hexo-algolia 时，如果你删除了文章，需要更新 Algolia 里面的链接，需要使用 <code>hexo algolia --flush true</code> 命令</li></ol><p>hexo-algolia 模块的作用：将博客文章链接发送给自己的 Algolia 账户。搜索原理：输入关键字，调用 Algolia 提供接口，返回相应文章链接</p><p>可参考教程：</p><ul><li><a href="https://juejin.im/post/5af3f9d1518825673e35a6eb" target="_blank" rel="noopener">Hexo + Next 集成 Algolia 搜索</a></li><li><a href="http://theme-next.iissnan.com/third-party-services.html#algolia-search" target="_blank" rel="noopener">Next Algolia</a> </li></ul><p>缺点：</p><ol><li>新增文章后需要运行 <code>hexo algolia</code> 将当前文章发送到 Algolia</li><li>删除文章后还能搜索到，需要再次去 Algolia 删除？可使用  <code>hexo algolia --flush true</code> 命令更新</li></ol><p>可能遇到的问题：</p><ul><li>每次运行 <code>hexo algolia</code> 都需要设置环境变量，解决方式：直接「永久」设置环境变量</li></ul><p>macOS「永久」设置环境变量：</p><ul><li>默认为 bash，修改 .bash_profile</li><li>如果为 oh-my-zsh，修改 .zshrc</li><li>打印环境变量命令：printenv</li></ul><h3 id="添加文章阅读次数统计、网站访问次数统计"><a href="#添加文章阅读次数统计、网站访问次数统计" class="headerlink" title="添加文章阅读次数统计、网站访问次数统计"></a>添加文章阅读次数统计、网站访问次数统计</h3><p>可参考文章：<a href="https://depp.wang/2017/06/14/hexo-statistical/">Hexo 添加不蒜子和 LeanCloud 统计</a></p><h2 id="三、外部设置"><a href="#三、外部设置" class="headerlink" title="三、外部设置"></a>三、外部设置</h2><ul><li><a href="https://depp.wang/2020/02/17/use-github-actions-to-achieve-hexo-blog-auto-deploy/">使用 GitHub Actions 实现 Hexo 博客自动部署</a></li></ul><h3 id="自定义域名加密为-HTTPS"><a href="#自定义域名加密为-HTTPS" class="headerlink" title="自定义域名加密为 HTTPS"></a>自定义域名加密为 HTTPS</h3><p>直接利用 <a href="https://www.cloudflare.com/" target="_blank" rel="noopener">cloudfire</a> 加密网站</p><p>访问域名时，需要先由 DNS 服务来将域名解析为 ip 地址</p><p>DNS 服务器负责域名解析，需要先将域名的 DNS 服务器修改为  cloudfire 的服务器，由 cloudfiere 的 DNS 服务器负责域名解析，在 cloudfire 中设置规则，如：将 depp.wang 解析到 deppwang.gihub.io</p><p>在项目 GitHub Pages 中设置：访问 deppwang.gihub.io 重定向到 depp.wang，访问 depp.wang 时，cloudfiere 的 DNS 服务器又将 depp.wang 指向到 deppwang.github.io，最终访问的还是 deppwang.github.io。ping depp.wang  会发现是 github 节点，如果 ip 地址为  cloudfiere 节点，那是因为 cloudfiere 设置了代理。</p><ul><li>DNS：Domain Name System 域名系统</li></ul><p>可参考文章：<a href="https://crossoverjie.top/%2F2017%2F05%2F07%2Fhttps%2Fl" target="_blank" rel="noopener">科普-为自己的博客免费加上小绿锁</a></p><h3 id="提交到-Google-搜索引擎"><a href="#提交到-Google-搜索引擎" class="headerlink" title="提交到 Google 搜索引擎"></a>提交到 Google 搜索引擎</h3><p>一般不主动提交 url  给 Google 搜索引擎，Google 也可以凭借强大的爬虫（蜘蛛）抓取你网址的 url，但为了让谷歌更好更快的抓取你的文章，还是给他提供一个参考，一个站点地图（sitemap.xml）</p><p>先在 <a href="https://search.google.com/search-console" target="_blank" rel="noopener">Search Console</a> 验证你拥有网站的所有权，可以使用 HTML 文件、HTML 标记等方式验证。将 HTML 文件添加到网站中。每个用户拥有自己的 HTML 文件，如果网站有多个管理员，每个管理员的 HTML 文件不同。</p><p>如果使用 HTML 文件验证失败，HTML 文件添加 <code>layout: false</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">layout: false</span><br><span class="line">---</span><br><span class="line">google-site-verification: googlec27ee4754ff2e800.html</span><br></pre></td></tr></table></figure><p>使用 <a href="https://github.com/hexojs/hexo-generator-sitemap/" target="_blank" rel="noopener">hexo-generator-sitemap</a> 包生成站点地图，hexo-generator-sitemap 包的作用：</p><ul><li>每次 <code>hexo g</code> 时，根据 _post 的文章生成站点地图：sitemap.xml。插件默认根据最近修改时间生成 sitemap 中的  <code>&lt;lastmod&gt;</code>，如果使用 <a href="https://github.com/DeppWang/hexo-action" target="_blank" rel="noopener">hexo-action</a>，需要添加 sitemap 模板（<code>/source/sitemap_template.xml</code>），使用文章的 date</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">urlset</span> <span class="attr">xmlns</span>=<span class="string">"http://www.sitemaps.org/schemas/sitemap/0.9"</span>&gt;</span></span><br><span class="line">  &#123;% for post in posts %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">loc</span>&gt;</span>&#123;&#123; post.permalink | uriencode &#125;&#125;<span class="tag">&lt;/<span class="name">loc</span>&gt;</span></span><br><span class="line">    &#123;% if post.date %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">lastmod</span>&gt;</span>&#123;&#123; post.date.toISOString().substring(0, 10) &#125;&#125;<span class="tag">&lt;/<span class="name">lastmod</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  &#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">urlset</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># _config.yml</span></span><br><span class="line"><span class="attr">sitemap:</span></span><br><span class="line"><span class="attr">  template:</span> <span class="string">./source/sitemap_template.xml</span></span><br></pre></td></tr></table></figure><p>正常来说，当添加了 sitemap，Google 将定期抓取你设置的 sitemap</p><ul><li>站点地图抓取时间不更新解释：<a href="https://metinsaylan.com/9642/how-to-solve-search-console-sitemap-could-not-be-read-error/" target="_blank" rel="noopener">[How To] Solve Search Console “Sitemap could not be read” Error</a></li></ul><p>sitemap 的 <code>&lt;lastmod&gt;</code> 应该对应 <a href="https://github.com/deppwang/deppwang.github.io" target="_blank" rel="noopener">deppwang.github.io</a> 的 html 文件的最近修改时间，sitemap 的最新文章的 url 的 <code>lastmod</code> 是对的，但其他 url 的时间不一定是对的。因为 Hexo 每次发布基本上都会更新所有文章 <code>og:updated_time</code> 改变。所以 GCS 是否因为文章时间对应不上而不抓取？或者因为网站权重太低？</p><p>如果 sitemap 不能读取，也可以设置 atom.xml</p><ul><li><a href="https://github.com/hexojs/hexo-generator-sitemap/issues/92" target="_blank" rel="noopener">https://github.com/hexojs/hexo-generator-sitemap/issues/92</a></li></ul><h2 id="四、其他可能遇到的问题"><a href="#四、其他可能遇到的问题" class="headerlink" title="四、其他可能遇到的问题"></a>四、其他可能遇到的问题</h2><ul><li>Google 不收录网址的问题</li><li>博客源文件每次被覆盖的问题</li></ul><h3 id="头像下网址描述不显示问题"><a href="#头像下网址描述不显示问题" class="headerlink" title="头像下网址描述不显示问题"></a>头像下网址描述不显示问题</h3><p>可能是你在 <code>主题配置文件</code> 中开起了 SEO，SEO 覆盖掉了原来的代码</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">seo:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>目测开启没有什么效果，可以关闭解决。也可以修改源代码</p><p>思路：找到不显示字样的 class，IDEA 打开文件，全局搜索 class，找到代码位置，进行修改</p><p>修改文件位置</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/next/</span>layout<span class="regexp">/_macro/</span>sidebar.swig</span><br></pre></td></tr></table></figure><p><code>theme.signature</code> 修改为 <code>config.description</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"site-description motion-element"</span> <span class="attr">itemprop</span>=<span class="string">"description"</span>&gt;</span>&#123;&#123; config.description &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>SEO: Search engine optimization 搜索引擎优化</li></ul>]]></content:encoded>
      
      <comments>https://depp.wang/2020/03/12/hexo-next-all-change/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
